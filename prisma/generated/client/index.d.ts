
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model uzytkownicy
 * 
 */
export type uzytkownicy = $Result.DefaultSelection<Prisma.$uzytkownicyPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model artykuly
 * 
 */
export type artykuly = $Result.DefaultSelection<Prisma.$artykulyPayload>
/**
 * Model kategorieartykulow
 * 
 */
export type kategorieartykulow = $Result.DefaultSelection<Prisma.$kategorieartykulowPayload>
/**
 * Model produkty
 * 
 */
export type produkty = $Result.DefaultSelection<Prisma.$produktyPayload>
/**
 * Model kategorieproduktow
 * 
 */
export type kategorieproduktow = $Result.DefaultSelection<Prisma.$kategorieproduktowPayload>
/**
 * Model zamowienia
 * 
 */
export type zamowienia = $Result.DefaultSelection<Prisma.$zamowieniaPayload>
/**
 * Model statusyzamowien
 * 
 */
export type statusyzamowien = $Result.DefaultSelection<Prisma.$statusyzamowienPayload>
/**
 * Model zlecenia
 * 
 */
export type zlecenia = $Result.DefaultSelection<Prisma.$zleceniaPayload>
/**
 * Model statusyzlecen
 * 
 */
export type statusyzlecen = $Result.DefaultSelection<Prisma.$statusyzlecenPayload>
/**
 * Model typyzlecen
 * 
 */
export type typyzlecen = $Result.DefaultSelection<Prisma.$typyzlecenPayload>
/**
 * Model projekty
 * 
 */
export type projekty = $Result.DefaultSelection<Prisma.$projektyPayload>
/**
 * Model statusyprojektow
 * 
 */
export type statusyprojektow = $Result.DefaultSelection<Prisma.$statusyprojektowPayload>
/**
 * Model producentkatalog
 * 
 */
export type producentkatalog = $Result.DefaultSelection<Prisma.$producentkatalogPayload>
/**
 * Model kategorieproducentow
 * 
 */
export type kategorieproducentow = $Result.DefaultSelection<Prisma.$kategorieproducentowPayload>
/**
 * Model podwykonawcy
 * 
 */
export type podwykonawcy = $Result.DefaultSelection<Prisma.$podwykonawcyPayload>
/**
 * Model freelancerzy
 * 
 */
export type freelancerzy = $Result.DefaultSelection<Prisma.$freelancerzyPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Uzytkownicies
 * const uzytkownicies = await prisma.uzytkownicy.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Uzytkownicies
   * const uzytkownicies = await prisma.uzytkownicy.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.uzytkownicy`: Exposes CRUD operations for the **uzytkownicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uzytkownicies
    * const uzytkownicies = await prisma.uzytkownicy.findMany()
    * ```
    */
  get uzytkownicy(): Prisma.uzytkownicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artykuly`: Exposes CRUD operations for the **artykuly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artykulies
    * const artykulies = await prisma.artykuly.findMany()
    * ```
    */
  get artykuly(): Prisma.artykulyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kategorieartykulow`: Exposes CRUD operations for the **kategorieartykulow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kategorieartykulows
    * const kategorieartykulows = await prisma.kategorieartykulow.findMany()
    * ```
    */
  get kategorieartykulow(): Prisma.kategorieartykulowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.produkty`: Exposes CRUD operations for the **produkty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produkties
    * const produkties = await prisma.produkty.findMany()
    * ```
    */
  get produkty(): Prisma.produktyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kategorieproduktow`: Exposes CRUD operations for the **kategorieproduktow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kategorieproduktows
    * const kategorieproduktows = await prisma.kategorieproduktow.findMany()
    * ```
    */
  get kategorieproduktow(): Prisma.kategorieproduktowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zamowienia`: Exposes CRUD operations for the **zamowienia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zamowienias
    * const zamowienias = await prisma.zamowienia.findMany()
    * ```
    */
  get zamowienia(): Prisma.zamowieniaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusyzamowien`: Exposes CRUD operations for the **statusyzamowien** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statusyzamowiens
    * const statusyzamowiens = await prisma.statusyzamowien.findMany()
    * ```
    */
  get statusyzamowien(): Prisma.statusyzamowienDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zlecenia`: Exposes CRUD operations for the **zlecenia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zlecenias
    * const zlecenias = await prisma.zlecenia.findMany()
    * ```
    */
  get zlecenia(): Prisma.zleceniaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusyzlecen`: Exposes CRUD operations for the **statusyzlecen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statusyzlecens
    * const statusyzlecens = await prisma.statusyzlecen.findMany()
    * ```
    */
  get statusyzlecen(): Prisma.statusyzlecenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.typyzlecen`: Exposes CRUD operations for the **typyzlecen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Typyzlecens
    * const typyzlecens = await prisma.typyzlecen.findMany()
    * ```
    */
  get typyzlecen(): Prisma.typyzlecenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projekty`: Exposes CRUD operations for the **projekty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projekties
    * const projekties = await prisma.projekty.findMany()
    * ```
    */
  get projekty(): Prisma.projektyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusyprojektow`: Exposes CRUD operations for the **statusyprojektow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statusyprojektows
    * const statusyprojektows = await prisma.statusyprojektow.findMany()
    * ```
    */
  get statusyprojektow(): Prisma.statusyprojektowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.producentkatalog`: Exposes CRUD operations for the **producentkatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Producentkatalogs
    * const producentkatalogs = await prisma.producentkatalog.findMany()
    * ```
    */
  get producentkatalog(): Prisma.producentkatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kategorieproducentow`: Exposes CRUD operations for the **kategorieproducentow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kategorieproducentows
    * const kategorieproducentows = await prisma.kategorieproducentow.findMany()
    * ```
    */
  get kategorieproducentow(): Prisma.kategorieproducentowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.podwykonawcy`: Exposes CRUD operations for the **podwykonawcy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Podwykonawcies
    * const podwykonawcies = await prisma.podwykonawcy.findMany()
    * ```
    */
  get podwykonawcy(): Prisma.podwykonawcyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelancerzy`: Exposes CRUD operations for the **freelancerzy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Freelancerzies
    * const freelancerzies = await prisma.freelancerzy.findMany()
    * ```
    */
  get freelancerzy(): Prisma.freelancerzyDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    uzytkownicy: 'uzytkownicy',
    role: 'role',
    artykuly: 'artykuly',
    kategorieartykulow: 'kategorieartykulow',
    produkty: 'produkty',
    kategorieproduktow: 'kategorieproduktow',
    zamowienia: 'zamowienia',
    statusyzamowien: 'statusyzamowien',
    zlecenia: 'zlecenia',
    statusyzlecen: 'statusyzlecen',
    typyzlecen: 'typyzlecen',
    projekty: 'projekty',
    statusyprojektow: 'statusyprojektow',
    producentkatalog: 'producentkatalog',
    kategorieproducentow: 'kategorieproducentow',
    podwykonawcy: 'podwykonawcy',
    freelancerzy: 'freelancerzy'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "uzytkownicy" | "role" | "artykuly" | "kategorieartykulow" | "produkty" | "kategorieproduktow" | "zamowienia" | "statusyzamowien" | "zlecenia" | "statusyzlecen" | "typyzlecen" | "projekty" | "statusyprojektow" | "producentkatalog" | "kategorieproducentow" | "podwykonawcy" | "freelancerzy"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      uzytkownicy: {
        payload: Prisma.$uzytkownicyPayload<ExtArgs>
        fields: Prisma.uzytkownicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.uzytkownicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.uzytkownicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>
          }
          findFirst: {
            args: Prisma.uzytkownicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.uzytkownicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>
          }
          findMany: {
            args: Prisma.uzytkownicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>[]
          }
          create: {
            args: Prisma.uzytkownicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>
          }
          createMany: {
            args: Prisma.uzytkownicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.uzytkownicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>[]
          }
          delete: {
            args: Prisma.uzytkownicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>
          }
          update: {
            args: Prisma.uzytkownicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>
          }
          deleteMany: {
            args: Prisma.uzytkownicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.uzytkownicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.uzytkownicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>[]
          }
          upsert: {
            args: Prisma.uzytkownicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uzytkownicyPayload>
          }
          aggregate: {
            args: Prisma.UzytkownicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUzytkownicy>
          }
          groupBy: {
            args: Prisma.uzytkownicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UzytkownicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.uzytkownicyCountArgs<ExtArgs>
            result: $Utils.Optional<UzytkownicyCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      artykuly: {
        payload: Prisma.$artykulyPayload<ExtArgs>
        fields: Prisma.artykulyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.artykulyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.artykulyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>
          }
          findFirst: {
            args: Prisma.artykulyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.artykulyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>
          }
          findMany: {
            args: Prisma.artykulyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>[]
          }
          create: {
            args: Prisma.artykulyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>
          }
          createMany: {
            args: Prisma.artykulyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.artykulyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>[]
          }
          delete: {
            args: Prisma.artykulyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>
          }
          update: {
            args: Prisma.artykulyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>
          }
          deleteMany: {
            args: Prisma.artykulyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.artykulyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.artykulyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>[]
          }
          upsert: {
            args: Prisma.artykulyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$artykulyPayload>
          }
          aggregate: {
            args: Prisma.ArtykulyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtykuly>
          }
          groupBy: {
            args: Prisma.artykulyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtykulyGroupByOutputType>[]
          }
          count: {
            args: Prisma.artykulyCountArgs<ExtArgs>
            result: $Utils.Optional<ArtykulyCountAggregateOutputType> | number
          }
        }
      }
      kategorieartykulow: {
        payload: Prisma.$kategorieartykulowPayload<ExtArgs>
        fields: Prisma.kategorieartykulowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kategorieartykulowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kategorieartykulowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>
          }
          findFirst: {
            args: Prisma.kategorieartykulowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kategorieartykulowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>
          }
          findMany: {
            args: Prisma.kategorieartykulowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>[]
          }
          create: {
            args: Prisma.kategorieartykulowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>
          }
          createMany: {
            args: Prisma.kategorieartykulowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.kategorieartykulowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>[]
          }
          delete: {
            args: Prisma.kategorieartykulowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>
          }
          update: {
            args: Prisma.kategorieartykulowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>
          }
          deleteMany: {
            args: Prisma.kategorieartykulowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kategorieartykulowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.kategorieartykulowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>[]
          }
          upsert: {
            args: Prisma.kategorieartykulowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieartykulowPayload>
          }
          aggregate: {
            args: Prisma.KategorieartykulowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKategorieartykulow>
          }
          groupBy: {
            args: Prisma.kategorieartykulowGroupByArgs<ExtArgs>
            result: $Utils.Optional<KategorieartykulowGroupByOutputType>[]
          }
          count: {
            args: Prisma.kategorieartykulowCountArgs<ExtArgs>
            result: $Utils.Optional<KategorieartykulowCountAggregateOutputType> | number
          }
        }
      }
      produkty: {
        payload: Prisma.$produktyPayload<ExtArgs>
        fields: Prisma.produktyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produktyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produktyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>
          }
          findFirst: {
            args: Prisma.produktyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produktyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>
          }
          findMany: {
            args: Prisma.produktyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>[]
          }
          create: {
            args: Prisma.produktyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>
          }
          createMany: {
            args: Prisma.produktyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.produktyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>[]
          }
          delete: {
            args: Prisma.produktyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>
          }
          update: {
            args: Prisma.produktyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>
          }
          deleteMany: {
            args: Prisma.produktyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.produktyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.produktyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>[]
          }
          upsert: {
            args: Prisma.produktyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produktyPayload>
          }
          aggregate: {
            args: Prisma.ProduktyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProdukty>
          }
          groupBy: {
            args: Prisma.produktyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProduktyGroupByOutputType>[]
          }
          count: {
            args: Prisma.produktyCountArgs<ExtArgs>
            result: $Utils.Optional<ProduktyCountAggregateOutputType> | number
          }
        }
      }
      kategorieproduktow: {
        payload: Prisma.$kategorieproduktowPayload<ExtArgs>
        fields: Prisma.kategorieproduktowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kategorieproduktowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kategorieproduktowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>
          }
          findFirst: {
            args: Prisma.kategorieproduktowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kategorieproduktowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>
          }
          findMany: {
            args: Prisma.kategorieproduktowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>[]
          }
          create: {
            args: Prisma.kategorieproduktowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>
          }
          createMany: {
            args: Prisma.kategorieproduktowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.kategorieproduktowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>[]
          }
          delete: {
            args: Prisma.kategorieproduktowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>
          }
          update: {
            args: Prisma.kategorieproduktowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>
          }
          deleteMany: {
            args: Prisma.kategorieproduktowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kategorieproduktowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.kategorieproduktowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>[]
          }
          upsert: {
            args: Prisma.kategorieproduktowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproduktowPayload>
          }
          aggregate: {
            args: Prisma.KategorieproduktowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKategorieproduktow>
          }
          groupBy: {
            args: Prisma.kategorieproduktowGroupByArgs<ExtArgs>
            result: $Utils.Optional<KategorieproduktowGroupByOutputType>[]
          }
          count: {
            args: Prisma.kategorieproduktowCountArgs<ExtArgs>
            result: $Utils.Optional<KategorieproduktowCountAggregateOutputType> | number
          }
        }
      }
      zamowienia: {
        payload: Prisma.$zamowieniaPayload<ExtArgs>
        fields: Prisma.zamowieniaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zamowieniaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zamowieniaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>
          }
          findFirst: {
            args: Prisma.zamowieniaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zamowieniaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>
          }
          findMany: {
            args: Prisma.zamowieniaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>[]
          }
          create: {
            args: Prisma.zamowieniaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>
          }
          createMany: {
            args: Prisma.zamowieniaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zamowieniaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>[]
          }
          delete: {
            args: Prisma.zamowieniaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>
          }
          update: {
            args: Prisma.zamowieniaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>
          }
          deleteMany: {
            args: Prisma.zamowieniaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zamowieniaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zamowieniaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>[]
          }
          upsert: {
            args: Prisma.zamowieniaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zamowieniaPayload>
          }
          aggregate: {
            args: Prisma.ZamowieniaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZamowienia>
          }
          groupBy: {
            args: Prisma.zamowieniaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZamowieniaGroupByOutputType>[]
          }
          count: {
            args: Prisma.zamowieniaCountArgs<ExtArgs>
            result: $Utils.Optional<ZamowieniaCountAggregateOutputType> | number
          }
        }
      }
      statusyzamowien: {
        payload: Prisma.$statusyzamowienPayload<ExtArgs>
        fields: Prisma.statusyzamowienFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statusyzamowienFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statusyzamowienFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>
          }
          findFirst: {
            args: Prisma.statusyzamowienFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statusyzamowienFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>
          }
          findMany: {
            args: Prisma.statusyzamowienFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>[]
          }
          create: {
            args: Prisma.statusyzamowienCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>
          }
          createMany: {
            args: Prisma.statusyzamowienCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.statusyzamowienCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>[]
          }
          delete: {
            args: Prisma.statusyzamowienDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>
          }
          update: {
            args: Prisma.statusyzamowienUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>
          }
          deleteMany: {
            args: Prisma.statusyzamowienDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statusyzamowienUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.statusyzamowienUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>[]
          }
          upsert: {
            args: Prisma.statusyzamowienUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzamowienPayload>
          }
          aggregate: {
            args: Prisma.StatusyzamowienAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusyzamowien>
          }
          groupBy: {
            args: Prisma.statusyzamowienGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusyzamowienGroupByOutputType>[]
          }
          count: {
            args: Prisma.statusyzamowienCountArgs<ExtArgs>
            result: $Utils.Optional<StatusyzamowienCountAggregateOutputType> | number
          }
        }
      }
      zlecenia: {
        payload: Prisma.$zleceniaPayload<ExtArgs>
        fields: Prisma.zleceniaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zleceniaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zleceniaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>
          }
          findFirst: {
            args: Prisma.zleceniaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zleceniaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>
          }
          findMany: {
            args: Prisma.zleceniaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>[]
          }
          create: {
            args: Prisma.zleceniaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>
          }
          createMany: {
            args: Prisma.zleceniaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zleceniaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>[]
          }
          delete: {
            args: Prisma.zleceniaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>
          }
          update: {
            args: Prisma.zleceniaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>
          }
          deleteMany: {
            args: Prisma.zleceniaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zleceniaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zleceniaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>[]
          }
          upsert: {
            args: Prisma.zleceniaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zleceniaPayload>
          }
          aggregate: {
            args: Prisma.ZleceniaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZlecenia>
          }
          groupBy: {
            args: Prisma.zleceniaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZleceniaGroupByOutputType>[]
          }
          count: {
            args: Prisma.zleceniaCountArgs<ExtArgs>
            result: $Utils.Optional<ZleceniaCountAggregateOutputType> | number
          }
        }
      }
      statusyzlecen: {
        payload: Prisma.$statusyzlecenPayload<ExtArgs>
        fields: Prisma.statusyzlecenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statusyzlecenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statusyzlecenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>
          }
          findFirst: {
            args: Prisma.statusyzlecenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statusyzlecenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>
          }
          findMany: {
            args: Prisma.statusyzlecenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>[]
          }
          create: {
            args: Prisma.statusyzlecenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>
          }
          createMany: {
            args: Prisma.statusyzlecenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.statusyzlecenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>[]
          }
          delete: {
            args: Prisma.statusyzlecenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>
          }
          update: {
            args: Prisma.statusyzlecenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>
          }
          deleteMany: {
            args: Prisma.statusyzlecenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statusyzlecenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.statusyzlecenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>[]
          }
          upsert: {
            args: Prisma.statusyzlecenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyzlecenPayload>
          }
          aggregate: {
            args: Prisma.StatusyzlecenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusyzlecen>
          }
          groupBy: {
            args: Prisma.statusyzlecenGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusyzlecenGroupByOutputType>[]
          }
          count: {
            args: Prisma.statusyzlecenCountArgs<ExtArgs>
            result: $Utils.Optional<StatusyzlecenCountAggregateOutputType> | number
          }
        }
      }
      typyzlecen: {
        payload: Prisma.$typyzlecenPayload<ExtArgs>
        fields: Prisma.typyzlecenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.typyzlecenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.typyzlecenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>
          }
          findFirst: {
            args: Prisma.typyzlecenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.typyzlecenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>
          }
          findMany: {
            args: Prisma.typyzlecenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>[]
          }
          create: {
            args: Prisma.typyzlecenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>
          }
          createMany: {
            args: Prisma.typyzlecenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.typyzlecenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>[]
          }
          delete: {
            args: Prisma.typyzlecenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>
          }
          update: {
            args: Prisma.typyzlecenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>
          }
          deleteMany: {
            args: Prisma.typyzlecenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.typyzlecenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.typyzlecenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>[]
          }
          upsert: {
            args: Prisma.typyzlecenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typyzlecenPayload>
          }
          aggregate: {
            args: Prisma.TypyzlecenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypyzlecen>
          }
          groupBy: {
            args: Prisma.typyzlecenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypyzlecenGroupByOutputType>[]
          }
          count: {
            args: Prisma.typyzlecenCountArgs<ExtArgs>
            result: $Utils.Optional<TypyzlecenCountAggregateOutputType> | number
          }
        }
      }
      projekty: {
        payload: Prisma.$projektyPayload<ExtArgs>
        fields: Prisma.projektyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projektyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projektyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>
          }
          findFirst: {
            args: Prisma.projektyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projektyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>
          }
          findMany: {
            args: Prisma.projektyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>[]
          }
          create: {
            args: Prisma.projektyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>
          }
          createMany: {
            args: Prisma.projektyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projektyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>[]
          }
          delete: {
            args: Prisma.projektyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>
          }
          update: {
            args: Prisma.projektyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>
          }
          deleteMany: {
            args: Prisma.projektyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projektyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projektyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>[]
          }
          upsert: {
            args: Prisma.projektyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projektyPayload>
          }
          aggregate: {
            args: Prisma.ProjektyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjekty>
          }
          groupBy: {
            args: Prisma.projektyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjektyGroupByOutputType>[]
          }
          count: {
            args: Prisma.projektyCountArgs<ExtArgs>
            result: $Utils.Optional<ProjektyCountAggregateOutputType> | number
          }
        }
      }
      statusyprojektow: {
        payload: Prisma.$statusyprojektowPayload<ExtArgs>
        fields: Prisma.statusyprojektowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statusyprojektowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statusyprojektowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>
          }
          findFirst: {
            args: Prisma.statusyprojektowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statusyprojektowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>
          }
          findMany: {
            args: Prisma.statusyprojektowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>[]
          }
          create: {
            args: Prisma.statusyprojektowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>
          }
          createMany: {
            args: Prisma.statusyprojektowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.statusyprojektowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>[]
          }
          delete: {
            args: Prisma.statusyprojektowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>
          }
          update: {
            args: Prisma.statusyprojektowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>
          }
          deleteMany: {
            args: Prisma.statusyprojektowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statusyprojektowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.statusyprojektowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>[]
          }
          upsert: {
            args: Prisma.statusyprojektowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusyprojektowPayload>
          }
          aggregate: {
            args: Prisma.StatusyprojektowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusyprojektow>
          }
          groupBy: {
            args: Prisma.statusyprojektowGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusyprojektowGroupByOutputType>[]
          }
          count: {
            args: Prisma.statusyprojektowCountArgs<ExtArgs>
            result: $Utils.Optional<StatusyprojektowCountAggregateOutputType> | number
          }
        }
      }
      producentkatalog: {
        payload: Prisma.$producentkatalogPayload<ExtArgs>
        fields: Prisma.producentkatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.producentkatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.producentkatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>
          }
          findFirst: {
            args: Prisma.producentkatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.producentkatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>
          }
          findMany: {
            args: Prisma.producentkatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>[]
          }
          create: {
            args: Prisma.producentkatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>
          }
          createMany: {
            args: Prisma.producentkatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.producentkatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>[]
          }
          delete: {
            args: Prisma.producentkatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>
          }
          update: {
            args: Prisma.producentkatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>
          }
          deleteMany: {
            args: Prisma.producentkatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.producentkatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.producentkatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>[]
          }
          upsert: {
            args: Prisma.producentkatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$producentkatalogPayload>
          }
          aggregate: {
            args: Prisma.ProducentkatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducentkatalog>
          }
          groupBy: {
            args: Prisma.producentkatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProducentkatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.producentkatalogCountArgs<ExtArgs>
            result: $Utils.Optional<ProducentkatalogCountAggregateOutputType> | number
          }
        }
      }
      kategorieproducentow: {
        payload: Prisma.$kategorieproducentowPayload<ExtArgs>
        fields: Prisma.kategorieproducentowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kategorieproducentowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kategorieproducentowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>
          }
          findFirst: {
            args: Prisma.kategorieproducentowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kategorieproducentowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>
          }
          findMany: {
            args: Prisma.kategorieproducentowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>[]
          }
          create: {
            args: Prisma.kategorieproducentowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>
          }
          createMany: {
            args: Prisma.kategorieproducentowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.kategorieproducentowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>[]
          }
          delete: {
            args: Prisma.kategorieproducentowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>
          }
          update: {
            args: Prisma.kategorieproducentowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>
          }
          deleteMany: {
            args: Prisma.kategorieproducentowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kategorieproducentowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.kategorieproducentowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>[]
          }
          upsert: {
            args: Prisma.kategorieproducentowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategorieproducentowPayload>
          }
          aggregate: {
            args: Prisma.KategorieproducentowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKategorieproducentow>
          }
          groupBy: {
            args: Prisma.kategorieproducentowGroupByArgs<ExtArgs>
            result: $Utils.Optional<KategorieproducentowGroupByOutputType>[]
          }
          count: {
            args: Prisma.kategorieproducentowCountArgs<ExtArgs>
            result: $Utils.Optional<KategorieproducentowCountAggregateOutputType> | number
          }
        }
      }
      podwykonawcy: {
        payload: Prisma.$podwykonawcyPayload<ExtArgs>
        fields: Prisma.podwykonawcyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.podwykonawcyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.podwykonawcyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>
          }
          findFirst: {
            args: Prisma.podwykonawcyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.podwykonawcyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>
          }
          findMany: {
            args: Prisma.podwykonawcyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>[]
          }
          create: {
            args: Prisma.podwykonawcyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>
          }
          createMany: {
            args: Prisma.podwykonawcyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.podwykonawcyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>[]
          }
          delete: {
            args: Prisma.podwykonawcyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>
          }
          update: {
            args: Prisma.podwykonawcyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>
          }
          deleteMany: {
            args: Prisma.podwykonawcyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.podwykonawcyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.podwykonawcyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>[]
          }
          upsert: {
            args: Prisma.podwykonawcyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$podwykonawcyPayload>
          }
          aggregate: {
            args: Prisma.PodwykonawcyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePodwykonawcy>
          }
          groupBy: {
            args: Prisma.podwykonawcyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PodwykonawcyGroupByOutputType>[]
          }
          count: {
            args: Prisma.podwykonawcyCountArgs<ExtArgs>
            result: $Utils.Optional<PodwykonawcyCountAggregateOutputType> | number
          }
        }
      }
      freelancerzy: {
        payload: Prisma.$freelancerzyPayload<ExtArgs>
        fields: Prisma.freelancerzyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.freelancerzyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.freelancerzyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>
          }
          findFirst: {
            args: Prisma.freelancerzyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.freelancerzyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>
          }
          findMany: {
            args: Prisma.freelancerzyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>[]
          }
          create: {
            args: Prisma.freelancerzyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>
          }
          createMany: {
            args: Prisma.freelancerzyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.freelancerzyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>[]
          }
          delete: {
            args: Prisma.freelancerzyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>
          }
          update: {
            args: Prisma.freelancerzyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>
          }
          deleteMany: {
            args: Prisma.freelancerzyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.freelancerzyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.freelancerzyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>[]
          }
          upsert: {
            args: Prisma.freelancerzyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freelancerzyPayload>
          }
          aggregate: {
            args: Prisma.FreelancerzyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelancerzy>
          }
          groupBy: {
            args: Prisma.freelancerzyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelancerzyGroupByOutputType>[]
          }
          count: {
            args: Prisma.freelancerzyCountArgs<ExtArgs>
            result: $Utils.Optional<FreelancerzyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    uzytkownicy?: uzytkownicyOmit
    role?: roleOmit
    artykuly?: artykulyOmit
    kategorieartykulow?: kategorieartykulowOmit
    produkty?: produktyOmit
    kategorieproduktow?: kategorieproduktowOmit
    zamowienia?: zamowieniaOmit
    statusyzamowien?: statusyzamowienOmit
    zlecenia?: zleceniaOmit
    statusyzlecen?: statusyzlecenOmit
    typyzlecen?: typyzlecenOmit
    projekty?: projektyOmit
    statusyprojektow?: statusyprojektowOmit
    producentkatalog?: producentkatalogOmit
    kategorieproducentow?: kategorieproducentowOmit
    podwykonawcy?: podwykonawcyOmit
    freelancerzy?: freelancerzyOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UzytkownicyCountOutputType
   */

  export type UzytkownicyCountOutputType = {
    artykuly: number
    produkty: number
    zamowienia: number
    zlecenia_zleceniodawca: number
    zlecenia_wykonawca: number
    projekty: number
    producent_katalog: number
  }

  export type UzytkownicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artykuly?: boolean | UzytkownicyCountOutputTypeCountArtykulyArgs
    produkty?: boolean | UzytkownicyCountOutputTypeCountProduktyArgs
    zamowienia?: boolean | UzytkownicyCountOutputTypeCountZamowieniaArgs
    zlecenia_zleceniodawca?: boolean | UzytkownicyCountOutputTypeCountZlecenia_zleceniodawcaArgs
    zlecenia_wykonawca?: boolean | UzytkownicyCountOutputTypeCountZlecenia_wykonawcaArgs
    projekty?: boolean | UzytkownicyCountOutputTypeCountProjektyArgs
    producent_katalog?: boolean | UzytkownicyCountOutputTypeCountProducent_katalogArgs
  }

  // Custom InputTypes
  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UzytkownicyCountOutputType
     */
    select?: UzytkownicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountArtykulyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: artykulyWhereInput
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountProduktyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produktyWhereInput
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountZamowieniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zamowieniaWhereInput
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountZlecenia_zleceniodawcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zleceniaWhereInput
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountZlecenia_wykonawcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zleceniaWhereInput
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountProjektyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projektyWhereInput
  }

  /**
   * UzytkownicyCountOutputType without action
   */
  export type UzytkownicyCountOutputTypeCountProducent_katalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: producentkatalogWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    uzytkownicy: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownicy?: boolean | RoleCountOutputTypeCountUzytkownicyArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUzytkownicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uzytkownicyWhereInput
  }


  /**
   * Count Type KategorieartykulowCountOutputType
   */

  export type KategorieartykulowCountOutputType = {
    artykuly: number
  }

  export type KategorieartykulowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artykuly?: boolean | KategorieartykulowCountOutputTypeCountArtykulyArgs
  }

  // Custom InputTypes
  /**
   * KategorieartykulowCountOutputType without action
   */
  export type KategorieartykulowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategorieartykulowCountOutputType
     */
    select?: KategorieartykulowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KategorieartykulowCountOutputType without action
   */
  export type KategorieartykulowCountOutputTypeCountArtykulyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: artykulyWhereInput
  }


  /**
   * Count Type ProduktyCountOutputType
   */

  export type ProduktyCountOutputType = {
    zamowienia: number
  }

  export type ProduktyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zamowienia?: boolean | ProduktyCountOutputTypeCountZamowieniaArgs
  }

  // Custom InputTypes
  /**
   * ProduktyCountOutputType without action
   */
  export type ProduktyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProduktyCountOutputType
     */
    select?: ProduktyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProduktyCountOutputType without action
   */
  export type ProduktyCountOutputTypeCountZamowieniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zamowieniaWhereInput
  }


  /**
   * Count Type KategorieproduktowCountOutputType
   */

  export type KategorieproduktowCountOutputType = {
    produkty: number
  }

  export type KategorieproduktowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produkty?: boolean | KategorieproduktowCountOutputTypeCountProduktyArgs
  }

  // Custom InputTypes
  /**
   * KategorieproduktowCountOutputType without action
   */
  export type KategorieproduktowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategorieproduktowCountOutputType
     */
    select?: KategorieproduktowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KategorieproduktowCountOutputType without action
   */
  export type KategorieproduktowCountOutputTypeCountProduktyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produktyWhereInput
  }


  /**
   * Count Type StatusyzamowienCountOutputType
   */

  export type StatusyzamowienCountOutputType = {
    zamowienia: number
  }

  export type StatusyzamowienCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zamowienia?: boolean | StatusyzamowienCountOutputTypeCountZamowieniaArgs
  }

  // Custom InputTypes
  /**
   * StatusyzamowienCountOutputType without action
   */
  export type StatusyzamowienCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusyzamowienCountOutputType
     */
    select?: StatusyzamowienCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatusyzamowienCountOutputType without action
   */
  export type StatusyzamowienCountOutputTypeCountZamowieniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zamowieniaWhereInput
  }


  /**
   * Count Type StatusyzlecenCountOutputType
   */

  export type StatusyzlecenCountOutputType = {
    zlecenia: number
  }

  export type StatusyzlecenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zlecenia?: boolean | StatusyzlecenCountOutputTypeCountZleceniaArgs
  }

  // Custom InputTypes
  /**
   * StatusyzlecenCountOutputType without action
   */
  export type StatusyzlecenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusyzlecenCountOutputType
     */
    select?: StatusyzlecenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatusyzlecenCountOutputType without action
   */
  export type StatusyzlecenCountOutputTypeCountZleceniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zleceniaWhereInput
  }


  /**
   * Count Type TypyzlecenCountOutputType
   */

  export type TypyzlecenCountOutputType = {
    zlecenia: number
  }

  export type TypyzlecenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zlecenia?: boolean | TypyzlecenCountOutputTypeCountZleceniaArgs
  }

  // Custom InputTypes
  /**
   * TypyzlecenCountOutputType without action
   */
  export type TypyzlecenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypyzlecenCountOutputType
     */
    select?: TypyzlecenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypyzlecenCountOutputType without action
   */
  export type TypyzlecenCountOutputTypeCountZleceniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zleceniaWhereInput
  }


  /**
   * Count Type StatusyprojektowCountOutputType
   */

  export type StatusyprojektowCountOutputType = {
    projekty: number
  }

  export type StatusyprojektowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projekty?: boolean | StatusyprojektowCountOutputTypeCountProjektyArgs
  }

  // Custom InputTypes
  /**
   * StatusyprojektowCountOutputType without action
   */
  export type StatusyprojektowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusyprojektowCountOutputType
     */
    select?: StatusyprojektowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatusyprojektowCountOutputType without action
   */
  export type StatusyprojektowCountOutputTypeCountProjektyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projektyWhereInput
  }


  /**
   * Count Type KategorieproducentowCountOutputType
   */

  export type KategorieproducentowCountOutputType = {
    producentkatalog: number
  }

  export type KategorieproducentowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producentkatalog?: boolean | KategorieproducentowCountOutputTypeCountProducentkatalogArgs
  }

  // Custom InputTypes
  /**
   * KategorieproducentowCountOutputType without action
   */
  export type KategorieproducentowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategorieproducentowCountOutputType
     */
    select?: KategorieproducentowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KategorieproducentowCountOutputType without action
   */
  export type KategorieproducentowCountOutputTypeCountProducentkatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: producentkatalogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model uzytkownicy
   */

  export type AggregateUzytkownicy = {
    _count: UzytkownicyCountAggregateOutputType | null
    _avg: UzytkownicyAvgAggregateOutputType | null
    _sum: UzytkownicySumAggregateOutputType | null
    _min: UzytkownicyMinAggregateOutputType | null
    _max: UzytkownicyMaxAggregateOutputType | null
  }

  export type UzytkownicyAvgAggregateOutputType = {
    id: number | null
    rola_id: number | null
  }

  export type UzytkownicySumAggregateOutputType = {
    id: number | null
    rola_id: number | null
  }

  export type UzytkownicyMinAggregateOutputType = {
    id: number | null
    imie: string | null
    nazwisko: string | null
    email: string | null
    haslo: string | null
    rola_id: number | null
    data_rejestracji: Date | null
  }

  export type UzytkownicyMaxAggregateOutputType = {
    id: number | null
    imie: string | null
    nazwisko: string | null
    email: string | null
    haslo: string | null
    rola_id: number | null
    data_rejestracji: Date | null
  }

  export type UzytkownicyCountAggregateOutputType = {
    id: number
    imie: number
    nazwisko: number
    email: number
    haslo: number
    rola_id: number
    data_rejestracji: number
    _all: number
  }


  export type UzytkownicyAvgAggregateInputType = {
    id?: true
    rola_id?: true
  }

  export type UzytkownicySumAggregateInputType = {
    id?: true
    rola_id?: true
  }

  export type UzytkownicyMinAggregateInputType = {
    id?: true
    imie?: true
    nazwisko?: true
    email?: true
    haslo?: true
    rola_id?: true
    data_rejestracji?: true
  }

  export type UzytkownicyMaxAggregateInputType = {
    id?: true
    imie?: true
    nazwisko?: true
    email?: true
    haslo?: true
    rola_id?: true
    data_rejestracji?: true
  }

  export type UzytkownicyCountAggregateInputType = {
    id?: true
    imie?: true
    nazwisko?: true
    email?: true
    haslo?: true
    rola_id?: true
    data_rejestracji?: true
    _all?: true
  }

  export type UzytkownicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uzytkownicy to aggregate.
     */
    where?: uzytkownicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uzytkownicies to fetch.
     */
    orderBy?: uzytkownicyOrderByWithRelationInput | uzytkownicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: uzytkownicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uzytkownicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uzytkownicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned uzytkownicies
    **/
    _count?: true | UzytkownicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UzytkownicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UzytkownicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UzytkownicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UzytkownicyMaxAggregateInputType
  }

  export type GetUzytkownicyAggregateType<T extends UzytkownicyAggregateArgs> = {
        [P in keyof T & keyof AggregateUzytkownicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUzytkownicy[P]>
      : GetScalarType<T[P], AggregateUzytkownicy[P]>
  }




  export type uzytkownicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uzytkownicyWhereInput
    orderBy?: uzytkownicyOrderByWithAggregationInput | uzytkownicyOrderByWithAggregationInput[]
    by: UzytkownicyScalarFieldEnum[] | UzytkownicyScalarFieldEnum
    having?: uzytkownicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UzytkownicyCountAggregateInputType | true
    _avg?: UzytkownicyAvgAggregateInputType
    _sum?: UzytkownicySumAggregateInputType
    _min?: UzytkownicyMinAggregateInputType
    _max?: UzytkownicyMaxAggregateInputType
  }

  export type UzytkownicyGroupByOutputType = {
    id: number
    imie: string | null
    nazwisko: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji: Date | null
    _count: UzytkownicyCountAggregateOutputType | null
    _avg: UzytkownicyAvgAggregateOutputType | null
    _sum: UzytkownicySumAggregateOutputType | null
    _min: UzytkownicyMinAggregateOutputType | null
    _max: UzytkownicyMaxAggregateOutputType | null
  }

  type GetUzytkownicyGroupByPayload<T extends uzytkownicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UzytkownicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UzytkownicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UzytkownicyGroupByOutputType[P]>
            : GetScalarType<T[P], UzytkownicyGroupByOutputType[P]>
        }
      >
    >


  export type uzytkownicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imie?: boolean
    nazwisko?: boolean
    email?: boolean
    haslo?: boolean
    rola_id?: boolean
    data_rejestracji?: boolean
    rola?: boolean | roleDefaultArgs<ExtArgs>
    artykuly?: boolean | uzytkownicy$artykulyArgs<ExtArgs>
    produkty?: boolean | uzytkownicy$produktyArgs<ExtArgs>
    zamowienia?: boolean | uzytkownicy$zamowieniaArgs<ExtArgs>
    zlecenia_zleceniodawca?: boolean | uzytkownicy$zlecenia_zleceniodawcaArgs<ExtArgs>
    zlecenia_wykonawca?: boolean | uzytkownicy$zlecenia_wykonawcaArgs<ExtArgs>
    projekty?: boolean | uzytkownicy$projektyArgs<ExtArgs>
    producent_katalog?: boolean | uzytkownicy$producent_katalogArgs<ExtArgs>
    podwykonawcy?: boolean | uzytkownicy$podwykonawcyArgs<ExtArgs>
    freelancerzy?: boolean | uzytkownicy$freelancerzyArgs<ExtArgs>
    _count?: boolean | UzytkownicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uzytkownicy"]>

  export type uzytkownicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imie?: boolean
    nazwisko?: boolean
    email?: boolean
    haslo?: boolean
    rola_id?: boolean
    data_rejestracji?: boolean
    rola?: boolean | roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uzytkownicy"]>

  export type uzytkownicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imie?: boolean
    nazwisko?: boolean
    email?: boolean
    haslo?: boolean
    rola_id?: boolean
    data_rejestracji?: boolean
    rola?: boolean | roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uzytkownicy"]>

  export type uzytkownicySelectScalar = {
    id?: boolean
    imie?: boolean
    nazwisko?: boolean
    email?: boolean
    haslo?: boolean
    rola_id?: boolean
    data_rejestracji?: boolean
  }

  export type uzytkownicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imie" | "nazwisko" | "email" | "haslo" | "rola_id" | "data_rejestracji", ExtArgs["result"]["uzytkownicy"]>
  export type uzytkownicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rola?: boolean | roleDefaultArgs<ExtArgs>
    artykuly?: boolean | uzytkownicy$artykulyArgs<ExtArgs>
    produkty?: boolean | uzytkownicy$produktyArgs<ExtArgs>
    zamowienia?: boolean | uzytkownicy$zamowieniaArgs<ExtArgs>
    zlecenia_zleceniodawca?: boolean | uzytkownicy$zlecenia_zleceniodawcaArgs<ExtArgs>
    zlecenia_wykonawca?: boolean | uzytkownicy$zlecenia_wykonawcaArgs<ExtArgs>
    projekty?: boolean | uzytkownicy$projektyArgs<ExtArgs>
    producent_katalog?: boolean | uzytkownicy$producent_katalogArgs<ExtArgs>
    podwykonawcy?: boolean | uzytkownicy$podwykonawcyArgs<ExtArgs>
    freelancerzy?: boolean | uzytkownicy$freelancerzyArgs<ExtArgs>
    _count?: boolean | UzytkownicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type uzytkownicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rola?: boolean | roleDefaultArgs<ExtArgs>
  }
  export type uzytkownicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rola?: boolean | roleDefaultArgs<ExtArgs>
  }

  export type $uzytkownicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "uzytkownicy"
    objects: {
      rola: Prisma.$rolePayload<ExtArgs>
      artykuly: Prisma.$artykulyPayload<ExtArgs>[]
      produkty: Prisma.$produktyPayload<ExtArgs>[]
      zamowienia: Prisma.$zamowieniaPayload<ExtArgs>[]
      zlecenia_zleceniodawca: Prisma.$zleceniaPayload<ExtArgs>[]
      zlecenia_wykonawca: Prisma.$zleceniaPayload<ExtArgs>[]
      projekty: Prisma.$projektyPayload<ExtArgs>[]
      producent_katalog: Prisma.$producentkatalogPayload<ExtArgs>[]
      podwykonawcy: Prisma.$podwykonawcyPayload<ExtArgs> | null
      freelancerzy: Prisma.$freelancerzyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      imie: string | null
      nazwisko: string | null
      email: string
      haslo: string
      rola_id: number
      data_rejestracji: Date | null
    }, ExtArgs["result"]["uzytkownicy"]>
    composites: {}
  }

  type uzytkownicyGetPayload<S extends boolean | null | undefined | uzytkownicyDefaultArgs> = $Result.GetResult<Prisma.$uzytkownicyPayload, S>

  type uzytkownicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<uzytkownicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UzytkownicyCountAggregateInputType | true
    }

  export interface uzytkownicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['uzytkownicy'], meta: { name: 'uzytkownicy' } }
    /**
     * Find zero or one Uzytkownicy that matches the filter.
     * @param {uzytkownicyFindUniqueArgs} args - Arguments to find a Uzytkownicy
     * @example
     * // Get one Uzytkownicy
     * const uzytkownicy = await prisma.uzytkownicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends uzytkownicyFindUniqueArgs>(args: SelectSubset<T, uzytkownicyFindUniqueArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Uzytkownicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {uzytkownicyFindUniqueOrThrowArgs} args - Arguments to find a Uzytkownicy
     * @example
     * // Get one Uzytkownicy
     * const uzytkownicy = await prisma.uzytkownicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends uzytkownicyFindUniqueOrThrowArgs>(args: SelectSubset<T, uzytkownicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uzytkownicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uzytkownicyFindFirstArgs} args - Arguments to find a Uzytkownicy
     * @example
     * // Get one Uzytkownicy
     * const uzytkownicy = await prisma.uzytkownicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends uzytkownicyFindFirstArgs>(args?: SelectSubset<T, uzytkownicyFindFirstArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uzytkownicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uzytkownicyFindFirstOrThrowArgs} args - Arguments to find a Uzytkownicy
     * @example
     * // Get one Uzytkownicy
     * const uzytkownicy = await prisma.uzytkownicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends uzytkownicyFindFirstOrThrowArgs>(args?: SelectSubset<T, uzytkownicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uzytkownicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uzytkownicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uzytkownicies
     * const uzytkownicies = await prisma.uzytkownicy.findMany()
     * 
     * // Get first 10 Uzytkownicies
     * const uzytkownicies = await prisma.uzytkownicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uzytkownicyWithIdOnly = await prisma.uzytkownicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends uzytkownicyFindManyArgs>(args?: SelectSubset<T, uzytkownicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Uzytkownicy.
     * @param {uzytkownicyCreateArgs} args - Arguments to create a Uzytkownicy.
     * @example
     * // Create one Uzytkownicy
     * const Uzytkownicy = await prisma.uzytkownicy.create({
     *   data: {
     *     // ... data to create a Uzytkownicy
     *   }
     * })
     * 
     */
    create<T extends uzytkownicyCreateArgs>(args: SelectSubset<T, uzytkownicyCreateArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uzytkownicies.
     * @param {uzytkownicyCreateManyArgs} args - Arguments to create many Uzytkownicies.
     * @example
     * // Create many Uzytkownicies
     * const uzytkownicy = await prisma.uzytkownicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends uzytkownicyCreateManyArgs>(args?: SelectSubset<T, uzytkownicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Uzytkownicies and returns the data saved in the database.
     * @param {uzytkownicyCreateManyAndReturnArgs} args - Arguments to create many Uzytkownicies.
     * @example
     * // Create many Uzytkownicies
     * const uzytkownicy = await prisma.uzytkownicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Uzytkownicies and only return the `id`
     * const uzytkownicyWithIdOnly = await prisma.uzytkownicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends uzytkownicyCreateManyAndReturnArgs>(args?: SelectSubset<T, uzytkownicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Uzytkownicy.
     * @param {uzytkownicyDeleteArgs} args - Arguments to delete one Uzytkownicy.
     * @example
     * // Delete one Uzytkownicy
     * const Uzytkownicy = await prisma.uzytkownicy.delete({
     *   where: {
     *     // ... filter to delete one Uzytkownicy
     *   }
     * })
     * 
     */
    delete<T extends uzytkownicyDeleteArgs>(args: SelectSubset<T, uzytkownicyDeleteArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Uzytkownicy.
     * @param {uzytkownicyUpdateArgs} args - Arguments to update one Uzytkownicy.
     * @example
     * // Update one Uzytkownicy
     * const uzytkownicy = await prisma.uzytkownicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends uzytkownicyUpdateArgs>(args: SelectSubset<T, uzytkownicyUpdateArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uzytkownicies.
     * @param {uzytkownicyDeleteManyArgs} args - Arguments to filter Uzytkownicies to delete.
     * @example
     * // Delete a few Uzytkownicies
     * const { count } = await prisma.uzytkownicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends uzytkownicyDeleteManyArgs>(args?: SelectSubset<T, uzytkownicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uzytkownicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uzytkownicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uzytkownicies
     * const uzytkownicy = await prisma.uzytkownicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends uzytkownicyUpdateManyArgs>(args: SelectSubset<T, uzytkownicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uzytkownicies and returns the data updated in the database.
     * @param {uzytkownicyUpdateManyAndReturnArgs} args - Arguments to update many Uzytkownicies.
     * @example
     * // Update many Uzytkownicies
     * const uzytkownicy = await prisma.uzytkownicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Uzytkownicies and only return the `id`
     * const uzytkownicyWithIdOnly = await prisma.uzytkownicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends uzytkownicyUpdateManyAndReturnArgs>(args: SelectSubset<T, uzytkownicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Uzytkownicy.
     * @param {uzytkownicyUpsertArgs} args - Arguments to update or create a Uzytkownicy.
     * @example
     * // Update or create a Uzytkownicy
     * const uzytkownicy = await prisma.uzytkownicy.upsert({
     *   create: {
     *     // ... data to create a Uzytkownicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uzytkownicy we want to update
     *   }
     * })
     */
    upsert<T extends uzytkownicyUpsertArgs>(args: SelectSubset<T, uzytkownicyUpsertArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uzytkownicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uzytkownicyCountArgs} args - Arguments to filter Uzytkownicies to count.
     * @example
     * // Count the number of Uzytkownicies
     * const count = await prisma.uzytkownicy.count({
     *   where: {
     *     // ... the filter for the Uzytkownicies we want to count
     *   }
     * })
    **/
    count<T extends uzytkownicyCountArgs>(
      args?: Subset<T, uzytkownicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UzytkownicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uzytkownicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UzytkownicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UzytkownicyAggregateArgs>(args: Subset<T, UzytkownicyAggregateArgs>): Prisma.PrismaPromise<GetUzytkownicyAggregateType<T>>

    /**
     * Group by Uzytkownicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uzytkownicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends uzytkownicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: uzytkownicyGroupByArgs['orderBy'] }
        : { orderBy?: uzytkownicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, uzytkownicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUzytkownicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the uzytkownicy model
   */
  readonly fields: uzytkownicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for uzytkownicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__uzytkownicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rola<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artykuly<T extends uzytkownicy$artykulyArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$artykulyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    produkty<T extends uzytkownicy$produktyArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$produktyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zamowienia<T extends uzytkownicy$zamowieniaArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$zamowieniaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zlecenia_zleceniodawca<T extends uzytkownicy$zlecenia_zleceniodawcaArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$zlecenia_zleceniodawcaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zlecenia_wykonawca<T extends uzytkownicy$zlecenia_wykonawcaArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$zlecenia_wykonawcaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projekty<T extends uzytkownicy$projektyArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$projektyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    producent_katalog<T extends uzytkownicy$producent_katalogArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$producent_katalogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    podwykonawcy<T extends uzytkownicy$podwykonawcyArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$podwykonawcyArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    freelancerzy<T extends uzytkownicy$freelancerzyArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicy$freelancerzyArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the uzytkownicy model
   */
  interface uzytkownicyFieldRefs {
    readonly id: FieldRef<"uzytkownicy", 'Int'>
    readonly imie: FieldRef<"uzytkownicy", 'String'>
    readonly nazwisko: FieldRef<"uzytkownicy", 'String'>
    readonly email: FieldRef<"uzytkownicy", 'String'>
    readonly haslo: FieldRef<"uzytkownicy", 'String'>
    readonly rola_id: FieldRef<"uzytkownicy", 'Int'>
    readonly data_rejestracji: FieldRef<"uzytkownicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * uzytkownicy findUnique
   */
  export type uzytkownicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * Filter, which uzytkownicy to fetch.
     */
    where: uzytkownicyWhereUniqueInput
  }

  /**
   * uzytkownicy findUniqueOrThrow
   */
  export type uzytkownicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * Filter, which uzytkownicy to fetch.
     */
    where: uzytkownicyWhereUniqueInput
  }

  /**
   * uzytkownicy findFirst
   */
  export type uzytkownicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * Filter, which uzytkownicy to fetch.
     */
    where?: uzytkownicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uzytkownicies to fetch.
     */
    orderBy?: uzytkownicyOrderByWithRelationInput | uzytkownicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uzytkownicies.
     */
    cursor?: uzytkownicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uzytkownicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uzytkownicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uzytkownicies.
     */
    distinct?: UzytkownicyScalarFieldEnum | UzytkownicyScalarFieldEnum[]
  }

  /**
   * uzytkownicy findFirstOrThrow
   */
  export type uzytkownicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * Filter, which uzytkownicy to fetch.
     */
    where?: uzytkownicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uzytkownicies to fetch.
     */
    orderBy?: uzytkownicyOrderByWithRelationInput | uzytkownicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uzytkownicies.
     */
    cursor?: uzytkownicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uzytkownicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uzytkownicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uzytkownicies.
     */
    distinct?: UzytkownicyScalarFieldEnum | UzytkownicyScalarFieldEnum[]
  }

  /**
   * uzytkownicy findMany
   */
  export type uzytkownicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * Filter, which uzytkownicies to fetch.
     */
    where?: uzytkownicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uzytkownicies to fetch.
     */
    orderBy?: uzytkownicyOrderByWithRelationInput | uzytkownicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing uzytkownicies.
     */
    cursor?: uzytkownicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uzytkownicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uzytkownicies.
     */
    skip?: number
    distinct?: UzytkownicyScalarFieldEnum | UzytkownicyScalarFieldEnum[]
  }

  /**
   * uzytkownicy create
   */
  export type uzytkownicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * The data needed to create a uzytkownicy.
     */
    data: XOR<uzytkownicyCreateInput, uzytkownicyUncheckedCreateInput>
  }

  /**
   * uzytkownicy createMany
   */
  export type uzytkownicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many uzytkownicies.
     */
    data: uzytkownicyCreateManyInput | uzytkownicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * uzytkownicy createManyAndReturn
   */
  export type uzytkownicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * The data used to create many uzytkownicies.
     */
    data: uzytkownicyCreateManyInput | uzytkownicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * uzytkownicy update
   */
  export type uzytkownicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * The data needed to update a uzytkownicy.
     */
    data: XOR<uzytkownicyUpdateInput, uzytkownicyUncheckedUpdateInput>
    /**
     * Choose, which uzytkownicy to update.
     */
    where: uzytkownicyWhereUniqueInput
  }

  /**
   * uzytkownicy updateMany
   */
  export type uzytkownicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update uzytkownicies.
     */
    data: XOR<uzytkownicyUpdateManyMutationInput, uzytkownicyUncheckedUpdateManyInput>
    /**
     * Filter which uzytkownicies to update
     */
    where?: uzytkownicyWhereInput
    /**
     * Limit how many uzytkownicies to update.
     */
    limit?: number
  }

  /**
   * uzytkownicy updateManyAndReturn
   */
  export type uzytkownicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * The data used to update uzytkownicies.
     */
    data: XOR<uzytkownicyUpdateManyMutationInput, uzytkownicyUncheckedUpdateManyInput>
    /**
     * Filter which uzytkownicies to update
     */
    where?: uzytkownicyWhereInput
    /**
     * Limit how many uzytkownicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * uzytkownicy upsert
   */
  export type uzytkownicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * The filter to search for the uzytkownicy to update in case it exists.
     */
    where: uzytkownicyWhereUniqueInput
    /**
     * In case the uzytkownicy found by the `where` argument doesn't exist, create a new uzytkownicy with this data.
     */
    create: XOR<uzytkownicyCreateInput, uzytkownicyUncheckedCreateInput>
    /**
     * In case the uzytkownicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<uzytkownicyUpdateInput, uzytkownicyUncheckedUpdateInput>
  }

  /**
   * uzytkownicy delete
   */
  export type uzytkownicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    /**
     * Filter which uzytkownicy to delete.
     */
    where: uzytkownicyWhereUniqueInput
  }

  /**
   * uzytkownicy deleteMany
   */
  export type uzytkownicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uzytkownicies to delete
     */
    where?: uzytkownicyWhereInput
    /**
     * Limit how many uzytkownicies to delete.
     */
    limit?: number
  }

  /**
   * uzytkownicy.artykuly
   */
  export type uzytkownicy$artykulyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    where?: artykulyWhereInput
    orderBy?: artykulyOrderByWithRelationInput | artykulyOrderByWithRelationInput[]
    cursor?: artykulyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtykulyScalarFieldEnum | ArtykulyScalarFieldEnum[]
  }

  /**
   * uzytkownicy.produkty
   */
  export type uzytkownicy$produktyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    where?: produktyWhereInput
    orderBy?: produktyOrderByWithRelationInput | produktyOrderByWithRelationInput[]
    cursor?: produktyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduktyScalarFieldEnum | ProduktyScalarFieldEnum[]
  }

  /**
   * uzytkownicy.zamowienia
   */
  export type uzytkownicy$zamowieniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    where?: zamowieniaWhereInput
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    cursor?: zamowieniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZamowieniaScalarFieldEnum | ZamowieniaScalarFieldEnum[]
  }

  /**
   * uzytkownicy.zlecenia_zleceniodawca
   */
  export type uzytkownicy$zlecenia_zleceniodawcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    where?: zleceniaWhereInput
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    cursor?: zleceniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * uzytkownicy.zlecenia_wykonawca
   */
  export type uzytkownicy$zlecenia_wykonawcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    where?: zleceniaWhereInput
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    cursor?: zleceniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * uzytkownicy.projekty
   */
  export type uzytkownicy$projektyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    where?: projektyWhereInput
    orderBy?: projektyOrderByWithRelationInput | projektyOrderByWithRelationInput[]
    cursor?: projektyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjektyScalarFieldEnum | ProjektyScalarFieldEnum[]
  }

  /**
   * uzytkownicy.producent_katalog
   */
  export type uzytkownicy$producent_katalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    where?: producentkatalogWhereInput
    orderBy?: producentkatalogOrderByWithRelationInput | producentkatalogOrderByWithRelationInput[]
    cursor?: producentkatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProducentkatalogScalarFieldEnum | ProducentkatalogScalarFieldEnum[]
  }

  /**
   * uzytkownicy.podwykonawcy
   */
  export type uzytkownicy$podwykonawcyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    where?: podwykonawcyWhereInput
  }

  /**
   * uzytkownicy.freelancerzy
   */
  export type uzytkownicy$freelancerzyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    where?: freelancerzyWhereInput
  }

  /**
   * uzytkownicy without action
   */
  export type uzytkownicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    nazwa: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    uzytkownicy?: boolean | role$uzytkownicyArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownicy?: boolean | role$uzytkownicyArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      uzytkownicy: Prisma.$uzytkownicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {roleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends roleUpdateManyAndReturnArgs>(args: SelectSubset<T, roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uzytkownicy<T extends role$uzytkownicyArgs<ExtArgs> = {}>(args?: Subset<T, role$uzytkownicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'Int'>
    readonly nazwa: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role updateManyAndReturn
   */
  export type roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.uzytkownicy
   */
  export type role$uzytkownicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uzytkownicy
     */
    select?: uzytkownicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uzytkownicy
     */
    omit?: uzytkownicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: uzytkownicyInclude<ExtArgs> | null
    where?: uzytkownicyWhereInput
    orderBy?: uzytkownicyOrderByWithRelationInput | uzytkownicyOrderByWithRelationInput[]
    cursor?: uzytkownicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UzytkownicyScalarFieldEnum | UzytkownicyScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model artykuly
   */

  export type AggregateArtykuly = {
    _count: ArtykulyCountAggregateOutputType | null
    _avg: ArtykulyAvgAggregateOutputType | null
    _sum: ArtykulySumAggregateOutputType | null
    _min: ArtykulyMinAggregateOutputType | null
    _max: ArtykulyMaxAggregateOutputType | null
  }

  export type ArtykulyAvgAggregateOutputType = {
    id: number | null
    autor_id: number | null
    kategoria_id: number | null
  }

  export type ArtykulySumAggregateOutputType = {
    id: number | null
    autor_id: number | null
    kategoria_id: number | null
  }

  export type ArtykulyMinAggregateOutputType = {
    id: number | null
    tytul: string | null
    tresc: string | null
    data_publikacji: Date | null
    autor_id: number | null
    kategoria_id: number | null
  }

  export type ArtykulyMaxAggregateOutputType = {
    id: number | null
    tytul: string | null
    tresc: string | null
    data_publikacji: Date | null
    autor_id: number | null
    kategoria_id: number | null
  }

  export type ArtykulyCountAggregateOutputType = {
    id: number
    tytul: number
    tresc: number
    data_publikacji: number
    autor_id: number
    kategoria_id: number
    _all: number
  }


  export type ArtykulyAvgAggregateInputType = {
    id?: true
    autor_id?: true
    kategoria_id?: true
  }

  export type ArtykulySumAggregateInputType = {
    id?: true
    autor_id?: true
    kategoria_id?: true
  }

  export type ArtykulyMinAggregateInputType = {
    id?: true
    tytul?: true
    tresc?: true
    data_publikacji?: true
    autor_id?: true
    kategoria_id?: true
  }

  export type ArtykulyMaxAggregateInputType = {
    id?: true
    tytul?: true
    tresc?: true
    data_publikacji?: true
    autor_id?: true
    kategoria_id?: true
  }

  export type ArtykulyCountAggregateInputType = {
    id?: true
    tytul?: true
    tresc?: true
    data_publikacji?: true
    autor_id?: true
    kategoria_id?: true
    _all?: true
  }

  export type ArtykulyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which artykuly to aggregate.
     */
    where?: artykulyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artykulies to fetch.
     */
    orderBy?: artykulyOrderByWithRelationInput | artykulyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: artykulyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artykulies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artykulies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned artykulies
    **/
    _count?: true | ArtykulyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtykulyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtykulySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtykulyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtykulyMaxAggregateInputType
  }

  export type GetArtykulyAggregateType<T extends ArtykulyAggregateArgs> = {
        [P in keyof T & keyof AggregateArtykuly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtykuly[P]>
      : GetScalarType<T[P], AggregateArtykuly[P]>
  }




  export type artykulyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: artykulyWhereInput
    orderBy?: artykulyOrderByWithAggregationInput | artykulyOrderByWithAggregationInput[]
    by: ArtykulyScalarFieldEnum[] | ArtykulyScalarFieldEnum
    having?: artykulyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtykulyCountAggregateInputType | true
    _avg?: ArtykulyAvgAggregateInputType
    _sum?: ArtykulySumAggregateInputType
    _min?: ArtykulyMinAggregateInputType
    _max?: ArtykulyMaxAggregateInputType
  }

  export type ArtykulyGroupByOutputType = {
    id: number
    tytul: string | null
    tresc: string | null
    data_publikacji: Date | null
    autor_id: number
    kategoria_id: number
    _count: ArtykulyCountAggregateOutputType | null
    _avg: ArtykulyAvgAggregateOutputType | null
    _sum: ArtykulySumAggregateOutputType | null
    _min: ArtykulyMinAggregateOutputType | null
    _max: ArtykulyMaxAggregateOutputType | null
  }

  type GetArtykulyGroupByPayload<T extends artykulyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtykulyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtykulyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtykulyGroupByOutputType[P]>
            : GetScalarType<T[P], ArtykulyGroupByOutputType[P]>
        }
      >
    >


  export type artykulySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tytul?: boolean
    tresc?: boolean
    data_publikacji?: boolean
    autor_id?: boolean
    kategoria_id?: boolean
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieartykulowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artykuly"]>

  export type artykulySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tytul?: boolean
    tresc?: boolean
    data_publikacji?: boolean
    autor_id?: boolean
    kategoria_id?: boolean
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieartykulowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artykuly"]>

  export type artykulySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tytul?: boolean
    tresc?: boolean
    data_publikacji?: boolean
    autor_id?: boolean
    kategoria_id?: boolean
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieartykulowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artykuly"]>

  export type artykulySelectScalar = {
    id?: boolean
    tytul?: boolean
    tresc?: boolean
    data_publikacji?: boolean
    autor_id?: boolean
    kategoria_id?: boolean
  }

  export type artykulyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tytul" | "tresc" | "data_publikacji" | "autor_id" | "kategoria_id", ExtArgs["result"]["artykuly"]>
  export type artykulyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieartykulowDefaultArgs<ExtArgs>
  }
  export type artykulyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieartykulowDefaultArgs<ExtArgs>
  }
  export type artykulyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieartykulowDefaultArgs<ExtArgs>
  }

  export type $artykulyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "artykuly"
    objects: {
      autor: Prisma.$uzytkownicyPayload<ExtArgs>
      kategoria: Prisma.$kategorieartykulowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tytul: string | null
      tresc: string | null
      data_publikacji: Date | null
      autor_id: number
      kategoria_id: number
    }, ExtArgs["result"]["artykuly"]>
    composites: {}
  }

  type artykulyGetPayload<S extends boolean | null | undefined | artykulyDefaultArgs> = $Result.GetResult<Prisma.$artykulyPayload, S>

  type artykulyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<artykulyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtykulyCountAggregateInputType | true
    }

  export interface artykulyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['artykuly'], meta: { name: 'artykuly' } }
    /**
     * Find zero or one Artykuly that matches the filter.
     * @param {artykulyFindUniqueArgs} args - Arguments to find a Artykuly
     * @example
     * // Get one Artykuly
     * const artykuly = await prisma.artykuly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends artykulyFindUniqueArgs>(args: SelectSubset<T, artykulyFindUniqueArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artykuly that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {artykulyFindUniqueOrThrowArgs} args - Arguments to find a Artykuly
     * @example
     * // Get one Artykuly
     * const artykuly = await prisma.artykuly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends artykulyFindUniqueOrThrowArgs>(args: SelectSubset<T, artykulyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artykuly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {artykulyFindFirstArgs} args - Arguments to find a Artykuly
     * @example
     * // Get one Artykuly
     * const artykuly = await prisma.artykuly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends artykulyFindFirstArgs>(args?: SelectSubset<T, artykulyFindFirstArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artykuly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {artykulyFindFirstOrThrowArgs} args - Arguments to find a Artykuly
     * @example
     * // Get one Artykuly
     * const artykuly = await prisma.artykuly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends artykulyFindFirstOrThrowArgs>(args?: SelectSubset<T, artykulyFindFirstOrThrowArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artykulies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {artykulyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artykulies
     * const artykulies = await prisma.artykuly.findMany()
     * 
     * // Get first 10 Artykulies
     * const artykulies = await prisma.artykuly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artykulyWithIdOnly = await prisma.artykuly.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends artykulyFindManyArgs>(args?: SelectSubset<T, artykulyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artykuly.
     * @param {artykulyCreateArgs} args - Arguments to create a Artykuly.
     * @example
     * // Create one Artykuly
     * const Artykuly = await prisma.artykuly.create({
     *   data: {
     *     // ... data to create a Artykuly
     *   }
     * })
     * 
     */
    create<T extends artykulyCreateArgs>(args: SelectSubset<T, artykulyCreateArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artykulies.
     * @param {artykulyCreateManyArgs} args - Arguments to create many Artykulies.
     * @example
     * // Create many Artykulies
     * const artykuly = await prisma.artykuly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends artykulyCreateManyArgs>(args?: SelectSubset<T, artykulyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artykulies and returns the data saved in the database.
     * @param {artykulyCreateManyAndReturnArgs} args - Arguments to create many Artykulies.
     * @example
     * // Create many Artykulies
     * const artykuly = await prisma.artykuly.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artykulies and only return the `id`
     * const artykulyWithIdOnly = await prisma.artykuly.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends artykulyCreateManyAndReturnArgs>(args?: SelectSubset<T, artykulyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artykuly.
     * @param {artykulyDeleteArgs} args - Arguments to delete one Artykuly.
     * @example
     * // Delete one Artykuly
     * const Artykuly = await prisma.artykuly.delete({
     *   where: {
     *     // ... filter to delete one Artykuly
     *   }
     * })
     * 
     */
    delete<T extends artykulyDeleteArgs>(args: SelectSubset<T, artykulyDeleteArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artykuly.
     * @param {artykulyUpdateArgs} args - Arguments to update one Artykuly.
     * @example
     * // Update one Artykuly
     * const artykuly = await prisma.artykuly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends artykulyUpdateArgs>(args: SelectSubset<T, artykulyUpdateArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artykulies.
     * @param {artykulyDeleteManyArgs} args - Arguments to filter Artykulies to delete.
     * @example
     * // Delete a few Artykulies
     * const { count } = await prisma.artykuly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends artykulyDeleteManyArgs>(args?: SelectSubset<T, artykulyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artykulies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {artykulyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artykulies
     * const artykuly = await prisma.artykuly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends artykulyUpdateManyArgs>(args: SelectSubset<T, artykulyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artykulies and returns the data updated in the database.
     * @param {artykulyUpdateManyAndReturnArgs} args - Arguments to update many Artykulies.
     * @example
     * // Update many Artykulies
     * const artykuly = await prisma.artykuly.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artykulies and only return the `id`
     * const artykulyWithIdOnly = await prisma.artykuly.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends artykulyUpdateManyAndReturnArgs>(args: SelectSubset<T, artykulyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artykuly.
     * @param {artykulyUpsertArgs} args - Arguments to update or create a Artykuly.
     * @example
     * // Update or create a Artykuly
     * const artykuly = await prisma.artykuly.upsert({
     *   create: {
     *     // ... data to create a Artykuly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artykuly we want to update
     *   }
     * })
     */
    upsert<T extends artykulyUpsertArgs>(args: SelectSubset<T, artykulyUpsertArgs<ExtArgs>>): Prisma__artykulyClient<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artykulies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {artykulyCountArgs} args - Arguments to filter Artykulies to count.
     * @example
     * // Count the number of Artykulies
     * const count = await prisma.artykuly.count({
     *   where: {
     *     // ... the filter for the Artykulies we want to count
     *   }
     * })
    **/
    count<T extends artykulyCountArgs>(
      args?: Subset<T, artykulyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtykulyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artykuly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtykulyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtykulyAggregateArgs>(args: Subset<T, ArtykulyAggregateArgs>): Prisma.PrismaPromise<GetArtykulyAggregateType<T>>

    /**
     * Group by Artykuly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {artykulyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends artykulyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: artykulyGroupByArgs['orderBy'] }
        : { orderBy?: artykulyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, artykulyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtykulyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the artykuly model
   */
  readonly fields: artykulyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for artykuly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__artykulyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autor<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kategoria<T extends kategorieartykulowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kategorieartykulowDefaultArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the artykuly model
   */
  interface artykulyFieldRefs {
    readonly id: FieldRef<"artykuly", 'Int'>
    readonly tytul: FieldRef<"artykuly", 'String'>
    readonly tresc: FieldRef<"artykuly", 'String'>
    readonly data_publikacji: FieldRef<"artykuly", 'DateTime'>
    readonly autor_id: FieldRef<"artykuly", 'Int'>
    readonly kategoria_id: FieldRef<"artykuly", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * artykuly findUnique
   */
  export type artykulyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * Filter, which artykuly to fetch.
     */
    where: artykulyWhereUniqueInput
  }

  /**
   * artykuly findUniqueOrThrow
   */
  export type artykulyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * Filter, which artykuly to fetch.
     */
    where: artykulyWhereUniqueInput
  }

  /**
   * artykuly findFirst
   */
  export type artykulyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * Filter, which artykuly to fetch.
     */
    where?: artykulyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artykulies to fetch.
     */
    orderBy?: artykulyOrderByWithRelationInput | artykulyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for artykulies.
     */
    cursor?: artykulyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artykulies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artykulies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of artykulies.
     */
    distinct?: ArtykulyScalarFieldEnum | ArtykulyScalarFieldEnum[]
  }

  /**
   * artykuly findFirstOrThrow
   */
  export type artykulyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * Filter, which artykuly to fetch.
     */
    where?: artykulyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artykulies to fetch.
     */
    orderBy?: artykulyOrderByWithRelationInput | artykulyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for artykulies.
     */
    cursor?: artykulyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artykulies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artykulies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of artykulies.
     */
    distinct?: ArtykulyScalarFieldEnum | ArtykulyScalarFieldEnum[]
  }

  /**
   * artykuly findMany
   */
  export type artykulyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * Filter, which artykulies to fetch.
     */
    where?: artykulyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of artykulies to fetch.
     */
    orderBy?: artykulyOrderByWithRelationInput | artykulyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing artykulies.
     */
    cursor?: artykulyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` artykulies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` artykulies.
     */
    skip?: number
    distinct?: ArtykulyScalarFieldEnum | ArtykulyScalarFieldEnum[]
  }

  /**
   * artykuly create
   */
  export type artykulyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * The data needed to create a artykuly.
     */
    data: XOR<artykulyCreateInput, artykulyUncheckedCreateInput>
  }

  /**
   * artykuly createMany
   */
  export type artykulyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many artykulies.
     */
    data: artykulyCreateManyInput | artykulyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * artykuly createManyAndReturn
   */
  export type artykulyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * The data used to create many artykulies.
     */
    data: artykulyCreateManyInput | artykulyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * artykuly update
   */
  export type artykulyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * The data needed to update a artykuly.
     */
    data: XOR<artykulyUpdateInput, artykulyUncheckedUpdateInput>
    /**
     * Choose, which artykuly to update.
     */
    where: artykulyWhereUniqueInput
  }

  /**
   * artykuly updateMany
   */
  export type artykulyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update artykulies.
     */
    data: XOR<artykulyUpdateManyMutationInput, artykulyUncheckedUpdateManyInput>
    /**
     * Filter which artykulies to update
     */
    where?: artykulyWhereInput
    /**
     * Limit how many artykulies to update.
     */
    limit?: number
  }

  /**
   * artykuly updateManyAndReturn
   */
  export type artykulyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * The data used to update artykulies.
     */
    data: XOR<artykulyUpdateManyMutationInput, artykulyUncheckedUpdateManyInput>
    /**
     * Filter which artykulies to update
     */
    where?: artykulyWhereInput
    /**
     * Limit how many artykulies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * artykuly upsert
   */
  export type artykulyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * The filter to search for the artykuly to update in case it exists.
     */
    where: artykulyWhereUniqueInput
    /**
     * In case the artykuly found by the `where` argument doesn't exist, create a new artykuly with this data.
     */
    create: XOR<artykulyCreateInput, artykulyUncheckedCreateInput>
    /**
     * In case the artykuly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<artykulyUpdateInput, artykulyUncheckedUpdateInput>
  }

  /**
   * artykuly delete
   */
  export type artykulyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    /**
     * Filter which artykuly to delete.
     */
    where: artykulyWhereUniqueInput
  }

  /**
   * artykuly deleteMany
   */
  export type artykulyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which artykulies to delete
     */
    where?: artykulyWhereInput
    /**
     * Limit how many artykulies to delete.
     */
    limit?: number
  }

  /**
   * artykuly without action
   */
  export type artykulyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
  }


  /**
   * Model kategorieartykulow
   */

  export type AggregateKategorieartykulow = {
    _count: KategorieartykulowCountAggregateOutputType | null
    _avg: KategorieartykulowAvgAggregateOutputType | null
    _sum: KategorieartykulowSumAggregateOutputType | null
    _min: KategorieartykulowMinAggregateOutputType | null
    _max: KategorieartykulowMaxAggregateOutputType | null
  }

  export type KategorieartykulowAvgAggregateOutputType = {
    id: number | null
  }

  export type KategorieartykulowSumAggregateOutputType = {
    id: number | null
  }

  export type KategorieartykulowMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type KategorieartykulowMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type KategorieartykulowCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type KategorieartykulowAvgAggregateInputType = {
    id?: true
  }

  export type KategorieartykulowSumAggregateInputType = {
    id?: true
  }

  export type KategorieartykulowMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type KategorieartykulowMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type KategorieartykulowCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type KategorieartykulowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategorieartykulow to aggregate.
     */
    where?: kategorieartykulowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieartykulows to fetch.
     */
    orderBy?: kategorieartykulowOrderByWithRelationInput | kategorieartykulowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kategorieartykulowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieartykulows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieartykulows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kategorieartykulows
    **/
    _count?: true | KategorieartykulowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KategorieartykulowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KategorieartykulowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KategorieartykulowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KategorieartykulowMaxAggregateInputType
  }

  export type GetKategorieartykulowAggregateType<T extends KategorieartykulowAggregateArgs> = {
        [P in keyof T & keyof AggregateKategorieartykulow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategorieartykulow[P]>
      : GetScalarType<T[P], AggregateKategorieartykulow[P]>
  }




  export type kategorieartykulowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kategorieartykulowWhereInput
    orderBy?: kategorieartykulowOrderByWithAggregationInput | kategorieartykulowOrderByWithAggregationInput[]
    by: KategorieartykulowScalarFieldEnum[] | KategorieartykulowScalarFieldEnum
    having?: kategorieartykulowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KategorieartykulowCountAggregateInputType | true
    _avg?: KategorieartykulowAvgAggregateInputType
    _sum?: KategorieartykulowSumAggregateInputType
    _min?: KategorieartykulowMinAggregateInputType
    _max?: KategorieartykulowMaxAggregateInputType
  }

  export type KategorieartykulowGroupByOutputType = {
    id: number
    nazwa: string
    _count: KategorieartykulowCountAggregateOutputType | null
    _avg: KategorieartykulowAvgAggregateOutputType | null
    _sum: KategorieartykulowSumAggregateOutputType | null
    _min: KategorieartykulowMinAggregateOutputType | null
    _max: KategorieartykulowMaxAggregateOutputType | null
  }

  type GetKategorieartykulowGroupByPayload<T extends kategorieartykulowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KategorieartykulowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KategorieartykulowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KategorieartykulowGroupByOutputType[P]>
            : GetScalarType<T[P], KategorieartykulowGroupByOutputType[P]>
        }
      >
    >


  export type kategorieartykulowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    artykuly?: boolean | kategorieartykulow$artykulyArgs<ExtArgs>
    _count?: boolean | KategorieartykulowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategorieartykulow"]>

  export type kategorieartykulowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["kategorieartykulow"]>

  export type kategorieartykulowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["kategorieartykulow"]>

  export type kategorieartykulowSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type kategorieartykulowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["kategorieartykulow"]>
  export type kategorieartykulowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artykuly?: boolean | kategorieartykulow$artykulyArgs<ExtArgs>
    _count?: boolean | KategorieartykulowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type kategorieartykulowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type kategorieartykulowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $kategorieartykulowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kategorieartykulow"
    objects: {
      artykuly: Prisma.$artykulyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["kategorieartykulow"]>
    composites: {}
  }

  type kategorieartykulowGetPayload<S extends boolean | null | undefined | kategorieartykulowDefaultArgs> = $Result.GetResult<Prisma.$kategorieartykulowPayload, S>

  type kategorieartykulowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<kategorieartykulowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KategorieartykulowCountAggregateInputType | true
    }

  export interface kategorieartykulowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kategorieartykulow'], meta: { name: 'kategorieartykulow' } }
    /**
     * Find zero or one Kategorieartykulow that matches the filter.
     * @param {kategorieartykulowFindUniqueArgs} args - Arguments to find a Kategorieartykulow
     * @example
     * // Get one Kategorieartykulow
     * const kategorieartykulow = await prisma.kategorieartykulow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kategorieartykulowFindUniqueArgs>(args: SelectSubset<T, kategorieartykulowFindUniqueArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kategorieartykulow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {kategorieartykulowFindUniqueOrThrowArgs} args - Arguments to find a Kategorieartykulow
     * @example
     * // Get one Kategorieartykulow
     * const kategorieartykulow = await prisma.kategorieartykulow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kategorieartykulowFindUniqueOrThrowArgs>(args: SelectSubset<T, kategorieartykulowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kategorieartykulow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieartykulowFindFirstArgs} args - Arguments to find a Kategorieartykulow
     * @example
     * // Get one Kategorieartykulow
     * const kategorieartykulow = await prisma.kategorieartykulow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kategorieartykulowFindFirstArgs>(args?: SelectSubset<T, kategorieartykulowFindFirstArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kategorieartykulow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieartykulowFindFirstOrThrowArgs} args - Arguments to find a Kategorieartykulow
     * @example
     * // Get one Kategorieartykulow
     * const kategorieartykulow = await prisma.kategorieartykulow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kategorieartykulowFindFirstOrThrowArgs>(args?: SelectSubset<T, kategorieartykulowFindFirstOrThrowArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kategorieartykulows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieartykulowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kategorieartykulows
     * const kategorieartykulows = await prisma.kategorieartykulow.findMany()
     * 
     * // Get first 10 Kategorieartykulows
     * const kategorieartykulows = await prisma.kategorieartykulow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kategorieartykulowWithIdOnly = await prisma.kategorieartykulow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kategorieartykulowFindManyArgs>(args?: SelectSubset<T, kategorieartykulowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kategorieartykulow.
     * @param {kategorieartykulowCreateArgs} args - Arguments to create a Kategorieartykulow.
     * @example
     * // Create one Kategorieartykulow
     * const Kategorieartykulow = await prisma.kategorieartykulow.create({
     *   data: {
     *     // ... data to create a Kategorieartykulow
     *   }
     * })
     * 
     */
    create<T extends kategorieartykulowCreateArgs>(args: SelectSubset<T, kategorieartykulowCreateArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kategorieartykulows.
     * @param {kategorieartykulowCreateManyArgs} args - Arguments to create many Kategorieartykulows.
     * @example
     * // Create many Kategorieartykulows
     * const kategorieartykulow = await prisma.kategorieartykulow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kategorieartykulowCreateManyArgs>(args?: SelectSubset<T, kategorieartykulowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kategorieartykulows and returns the data saved in the database.
     * @param {kategorieartykulowCreateManyAndReturnArgs} args - Arguments to create many Kategorieartykulows.
     * @example
     * // Create many Kategorieartykulows
     * const kategorieartykulow = await prisma.kategorieartykulow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kategorieartykulows and only return the `id`
     * const kategorieartykulowWithIdOnly = await prisma.kategorieartykulow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends kategorieartykulowCreateManyAndReturnArgs>(args?: SelectSubset<T, kategorieartykulowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kategorieartykulow.
     * @param {kategorieartykulowDeleteArgs} args - Arguments to delete one Kategorieartykulow.
     * @example
     * // Delete one Kategorieartykulow
     * const Kategorieartykulow = await prisma.kategorieartykulow.delete({
     *   where: {
     *     // ... filter to delete one Kategorieartykulow
     *   }
     * })
     * 
     */
    delete<T extends kategorieartykulowDeleteArgs>(args: SelectSubset<T, kategorieartykulowDeleteArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kategorieartykulow.
     * @param {kategorieartykulowUpdateArgs} args - Arguments to update one Kategorieartykulow.
     * @example
     * // Update one Kategorieartykulow
     * const kategorieartykulow = await prisma.kategorieartykulow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kategorieartykulowUpdateArgs>(args: SelectSubset<T, kategorieartykulowUpdateArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kategorieartykulows.
     * @param {kategorieartykulowDeleteManyArgs} args - Arguments to filter Kategorieartykulows to delete.
     * @example
     * // Delete a few Kategorieartykulows
     * const { count } = await prisma.kategorieartykulow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kategorieartykulowDeleteManyArgs>(args?: SelectSubset<T, kategorieartykulowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategorieartykulows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieartykulowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kategorieartykulows
     * const kategorieartykulow = await prisma.kategorieartykulow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kategorieartykulowUpdateManyArgs>(args: SelectSubset<T, kategorieartykulowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategorieartykulows and returns the data updated in the database.
     * @param {kategorieartykulowUpdateManyAndReturnArgs} args - Arguments to update many Kategorieartykulows.
     * @example
     * // Update many Kategorieartykulows
     * const kategorieartykulow = await prisma.kategorieartykulow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kategorieartykulows and only return the `id`
     * const kategorieartykulowWithIdOnly = await prisma.kategorieartykulow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends kategorieartykulowUpdateManyAndReturnArgs>(args: SelectSubset<T, kategorieartykulowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kategorieartykulow.
     * @param {kategorieartykulowUpsertArgs} args - Arguments to update or create a Kategorieartykulow.
     * @example
     * // Update or create a Kategorieartykulow
     * const kategorieartykulow = await prisma.kategorieartykulow.upsert({
     *   create: {
     *     // ... data to create a Kategorieartykulow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kategorieartykulow we want to update
     *   }
     * })
     */
    upsert<T extends kategorieartykulowUpsertArgs>(args: SelectSubset<T, kategorieartykulowUpsertArgs<ExtArgs>>): Prisma__kategorieartykulowClient<$Result.GetResult<Prisma.$kategorieartykulowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kategorieartykulows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieartykulowCountArgs} args - Arguments to filter Kategorieartykulows to count.
     * @example
     * // Count the number of Kategorieartykulows
     * const count = await prisma.kategorieartykulow.count({
     *   where: {
     *     // ... the filter for the Kategorieartykulows we want to count
     *   }
     * })
    **/
    count<T extends kategorieartykulowCountArgs>(
      args?: Subset<T, kategorieartykulowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KategorieartykulowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kategorieartykulow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategorieartykulowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KategorieartykulowAggregateArgs>(args: Subset<T, KategorieartykulowAggregateArgs>): Prisma.PrismaPromise<GetKategorieartykulowAggregateType<T>>

    /**
     * Group by Kategorieartykulow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieartykulowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kategorieartykulowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kategorieartykulowGroupByArgs['orderBy'] }
        : { orderBy?: kategorieartykulowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kategorieartykulowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategorieartykulowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kategorieartykulow model
   */
  readonly fields: kategorieartykulowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kategorieartykulow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kategorieartykulowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artykuly<T extends kategorieartykulow$artykulyArgs<ExtArgs> = {}>(args?: Subset<T, kategorieartykulow$artykulyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$artykulyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kategorieartykulow model
   */
  interface kategorieartykulowFieldRefs {
    readonly id: FieldRef<"kategorieartykulow", 'Int'>
    readonly nazwa: FieldRef<"kategorieartykulow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kategorieartykulow findUnique
   */
  export type kategorieartykulowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieartykulow to fetch.
     */
    where: kategorieartykulowWhereUniqueInput
  }

  /**
   * kategorieartykulow findUniqueOrThrow
   */
  export type kategorieartykulowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieartykulow to fetch.
     */
    where: kategorieartykulowWhereUniqueInput
  }

  /**
   * kategorieartykulow findFirst
   */
  export type kategorieartykulowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieartykulow to fetch.
     */
    where?: kategorieartykulowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieartykulows to fetch.
     */
    orderBy?: kategorieartykulowOrderByWithRelationInput | kategorieartykulowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategorieartykulows.
     */
    cursor?: kategorieartykulowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieartykulows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieartykulows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategorieartykulows.
     */
    distinct?: KategorieartykulowScalarFieldEnum | KategorieartykulowScalarFieldEnum[]
  }

  /**
   * kategorieartykulow findFirstOrThrow
   */
  export type kategorieartykulowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieartykulow to fetch.
     */
    where?: kategorieartykulowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieartykulows to fetch.
     */
    orderBy?: kategorieartykulowOrderByWithRelationInput | kategorieartykulowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategorieartykulows.
     */
    cursor?: kategorieartykulowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieartykulows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieartykulows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategorieartykulows.
     */
    distinct?: KategorieartykulowScalarFieldEnum | KategorieartykulowScalarFieldEnum[]
  }

  /**
   * kategorieartykulow findMany
   */
  export type kategorieartykulowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieartykulows to fetch.
     */
    where?: kategorieartykulowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieartykulows to fetch.
     */
    orderBy?: kategorieartykulowOrderByWithRelationInput | kategorieartykulowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kategorieartykulows.
     */
    cursor?: kategorieartykulowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieartykulows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieartykulows.
     */
    skip?: number
    distinct?: KategorieartykulowScalarFieldEnum | KategorieartykulowScalarFieldEnum[]
  }

  /**
   * kategorieartykulow create
   */
  export type kategorieartykulowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * The data needed to create a kategorieartykulow.
     */
    data: XOR<kategorieartykulowCreateInput, kategorieartykulowUncheckedCreateInput>
  }

  /**
   * kategorieartykulow createMany
   */
  export type kategorieartykulowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kategorieartykulows.
     */
    data: kategorieartykulowCreateManyInput | kategorieartykulowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategorieartykulow createManyAndReturn
   */
  export type kategorieartykulowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * The data used to create many kategorieartykulows.
     */
    data: kategorieartykulowCreateManyInput | kategorieartykulowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategorieartykulow update
   */
  export type kategorieartykulowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * The data needed to update a kategorieartykulow.
     */
    data: XOR<kategorieartykulowUpdateInput, kategorieartykulowUncheckedUpdateInput>
    /**
     * Choose, which kategorieartykulow to update.
     */
    where: kategorieartykulowWhereUniqueInput
  }

  /**
   * kategorieartykulow updateMany
   */
  export type kategorieartykulowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kategorieartykulows.
     */
    data: XOR<kategorieartykulowUpdateManyMutationInput, kategorieartykulowUncheckedUpdateManyInput>
    /**
     * Filter which kategorieartykulows to update
     */
    where?: kategorieartykulowWhereInput
    /**
     * Limit how many kategorieartykulows to update.
     */
    limit?: number
  }

  /**
   * kategorieartykulow updateManyAndReturn
   */
  export type kategorieartykulowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * The data used to update kategorieartykulows.
     */
    data: XOR<kategorieartykulowUpdateManyMutationInput, kategorieartykulowUncheckedUpdateManyInput>
    /**
     * Filter which kategorieartykulows to update
     */
    where?: kategorieartykulowWhereInput
    /**
     * Limit how many kategorieartykulows to update.
     */
    limit?: number
  }

  /**
   * kategorieartykulow upsert
   */
  export type kategorieartykulowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * The filter to search for the kategorieartykulow to update in case it exists.
     */
    where: kategorieartykulowWhereUniqueInput
    /**
     * In case the kategorieartykulow found by the `where` argument doesn't exist, create a new kategorieartykulow with this data.
     */
    create: XOR<kategorieartykulowCreateInput, kategorieartykulowUncheckedCreateInput>
    /**
     * In case the kategorieartykulow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kategorieartykulowUpdateInput, kategorieartykulowUncheckedUpdateInput>
  }

  /**
   * kategorieartykulow delete
   */
  export type kategorieartykulowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
    /**
     * Filter which kategorieartykulow to delete.
     */
    where: kategorieartykulowWhereUniqueInput
  }

  /**
   * kategorieartykulow deleteMany
   */
  export type kategorieartykulowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategorieartykulows to delete
     */
    where?: kategorieartykulowWhereInput
    /**
     * Limit how many kategorieartykulows to delete.
     */
    limit?: number
  }

  /**
   * kategorieartykulow.artykuly
   */
  export type kategorieartykulow$artykulyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the artykuly
     */
    select?: artykulySelect<ExtArgs> | null
    /**
     * Omit specific fields from the artykuly
     */
    omit?: artykulyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: artykulyInclude<ExtArgs> | null
    where?: artykulyWhereInput
    orderBy?: artykulyOrderByWithRelationInput | artykulyOrderByWithRelationInput[]
    cursor?: artykulyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtykulyScalarFieldEnum | ArtykulyScalarFieldEnum[]
  }

  /**
   * kategorieartykulow without action
   */
  export type kategorieartykulowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieartykulow
     */
    select?: kategorieartykulowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieartykulow
     */
    omit?: kategorieartykulowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieartykulowInclude<ExtArgs> | null
  }


  /**
   * Model produkty
   */

  export type AggregateProdukty = {
    _count: ProduktyCountAggregateOutputType | null
    _avg: ProduktyAvgAggregateOutputType | null
    _sum: ProduktySumAggregateOutputType | null
    _min: ProduktyMinAggregateOutputType | null
    _max: ProduktyMaxAggregateOutputType | null
  }

  export type ProduktyAvgAggregateOutputType = {
    id: number | null
    producent_id: number | null
    cena: Decimal | null
    kategoria_id: number | null
  }

  export type ProduktySumAggregateOutputType = {
    id: number | null
    producent_id: number | null
    cena: Decimal | null
    kategoria_id: number | null
  }

  export type ProduktyMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
    opis: string | null
    producent_id: number | null
    cena: Decimal | null
    kategoria_id: number | null
    data_dodania: Date | null
  }

  export type ProduktyMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
    opis: string | null
    producent_id: number | null
    cena: Decimal | null
    kategoria_id: number | null
    data_dodania: Date | null
  }

  export type ProduktyCountAggregateOutputType = {
    id: number
    nazwa: number
    opis: number
    producent_id: number
    cena: number
    kategoria_id: number
    data_dodania: number
    _all: number
  }


  export type ProduktyAvgAggregateInputType = {
    id?: true
    producent_id?: true
    cena?: true
    kategoria_id?: true
  }

  export type ProduktySumAggregateInputType = {
    id?: true
    producent_id?: true
    cena?: true
    kategoria_id?: true
  }

  export type ProduktyMinAggregateInputType = {
    id?: true
    nazwa?: true
    opis?: true
    producent_id?: true
    cena?: true
    kategoria_id?: true
    data_dodania?: true
  }

  export type ProduktyMaxAggregateInputType = {
    id?: true
    nazwa?: true
    opis?: true
    producent_id?: true
    cena?: true
    kategoria_id?: true
    data_dodania?: true
  }

  export type ProduktyCountAggregateInputType = {
    id?: true
    nazwa?: true
    opis?: true
    producent_id?: true
    cena?: true
    kategoria_id?: true
    data_dodania?: true
    _all?: true
  }

  export type ProduktyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produkty to aggregate.
     */
    where?: produktyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produkties to fetch.
     */
    orderBy?: produktyOrderByWithRelationInput | produktyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produktyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produkties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produkties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produkties
    **/
    _count?: true | ProduktyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProduktyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProduktySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProduktyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProduktyMaxAggregateInputType
  }

  export type GetProduktyAggregateType<T extends ProduktyAggregateArgs> = {
        [P in keyof T & keyof AggregateProdukty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProdukty[P]>
      : GetScalarType<T[P], AggregateProdukty[P]>
  }




  export type produktyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produktyWhereInput
    orderBy?: produktyOrderByWithAggregationInput | produktyOrderByWithAggregationInput[]
    by: ProduktyScalarFieldEnum[] | ProduktyScalarFieldEnum
    having?: produktyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProduktyCountAggregateInputType | true
    _avg?: ProduktyAvgAggregateInputType
    _sum?: ProduktySumAggregateInputType
    _min?: ProduktyMinAggregateInputType
    _max?: ProduktyMaxAggregateInputType
  }

  export type ProduktyGroupByOutputType = {
    id: number
    nazwa: string | null
    opis: string | null
    producent_id: number
    cena: Decimal | null
    kategoria_id: number
    data_dodania: Date | null
    _count: ProduktyCountAggregateOutputType | null
    _avg: ProduktyAvgAggregateOutputType | null
    _sum: ProduktySumAggregateOutputType | null
    _min: ProduktyMinAggregateOutputType | null
    _max: ProduktyMaxAggregateOutputType | null
  }

  type GetProduktyGroupByPayload<T extends produktyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProduktyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProduktyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProduktyGroupByOutputType[P]>
            : GetScalarType<T[P], ProduktyGroupByOutputType[P]>
        }
      >
    >


  export type produktySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    producent_id?: boolean
    cena?: boolean
    kategoria_id?: boolean
    data_dodania?: boolean
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproduktowDefaultArgs<ExtArgs>
    zamowienia?: boolean | produkty$zamowieniaArgs<ExtArgs>
    _count?: boolean | ProduktyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produkty"]>

  export type produktySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    producent_id?: boolean
    cena?: boolean
    kategoria_id?: boolean
    data_dodania?: boolean
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproduktowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produkty"]>

  export type produktySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    producent_id?: boolean
    cena?: boolean
    kategoria_id?: boolean
    data_dodania?: boolean
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproduktowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produkty"]>

  export type produktySelectScalar = {
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    producent_id?: boolean
    cena?: boolean
    kategoria_id?: boolean
    data_dodania?: boolean
  }

  export type produktyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa" | "opis" | "producent_id" | "cena" | "kategoria_id" | "data_dodania", ExtArgs["result"]["produkty"]>
  export type produktyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproduktowDefaultArgs<ExtArgs>
    zamowienia?: boolean | produkty$zamowieniaArgs<ExtArgs>
    _count?: boolean | ProduktyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type produktyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproduktowDefaultArgs<ExtArgs>
  }
  export type produktyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproduktowDefaultArgs<ExtArgs>
  }

  export type $produktyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "produkty"
    objects: {
      producent: Prisma.$uzytkownicyPayload<ExtArgs>
      kategoria: Prisma.$kategorieproduktowPayload<ExtArgs>
      zamowienia: Prisma.$zamowieniaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string | null
      opis: string | null
      producent_id: number
      cena: Prisma.Decimal | null
      kategoria_id: number
      data_dodania: Date | null
    }, ExtArgs["result"]["produkty"]>
    composites: {}
  }

  type produktyGetPayload<S extends boolean | null | undefined | produktyDefaultArgs> = $Result.GetResult<Prisma.$produktyPayload, S>

  type produktyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<produktyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProduktyCountAggregateInputType | true
    }

  export interface produktyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produkty'], meta: { name: 'produkty' } }
    /**
     * Find zero or one Produkty that matches the filter.
     * @param {produktyFindUniqueArgs} args - Arguments to find a Produkty
     * @example
     * // Get one Produkty
     * const produkty = await prisma.produkty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends produktyFindUniqueArgs>(args: SelectSubset<T, produktyFindUniqueArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Produkty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {produktyFindUniqueOrThrowArgs} args - Arguments to find a Produkty
     * @example
     * // Get one Produkty
     * const produkty = await prisma.produkty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends produktyFindUniqueOrThrowArgs>(args: SelectSubset<T, produktyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produkty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produktyFindFirstArgs} args - Arguments to find a Produkty
     * @example
     * // Get one Produkty
     * const produkty = await prisma.produkty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends produktyFindFirstArgs>(args?: SelectSubset<T, produktyFindFirstArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produkty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produktyFindFirstOrThrowArgs} args - Arguments to find a Produkty
     * @example
     * // Get one Produkty
     * const produkty = await prisma.produkty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends produktyFindFirstOrThrowArgs>(args?: SelectSubset<T, produktyFindFirstOrThrowArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Produkties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produktyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produkties
     * const produkties = await prisma.produkty.findMany()
     * 
     * // Get first 10 Produkties
     * const produkties = await prisma.produkty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produktyWithIdOnly = await prisma.produkty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends produktyFindManyArgs>(args?: SelectSubset<T, produktyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Produkty.
     * @param {produktyCreateArgs} args - Arguments to create a Produkty.
     * @example
     * // Create one Produkty
     * const Produkty = await prisma.produkty.create({
     *   data: {
     *     // ... data to create a Produkty
     *   }
     * })
     * 
     */
    create<T extends produktyCreateArgs>(args: SelectSubset<T, produktyCreateArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Produkties.
     * @param {produktyCreateManyArgs} args - Arguments to create many Produkties.
     * @example
     * // Create many Produkties
     * const produkty = await prisma.produkty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends produktyCreateManyArgs>(args?: SelectSubset<T, produktyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Produkties and returns the data saved in the database.
     * @param {produktyCreateManyAndReturnArgs} args - Arguments to create many Produkties.
     * @example
     * // Create many Produkties
     * const produkty = await prisma.produkty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Produkties and only return the `id`
     * const produktyWithIdOnly = await prisma.produkty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends produktyCreateManyAndReturnArgs>(args?: SelectSubset<T, produktyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Produkty.
     * @param {produktyDeleteArgs} args - Arguments to delete one Produkty.
     * @example
     * // Delete one Produkty
     * const Produkty = await prisma.produkty.delete({
     *   where: {
     *     // ... filter to delete one Produkty
     *   }
     * })
     * 
     */
    delete<T extends produktyDeleteArgs>(args: SelectSubset<T, produktyDeleteArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Produkty.
     * @param {produktyUpdateArgs} args - Arguments to update one Produkty.
     * @example
     * // Update one Produkty
     * const produkty = await prisma.produkty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends produktyUpdateArgs>(args: SelectSubset<T, produktyUpdateArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Produkties.
     * @param {produktyDeleteManyArgs} args - Arguments to filter Produkties to delete.
     * @example
     * // Delete a few Produkties
     * const { count } = await prisma.produkty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends produktyDeleteManyArgs>(args?: SelectSubset<T, produktyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produkties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produktyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produkties
     * const produkty = await prisma.produkty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends produktyUpdateManyArgs>(args: SelectSubset<T, produktyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produkties and returns the data updated in the database.
     * @param {produktyUpdateManyAndReturnArgs} args - Arguments to update many Produkties.
     * @example
     * // Update many Produkties
     * const produkty = await prisma.produkty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Produkties and only return the `id`
     * const produktyWithIdOnly = await prisma.produkty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends produktyUpdateManyAndReturnArgs>(args: SelectSubset<T, produktyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Produkty.
     * @param {produktyUpsertArgs} args - Arguments to update or create a Produkty.
     * @example
     * // Update or create a Produkty
     * const produkty = await prisma.produkty.upsert({
     *   create: {
     *     // ... data to create a Produkty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produkty we want to update
     *   }
     * })
     */
    upsert<T extends produktyUpsertArgs>(args: SelectSubset<T, produktyUpsertArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Produkties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produktyCountArgs} args - Arguments to filter Produkties to count.
     * @example
     * // Count the number of Produkties
     * const count = await prisma.produkty.count({
     *   where: {
     *     // ... the filter for the Produkties we want to count
     *   }
     * })
    **/
    count<T extends produktyCountArgs>(
      args?: Subset<T, produktyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProduktyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produkty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduktyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProduktyAggregateArgs>(args: Subset<T, ProduktyAggregateArgs>): Prisma.PrismaPromise<GetProduktyAggregateType<T>>

    /**
     * Group by Produkty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produktyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produktyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produktyGroupByArgs['orderBy'] }
        : { orderBy?: produktyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produktyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduktyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produkty model
   */
  readonly fields: produktyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produkty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produktyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producent<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kategoria<T extends kategorieproduktowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kategorieproduktowDefaultArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zamowienia<T extends produkty$zamowieniaArgs<ExtArgs> = {}>(args?: Subset<T, produkty$zamowieniaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the produkty model
   */
  interface produktyFieldRefs {
    readonly id: FieldRef<"produkty", 'Int'>
    readonly nazwa: FieldRef<"produkty", 'String'>
    readonly opis: FieldRef<"produkty", 'String'>
    readonly producent_id: FieldRef<"produkty", 'Int'>
    readonly cena: FieldRef<"produkty", 'Decimal'>
    readonly kategoria_id: FieldRef<"produkty", 'Int'>
    readonly data_dodania: FieldRef<"produkty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * produkty findUnique
   */
  export type produktyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * Filter, which produkty to fetch.
     */
    where: produktyWhereUniqueInput
  }

  /**
   * produkty findUniqueOrThrow
   */
  export type produktyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * Filter, which produkty to fetch.
     */
    where: produktyWhereUniqueInput
  }

  /**
   * produkty findFirst
   */
  export type produktyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * Filter, which produkty to fetch.
     */
    where?: produktyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produkties to fetch.
     */
    orderBy?: produktyOrderByWithRelationInput | produktyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produkties.
     */
    cursor?: produktyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produkties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produkties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produkties.
     */
    distinct?: ProduktyScalarFieldEnum | ProduktyScalarFieldEnum[]
  }

  /**
   * produkty findFirstOrThrow
   */
  export type produktyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * Filter, which produkty to fetch.
     */
    where?: produktyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produkties to fetch.
     */
    orderBy?: produktyOrderByWithRelationInput | produktyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produkties.
     */
    cursor?: produktyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produkties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produkties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produkties.
     */
    distinct?: ProduktyScalarFieldEnum | ProduktyScalarFieldEnum[]
  }

  /**
   * produkty findMany
   */
  export type produktyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * Filter, which produkties to fetch.
     */
    where?: produktyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produkties to fetch.
     */
    orderBy?: produktyOrderByWithRelationInput | produktyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produkties.
     */
    cursor?: produktyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produkties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produkties.
     */
    skip?: number
    distinct?: ProduktyScalarFieldEnum | ProduktyScalarFieldEnum[]
  }

  /**
   * produkty create
   */
  export type produktyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * The data needed to create a produkty.
     */
    data: XOR<produktyCreateInput, produktyUncheckedCreateInput>
  }

  /**
   * produkty createMany
   */
  export type produktyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produkties.
     */
    data: produktyCreateManyInput | produktyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * produkty createManyAndReturn
   */
  export type produktyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * The data used to create many produkties.
     */
    data: produktyCreateManyInput | produktyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * produkty update
   */
  export type produktyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * The data needed to update a produkty.
     */
    data: XOR<produktyUpdateInput, produktyUncheckedUpdateInput>
    /**
     * Choose, which produkty to update.
     */
    where: produktyWhereUniqueInput
  }

  /**
   * produkty updateMany
   */
  export type produktyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produkties.
     */
    data: XOR<produktyUpdateManyMutationInput, produktyUncheckedUpdateManyInput>
    /**
     * Filter which produkties to update
     */
    where?: produktyWhereInput
    /**
     * Limit how many produkties to update.
     */
    limit?: number
  }

  /**
   * produkty updateManyAndReturn
   */
  export type produktyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * The data used to update produkties.
     */
    data: XOR<produktyUpdateManyMutationInput, produktyUncheckedUpdateManyInput>
    /**
     * Filter which produkties to update
     */
    where?: produktyWhereInput
    /**
     * Limit how many produkties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * produkty upsert
   */
  export type produktyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * The filter to search for the produkty to update in case it exists.
     */
    where: produktyWhereUniqueInput
    /**
     * In case the produkty found by the `where` argument doesn't exist, create a new produkty with this data.
     */
    create: XOR<produktyCreateInput, produktyUncheckedCreateInput>
    /**
     * In case the produkty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produktyUpdateInput, produktyUncheckedUpdateInput>
  }

  /**
   * produkty delete
   */
  export type produktyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    /**
     * Filter which produkty to delete.
     */
    where: produktyWhereUniqueInput
  }

  /**
   * produkty deleteMany
   */
  export type produktyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produkties to delete
     */
    where?: produktyWhereInput
    /**
     * Limit how many produkties to delete.
     */
    limit?: number
  }

  /**
   * produkty.zamowienia
   */
  export type produkty$zamowieniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    where?: zamowieniaWhereInput
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    cursor?: zamowieniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZamowieniaScalarFieldEnum | ZamowieniaScalarFieldEnum[]
  }

  /**
   * produkty without action
   */
  export type produktyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
  }


  /**
   * Model kategorieproduktow
   */

  export type AggregateKategorieproduktow = {
    _count: KategorieproduktowCountAggregateOutputType | null
    _avg: KategorieproduktowAvgAggregateOutputType | null
    _sum: KategorieproduktowSumAggregateOutputType | null
    _min: KategorieproduktowMinAggregateOutputType | null
    _max: KategorieproduktowMaxAggregateOutputType | null
  }

  export type KategorieproduktowAvgAggregateOutputType = {
    id: number | null
  }

  export type KategorieproduktowSumAggregateOutputType = {
    id: number | null
  }

  export type KategorieproduktowMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type KategorieproduktowMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type KategorieproduktowCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type KategorieproduktowAvgAggregateInputType = {
    id?: true
  }

  export type KategorieproduktowSumAggregateInputType = {
    id?: true
  }

  export type KategorieproduktowMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type KategorieproduktowMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type KategorieproduktowCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type KategorieproduktowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategorieproduktow to aggregate.
     */
    where?: kategorieproduktowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproduktows to fetch.
     */
    orderBy?: kategorieproduktowOrderByWithRelationInput | kategorieproduktowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kategorieproduktowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproduktows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproduktows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kategorieproduktows
    **/
    _count?: true | KategorieproduktowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KategorieproduktowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KategorieproduktowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KategorieproduktowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KategorieproduktowMaxAggregateInputType
  }

  export type GetKategorieproduktowAggregateType<T extends KategorieproduktowAggregateArgs> = {
        [P in keyof T & keyof AggregateKategorieproduktow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategorieproduktow[P]>
      : GetScalarType<T[P], AggregateKategorieproduktow[P]>
  }




  export type kategorieproduktowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kategorieproduktowWhereInput
    orderBy?: kategorieproduktowOrderByWithAggregationInput | kategorieproduktowOrderByWithAggregationInput[]
    by: KategorieproduktowScalarFieldEnum[] | KategorieproduktowScalarFieldEnum
    having?: kategorieproduktowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KategorieproduktowCountAggregateInputType | true
    _avg?: KategorieproduktowAvgAggregateInputType
    _sum?: KategorieproduktowSumAggregateInputType
    _min?: KategorieproduktowMinAggregateInputType
    _max?: KategorieproduktowMaxAggregateInputType
  }

  export type KategorieproduktowGroupByOutputType = {
    id: number
    nazwa: string
    _count: KategorieproduktowCountAggregateOutputType | null
    _avg: KategorieproduktowAvgAggregateOutputType | null
    _sum: KategorieproduktowSumAggregateOutputType | null
    _min: KategorieproduktowMinAggregateOutputType | null
    _max: KategorieproduktowMaxAggregateOutputType | null
  }

  type GetKategorieproduktowGroupByPayload<T extends kategorieproduktowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KategorieproduktowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KategorieproduktowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KategorieproduktowGroupByOutputType[P]>
            : GetScalarType<T[P], KategorieproduktowGroupByOutputType[P]>
        }
      >
    >


  export type kategorieproduktowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    produkty?: boolean | kategorieproduktow$produktyArgs<ExtArgs>
    _count?: boolean | KategorieproduktowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategorieproduktow"]>

  export type kategorieproduktowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["kategorieproduktow"]>

  export type kategorieproduktowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["kategorieproduktow"]>

  export type kategorieproduktowSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type kategorieproduktowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["kategorieproduktow"]>
  export type kategorieproduktowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produkty?: boolean | kategorieproduktow$produktyArgs<ExtArgs>
    _count?: boolean | KategorieproduktowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type kategorieproduktowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type kategorieproduktowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $kategorieproduktowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kategorieproduktow"
    objects: {
      produkty: Prisma.$produktyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["kategorieproduktow"]>
    composites: {}
  }

  type kategorieproduktowGetPayload<S extends boolean | null | undefined | kategorieproduktowDefaultArgs> = $Result.GetResult<Prisma.$kategorieproduktowPayload, S>

  type kategorieproduktowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<kategorieproduktowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KategorieproduktowCountAggregateInputType | true
    }

  export interface kategorieproduktowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kategorieproduktow'], meta: { name: 'kategorieproduktow' } }
    /**
     * Find zero or one Kategorieproduktow that matches the filter.
     * @param {kategorieproduktowFindUniqueArgs} args - Arguments to find a Kategorieproduktow
     * @example
     * // Get one Kategorieproduktow
     * const kategorieproduktow = await prisma.kategorieproduktow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kategorieproduktowFindUniqueArgs>(args: SelectSubset<T, kategorieproduktowFindUniqueArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kategorieproduktow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {kategorieproduktowFindUniqueOrThrowArgs} args - Arguments to find a Kategorieproduktow
     * @example
     * // Get one Kategorieproduktow
     * const kategorieproduktow = await prisma.kategorieproduktow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kategorieproduktowFindUniqueOrThrowArgs>(args: SelectSubset<T, kategorieproduktowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kategorieproduktow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproduktowFindFirstArgs} args - Arguments to find a Kategorieproduktow
     * @example
     * // Get one Kategorieproduktow
     * const kategorieproduktow = await prisma.kategorieproduktow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kategorieproduktowFindFirstArgs>(args?: SelectSubset<T, kategorieproduktowFindFirstArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kategorieproduktow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproduktowFindFirstOrThrowArgs} args - Arguments to find a Kategorieproduktow
     * @example
     * // Get one Kategorieproduktow
     * const kategorieproduktow = await prisma.kategorieproduktow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kategorieproduktowFindFirstOrThrowArgs>(args?: SelectSubset<T, kategorieproduktowFindFirstOrThrowArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kategorieproduktows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproduktowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kategorieproduktows
     * const kategorieproduktows = await prisma.kategorieproduktow.findMany()
     * 
     * // Get first 10 Kategorieproduktows
     * const kategorieproduktows = await prisma.kategorieproduktow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kategorieproduktowWithIdOnly = await prisma.kategorieproduktow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kategorieproduktowFindManyArgs>(args?: SelectSubset<T, kategorieproduktowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kategorieproduktow.
     * @param {kategorieproduktowCreateArgs} args - Arguments to create a Kategorieproduktow.
     * @example
     * // Create one Kategorieproduktow
     * const Kategorieproduktow = await prisma.kategorieproduktow.create({
     *   data: {
     *     // ... data to create a Kategorieproduktow
     *   }
     * })
     * 
     */
    create<T extends kategorieproduktowCreateArgs>(args: SelectSubset<T, kategorieproduktowCreateArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kategorieproduktows.
     * @param {kategorieproduktowCreateManyArgs} args - Arguments to create many Kategorieproduktows.
     * @example
     * // Create many Kategorieproduktows
     * const kategorieproduktow = await prisma.kategorieproduktow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kategorieproduktowCreateManyArgs>(args?: SelectSubset<T, kategorieproduktowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kategorieproduktows and returns the data saved in the database.
     * @param {kategorieproduktowCreateManyAndReturnArgs} args - Arguments to create many Kategorieproduktows.
     * @example
     * // Create many Kategorieproduktows
     * const kategorieproduktow = await prisma.kategorieproduktow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kategorieproduktows and only return the `id`
     * const kategorieproduktowWithIdOnly = await prisma.kategorieproduktow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends kategorieproduktowCreateManyAndReturnArgs>(args?: SelectSubset<T, kategorieproduktowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kategorieproduktow.
     * @param {kategorieproduktowDeleteArgs} args - Arguments to delete one Kategorieproduktow.
     * @example
     * // Delete one Kategorieproduktow
     * const Kategorieproduktow = await prisma.kategorieproduktow.delete({
     *   where: {
     *     // ... filter to delete one Kategorieproduktow
     *   }
     * })
     * 
     */
    delete<T extends kategorieproduktowDeleteArgs>(args: SelectSubset<T, kategorieproduktowDeleteArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kategorieproduktow.
     * @param {kategorieproduktowUpdateArgs} args - Arguments to update one Kategorieproduktow.
     * @example
     * // Update one Kategorieproduktow
     * const kategorieproduktow = await prisma.kategorieproduktow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kategorieproduktowUpdateArgs>(args: SelectSubset<T, kategorieproduktowUpdateArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kategorieproduktows.
     * @param {kategorieproduktowDeleteManyArgs} args - Arguments to filter Kategorieproduktows to delete.
     * @example
     * // Delete a few Kategorieproduktows
     * const { count } = await prisma.kategorieproduktow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kategorieproduktowDeleteManyArgs>(args?: SelectSubset<T, kategorieproduktowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategorieproduktows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproduktowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kategorieproduktows
     * const kategorieproduktow = await prisma.kategorieproduktow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kategorieproduktowUpdateManyArgs>(args: SelectSubset<T, kategorieproduktowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategorieproduktows and returns the data updated in the database.
     * @param {kategorieproduktowUpdateManyAndReturnArgs} args - Arguments to update many Kategorieproduktows.
     * @example
     * // Update many Kategorieproduktows
     * const kategorieproduktow = await prisma.kategorieproduktow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kategorieproduktows and only return the `id`
     * const kategorieproduktowWithIdOnly = await prisma.kategorieproduktow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends kategorieproduktowUpdateManyAndReturnArgs>(args: SelectSubset<T, kategorieproduktowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kategorieproduktow.
     * @param {kategorieproduktowUpsertArgs} args - Arguments to update or create a Kategorieproduktow.
     * @example
     * // Update or create a Kategorieproduktow
     * const kategorieproduktow = await prisma.kategorieproduktow.upsert({
     *   create: {
     *     // ... data to create a Kategorieproduktow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kategorieproduktow we want to update
     *   }
     * })
     */
    upsert<T extends kategorieproduktowUpsertArgs>(args: SelectSubset<T, kategorieproduktowUpsertArgs<ExtArgs>>): Prisma__kategorieproduktowClient<$Result.GetResult<Prisma.$kategorieproduktowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kategorieproduktows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproduktowCountArgs} args - Arguments to filter Kategorieproduktows to count.
     * @example
     * // Count the number of Kategorieproduktows
     * const count = await prisma.kategorieproduktow.count({
     *   where: {
     *     // ... the filter for the Kategorieproduktows we want to count
     *   }
     * })
    **/
    count<T extends kategorieproduktowCountArgs>(
      args?: Subset<T, kategorieproduktowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KategorieproduktowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kategorieproduktow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategorieproduktowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KategorieproduktowAggregateArgs>(args: Subset<T, KategorieproduktowAggregateArgs>): Prisma.PrismaPromise<GetKategorieproduktowAggregateType<T>>

    /**
     * Group by Kategorieproduktow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproduktowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kategorieproduktowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kategorieproduktowGroupByArgs['orderBy'] }
        : { orderBy?: kategorieproduktowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kategorieproduktowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategorieproduktowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kategorieproduktow model
   */
  readonly fields: kategorieproduktowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kategorieproduktow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kategorieproduktowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    produkty<T extends kategorieproduktow$produktyArgs<ExtArgs> = {}>(args?: Subset<T, kategorieproduktow$produktyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kategorieproduktow model
   */
  interface kategorieproduktowFieldRefs {
    readonly id: FieldRef<"kategorieproduktow", 'Int'>
    readonly nazwa: FieldRef<"kategorieproduktow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kategorieproduktow findUnique
   */
  export type kategorieproduktowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproduktow to fetch.
     */
    where: kategorieproduktowWhereUniqueInput
  }

  /**
   * kategorieproduktow findUniqueOrThrow
   */
  export type kategorieproduktowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproduktow to fetch.
     */
    where: kategorieproduktowWhereUniqueInput
  }

  /**
   * kategorieproduktow findFirst
   */
  export type kategorieproduktowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproduktow to fetch.
     */
    where?: kategorieproduktowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproduktows to fetch.
     */
    orderBy?: kategorieproduktowOrderByWithRelationInput | kategorieproduktowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategorieproduktows.
     */
    cursor?: kategorieproduktowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproduktows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproduktows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategorieproduktows.
     */
    distinct?: KategorieproduktowScalarFieldEnum | KategorieproduktowScalarFieldEnum[]
  }

  /**
   * kategorieproduktow findFirstOrThrow
   */
  export type kategorieproduktowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproduktow to fetch.
     */
    where?: kategorieproduktowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproduktows to fetch.
     */
    orderBy?: kategorieproduktowOrderByWithRelationInput | kategorieproduktowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategorieproduktows.
     */
    cursor?: kategorieproduktowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproduktows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproduktows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategorieproduktows.
     */
    distinct?: KategorieproduktowScalarFieldEnum | KategorieproduktowScalarFieldEnum[]
  }

  /**
   * kategorieproduktow findMany
   */
  export type kategorieproduktowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproduktows to fetch.
     */
    where?: kategorieproduktowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproduktows to fetch.
     */
    orderBy?: kategorieproduktowOrderByWithRelationInput | kategorieproduktowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kategorieproduktows.
     */
    cursor?: kategorieproduktowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproduktows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproduktows.
     */
    skip?: number
    distinct?: KategorieproduktowScalarFieldEnum | KategorieproduktowScalarFieldEnum[]
  }

  /**
   * kategorieproduktow create
   */
  export type kategorieproduktowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * The data needed to create a kategorieproduktow.
     */
    data: XOR<kategorieproduktowCreateInput, kategorieproduktowUncheckedCreateInput>
  }

  /**
   * kategorieproduktow createMany
   */
  export type kategorieproduktowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kategorieproduktows.
     */
    data: kategorieproduktowCreateManyInput | kategorieproduktowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategorieproduktow createManyAndReturn
   */
  export type kategorieproduktowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * The data used to create many kategorieproduktows.
     */
    data: kategorieproduktowCreateManyInput | kategorieproduktowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategorieproduktow update
   */
  export type kategorieproduktowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * The data needed to update a kategorieproduktow.
     */
    data: XOR<kategorieproduktowUpdateInput, kategorieproduktowUncheckedUpdateInput>
    /**
     * Choose, which kategorieproduktow to update.
     */
    where: kategorieproduktowWhereUniqueInput
  }

  /**
   * kategorieproduktow updateMany
   */
  export type kategorieproduktowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kategorieproduktows.
     */
    data: XOR<kategorieproduktowUpdateManyMutationInput, kategorieproduktowUncheckedUpdateManyInput>
    /**
     * Filter which kategorieproduktows to update
     */
    where?: kategorieproduktowWhereInput
    /**
     * Limit how many kategorieproduktows to update.
     */
    limit?: number
  }

  /**
   * kategorieproduktow updateManyAndReturn
   */
  export type kategorieproduktowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * The data used to update kategorieproduktows.
     */
    data: XOR<kategorieproduktowUpdateManyMutationInput, kategorieproduktowUncheckedUpdateManyInput>
    /**
     * Filter which kategorieproduktows to update
     */
    where?: kategorieproduktowWhereInput
    /**
     * Limit how many kategorieproduktows to update.
     */
    limit?: number
  }

  /**
   * kategorieproduktow upsert
   */
  export type kategorieproduktowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * The filter to search for the kategorieproduktow to update in case it exists.
     */
    where: kategorieproduktowWhereUniqueInput
    /**
     * In case the kategorieproduktow found by the `where` argument doesn't exist, create a new kategorieproduktow with this data.
     */
    create: XOR<kategorieproduktowCreateInput, kategorieproduktowUncheckedCreateInput>
    /**
     * In case the kategorieproduktow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kategorieproduktowUpdateInput, kategorieproduktowUncheckedUpdateInput>
  }

  /**
   * kategorieproduktow delete
   */
  export type kategorieproduktowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
    /**
     * Filter which kategorieproduktow to delete.
     */
    where: kategorieproduktowWhereUniqueInput
  }

  /**
   * kategorieproduktow deleteMany
   */
  export type kategorieproduktowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategorieproduktows to delete
     */
    where?: kategorieproduktowWhereInput
    /**
     * Limit how many kategorieproduktows to delete.
     */
    limit?: number
  }

  /**
   * kategorieproduktow.produkty
   */
  export type kategorieproduktow$produktyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produkty
     */
    select?: produktySelect<ExtArgs> | null
    /**
     * Omit specific fields from the produkty
     */
    omit?: produktyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: produktyInclude<ExtArgs> | null
    where?: produktyWhereInput
    orderBy?: produktyOrderByWithRelationInput | produktyOrderByWithRelationInput[]
    cursor?: produktyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduktyScalarFieldEnum | ProduktyScalarFieldEnum[]
  }

  /**
   * kategorieproduktow without action
   */
  export type kategorieproduktowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproduktow
     */
    select?: kategorieproduktowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproduktow
     */
    omit?: kategorieproduktowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproduktowInclude<ExtArgs> | null
  }


  /**
   * Model zamowienia
   */

  export type AggregateZamowienia = {
    _count: ZamowieniaCountAggregateOutputType | null
    _avg: ZamowieniaAvgAggregateOutputType | null
    _sum: ZamowieniaSumAggregateOutputType | null
    _min: ZamowieniaMinAggregateOutputType | null
    _max: ZamowieniaMaxAggregateOutputType | null
  }

  export type ZamowieniaAvgAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    produkt_id: number | null
    ilosc: number | null
    status_id: number | null
  }

  export type ZamowieniaSumAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    produkt_id: number | null
    ilosc: number | null
    status_id: number | null
  }

  export type ZamowieniaMinAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    produkt_id: number | null
    ilosc: number | null
    data_zamowienia: Date | null
    status_id: number | null
  }

  export type ZamowieniaMaxAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    produkt_id: number | null
    ilosc: number | null
    data_zamowienia: Date | null
    status_id: number | null
  }

  export type ZamowieniaCountAggregateOutputType = {
    id: number
    uzytkownik_id: number
    produkt_id: number
    ilosc: number
    data_zamowienia: number
    status_id: number
    _all: number
  }


  export type ZamowieniaAvgAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    produkt_id?: true
    ilosc?: true
    status_id?: true
  }

  export type ZamowieniaSumAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    produkt_id?: true
    ilosc?: true
    status_id?: true
  }

  export type ZamowieniaMinAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    produkt_id?: true
    ilosc?: true
    data_zamowienia?: true
    status_id?: true
  }

  export type ZamowieniaMaxAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    produkt_id?: true
    ilosc?: true
    data_zamowienia?: true
    status_id?: true
  }

  export type ZamowieniaCountAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    produkt_id?: true
    ilosc?: true
    data_zamowienia?: true
    status_id?: true
    _all?: true
  }

  export type ZamowieniaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zamowienia to aggregate.
     */
    where?: zamowieniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zamowienias to fetch.
     */
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zamowieniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zamowienias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zamowienias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zamowienias
    **/
    _count?: true | ZamowieniaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZamowieniaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZamowieniaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZamowieniaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZamowieniaMaxAggregateInputType
  }

  export type GetZamowieniaAggregateType<T extends ZamowieniaAggregateArgs> = {
        [P in keyof T & keyof AggregateZamowienia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZamowienia[P]>
      : GetScalarType<T[P], AggregateZamowienia[P]>
  }




  export type zamowieniaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zamowieniaWhereInput
    orderBy?: zamowieniaOrderByWithAggregationInput | zamowieniaOrderByWithAggregationInput[]
    by: ZamowieniaScalarFieldEnum[] | ZamowieniaScalarFieldEnum
    having?: zamowieniaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZamowieniaCountAggregateInputType | true
    _avg?: ZamowieniaAvgAggregateInputType
    _sum?: ZamowieniaSumAggregateInputType
    _min?: ZamowieniaMinAggregateInputType
    _max?: ZamowieniaMaxAggregateInputType
  }

  export type ZamowieniaGroupByOutputType = {
    id: number
    uzytkownik_id: number
    produkt_id: number
    ilosc: number | null
    data_zamowienia: Date | null
    status_id: number
    _count: ZamowieniaCountAggregateOutputType | null
    _avg: ZamowieniaAvgAggregateOutputType | null
    _sum: ZamowieniaSumAggregateOutputType | null
    _min: ZamowieniaMinAggregateOutputType | null
    _max: ZamowieniaMaxAggregateOutputType | null
  }

  type GetZamowieniaGroupByPayload<T extends zamowieniaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZamowieniaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZamowieniaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZamowieniaGroupByOutputType[P]>
            : GetScalarType<T[P], ZamowieniaGroupByOutputType[P]>
        }
      >
    >


  export type zamowieniaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    produkt_id?: boolean
    ilosc?: boolean
    data_zamowienia?: boolean
    status_id?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    produkt?: boolean | produktyDefaultArgs<ExtArgs>
    status?: boolean | statusyzamowienDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zamowienia"]>

  export type zamowieniaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    produkt_id?: boolean
    ilosc?: boolean
    data_zamowienia?: boolean
    status_id?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    produkt?: boolean | produktyDefaultArgs<ExtArgs>
    status?: boolean | statusyzamowienDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zamowienia"]>

  export type zamowieniaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    produkt_id?: boolean
    ilosc?: boolean
    data_zamowienia?: boolean
    status_id?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    produkt?: boolean | produktyDefaultArgs<ExtArgs>
    status?: boolean | statusyzamowienDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zamowienia"]>

  export type zamowieniaSelectScalar = {
    id?: boolean
    uzytkownik_id?: boolean
    produkt_id?: boolean
    ilosc?: boolean
    data_zamowienia?: boolean
    status_id?: boolean
  }

  export type zamowieniaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uzytkownik_id" | "produkt_id" | "ilosc" | "data_zamowienia" | "status_id", ExtArgs["result"]["zamowienia"]>
  export type zamowieniaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    produkt?: boolean | produktyDefaultArgs<ExtArgs>
    status?: boolean | statusyzamowienDefaultArgs<ExtArgs>
  }
  export type zamowieniaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    produkt?: boolean | produktyDefaultArgs<ExtArgs>
    status?: boolean | statusyzamowienDefaultArgs<ExtArgs>
  }
  export type zamowieniaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    produkt?: boolean | produktyDefaultArgs<ExtArgs>
    status?: boolean | statusyzamowienDefaultArgs<ExtArgs>
  }

  export type $zamowieniaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zamowienia"
    objects: {
      uzytkownik: Prisma.$uzytkownicyPayload<ExtArgs>
      produkt: Prisma.$produktyPayload<ExtArgs>
      status: Prisma.$statusyzamowienPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uzytkownik_id: number
      produkt_id: number
      ilosc: number | null
      data_zamowienia: Date | null
      status_id: number
    }, ExtArgs["result"]["zamowienia"]>
    composites: {}
  }

  type zamowieniaGetPayload<S extends boolean | null | undefined | zamowieniaDefaultArgs> = $Result.GetResult<Prisma.$zamowieniaPayload, S>

  type zamowieniaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zamowieniaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZamowieniaCountAggregateInputType | true
    }

  export interface zamowieniaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zamowienia'], meta: { name: 'zamowienia' } }
    /**
     * Find zero or one Zamowienia that matches the filter.
     * @param {zamowieniaFindUniqueArgs} args - Arguments to find a Zamowienia
     * @example
     * // Get one Zamowienia
     * const zamowienia = await prisma.zamowienia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zamowieniaFindUniqueArgs>(args: SelectSubset<T, zamowieniaFindUniqueArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zamowienia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zamowieniaFindUniqueOrThrowArgs} args - Arguments to find a Zamowienia
     * @example
     * // Get one Zamowienia
     * const zamowienia = await prisma.zamowienia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zamowieniaFindUniqueOrThrowArgs>(args: SelectSubset<T, zamowieniaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zamowienia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zamowieniaFindFirstArgs} args - Arguments to find a Zamowienia
     * @example
     * // Get one Zamowienia
     * const zamowienia = await prisma.zamowienia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zamowieniaFindFirstArgs>(args?: SelectSubset<T, zamowieniaFindFirstArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zamowienia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zamowieniaFindFirstOrThrowArgs} args - Arguments to find a Zamowienia
     * @example
     * // Get one Zamowienia
     * const zamowienia = await prisma.zamowienia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zamowieniaFindFirstOrThrowArgs>(args?: SelectSubset<T, zamowieniaFindFirstOrThrowArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zamowienias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zamowieniaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zamowienias
     * const zamowienias = await prisma.zamowienia.findMany()
     * 
     * // Get first 10 Zamowienias
     * const zamowienias = await prisma.zamowienia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zamowieniaWithIdOnly = await prisma.zamowienia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zamowieniaFindManyArgs>(args?: SelectSubset<T, zamowieniaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zamowienia.
     * @param {zamowieniaCreateArgs} args - Arguments to create a Zamowienia.
     * @example
     * // Create one Zamowienia
     * const Zamowienia = await prisma.zamowienia.create({
     *   data: {
     *     // ... data to create a Zamowienia
     *   }
     * })
     * 
     */
    create<T extends zamowieniaCreateArgs>(args: SelectSubset<T, zamowieniaCreateArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zamowienias.
     * @param {zamowieniaCreateManyArgs} args - Arguments to create many Zamowienias.
     * @example
     * // Create many Zamowienias
     * const zamowienia = await prisma.zamowienia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zamowieniaCreateManyArgs>(args?: SelectSubset<T, zamowieniaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zamowienias and returns the data saved in the database.
     * @param {zamowieniaCreateManyAndReturnArgs} args - Arguments to create many Zamowienias.
     * @example
     * // Create many Zamowienias
     * const zamowienia = await prisma.zamowienia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zamowienias and only return the `id`
     * const zamowieniaWithIdOnly = await prisma.zamowienia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zamowieniaCreateManyAndReturnArgs>(args?: SelectSubset<T, zamowieniaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zamowienia.
     * @param {zamowieniaDeleteArgs} args - Arguments to delete one Zamowienia.
     * @example
     * // Delete one Zamowienia
     * const Zamowienia = await prisma.zamowienia.delete({
     *   where: {
     *     // ... filter to delete one Zamowienia
     *   }
     * })
     * 
     */
    delete<T extends zamowieniaDeleteArgs>(args: SelectSubset<T, zamowieniaDeleteArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zamowienia.
     * @param {zamowieniaUpdateArgs} args - Arguments to update one Zamowienia.
     * @example
     * // Update one Zamowienia
     * const zamowienia = await prisma.zamowienia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zamowieniaUpdateArgs>(args: SelectSubset<T, zamowieniaUpdateArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zamowienias.
     * @param {zamowieniaDeleteManyArgs} args - Arguments to filter Zamowienias to delete.
     * @example
     * // Delete a few Zamowienias
     * const { count } = await prisma.zamowienia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zamowieniaDeleteManyArgs>(args?: SelectSubset<T, zamowieniaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zamowienias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zamowieniaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zamowienias
     * const zamowienia = await prisma.zamowienia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zamowieniaUpdateManyArgs>(args: SelectSubset<T, zamowieniaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zamowienias and returns the data updated in the database.
     * @param {zamowieniaUpdateManyAndReturnArgs} args - Arguments to update many Zamowienias.
     * @example
     * // Update many Zamowienias
     * const zamowienia = await prisma.zamowienia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zamowienias and only return the `id`
     * const zamowieniaWithIdOnly = await prisma.zamowienia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zamowieniaUpdateManyAndReturnArgs>(args: SelectSubset<T, zamowieniaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zamowienia.
     * @param {zamowieniaUpsertArgs} args - Arguments to update or create a Zamowienia.
     * @example
     * // Update or create a Zamowienia
     * const zamowienia = await prisma.zamowienia.upsert({
     *   create: {
     *     // ... data to create a Zamowienia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zamowienia we want to update
     *   }
     * })
     */
    upsert<T extends zamowieniaUpsertArgs>(args: SelectSubset<T, zamowieniaUpsertArgs<ExtArgs>>): Prisma__zamowieniaClient<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zamowienias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zamowieniaCountArgs} args - Arguments to filter Zamowienias to count.
     * @example
     * // Count the number of Zamowienias
     * const count = await prisma.zamowienia.count({
     *   where: {
     *     // ... the filter for the Zamowienias we want to count
     *   }
     * })
    **/
    count<T extends zamowieniaCountArgs>(
      args?: Subset<T, zamowieniaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZamowieniaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zamowienia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZamowieniaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZamowieniaAggregateArgs>(args: Subset<T, ZamowieniaAggregateArgs>): Prisma.PrismaPromise<GetZamowieniaAggregateType<T>>

    /**
     * Group by Zamowienia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zamowieniaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zamowieniaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zamowieniaGroupByArgs['orderBy'] }
        : { orderBy?: zamowieniaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zamowieniaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZamowieniaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zamowienia model
   */
  readonly fields: zamowieniaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zamowienia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zamowieniaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uzytkownik<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    produkt<T extends produktyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, produktyDefaultArgs<ExtArgs>>): Prisma__produktyClient<$Result.GetResult<Prisma.$produktyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends statusyzamowienDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statusyzamowienDefaultArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zamowienia model
   */
  interface zamowieniaFieldRefs {
    readonly id: FieldRef<"zamowienia", 'Int'>
    readonly uzytkownik_id: FieldRef<"zamowienia", 'Int'>
    readonly produkt_id: FieldRef<"zamowienia", 'Int'>
    readonly ilosc: FieldRef<"zamowienia", 'Int'>
    readonly data_zamowienia: FieldRef<"zamowienia", 'DateTime'>
    readonly status_id: FieldRef<"zamowienia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * zamowienia findUnique
   */
  export type zamowieniaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * Filter, which zamowienia to fetch.
     */
    where: zamowieniaWhereUniqueInput
  }

  /**
   * zamowienia findUniqueOrThrow
   */
  export type zamowieniaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * Filter, which zamowienia to fetch.
     */
    where: zamowieniaWhereUniqueInput
  }

  /**
   * zamowienia findFirst
   */
  export type zamowieniaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * Filter, which zamowienia to fetch.
     */
    where?: zamowieniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zamowienias to fetch.
     */
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zamowienias.
     */
    cursor?: zamowieniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zamowienias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zamowienias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zamowienias.
     */
    distinct?: ZamowieniaScalarFieldEnum | ZamowieniaScalarFieldEnum[]
  }

  /**
   * zamowienia findFirstOrThrow
   */
  export type zamowieniaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * Filter, which zamowienia to fetch.
     */
    where?: zamowieniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zamowienias to fetch.
     */
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zamowienias.
     */
    cursor?: zamowieniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zamowienias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zamowienias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zamowienias.
     */
    distinct?: ZamowieniaScalarFieldEnum | ZamowieniaScalarFieldEnum[]
  }

  /**
   * zamowienia findMany
   */
  export type zamowieniaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * Filter, which zamowienias to fetch.
     */
    where?: zamowieniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zamowienias to fetch.
     */
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zamowienias.
     */
    cursor?: zamowieniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zamowienias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zamowienias.
     */
    skip?: number
    distinct?: ZamowieniaScalarFieldEnum | ZamowieniaScalarFieldEnum[]
  }

  /**
   * zamowienia create
   */
  export type zamowieniaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * The data needed to create a zamowienia.
     */
    data: XOR<zamowieniaCreateInput, zamowieniaUncheckedCreateInput>
  }

  /**
   * zamowienia createMany
   */
  export type zamowieniaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zamowienias.
     */
    data: zamowieniaCreateManyInput | zamowieniaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zamowienia createManyAndReturn
   */
  export type zamowieniaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * The data used to create many zamowienias.
     */
    data: zamowieniaCreateManyInput | zamowieniaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * zamowienia update
   */
  export type zamowieniaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * The data needed to update a zamowienia.
     */
    data: XOR<zamowieniaUpdateInput, zamowieniaUncheckedUpdateInput>
    /**
     * Choose, which zamowienia to update.
     */
    where: zamowieniaWhereUniqueInput
  }

  /**
   * zamowienia updateMany
   */
  export type zamowieniaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zamowienias.
     */
    data: XOR<zamowieniaUpdateManyMutationInput, zamowieniaUncheckedUpdateManyInput>
    /**
     * Filter which zamowienias to update
     */
    where?: zamowieniaWhereInput
    /**
     * Limit how many zamowienias to update.
     */
    limit?: number
  }

  /**
   * zamowienia updateManyAndReturn
   */
  export type zamowieniaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * The data used to update zamowienias.
     */
    data: XOR<zamowieniaUpdateManyMutationInput, zamowieniaUncheckedUpdateManyInput>
    /**
     * Filter which zamowienias to update
     */
    where?: zamowieniaWhereInput
    /**
     * Limit how many zamowienias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * zamowienia upsert
   */
  export type zamowieniaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * The filter to search for the zamowienia to update in case it exists.
     */
    where: zamowieniaWhereUniqueInput
    /**
     * In case the zamowienia found by the `where` argument doesn't exist, create a new zamowienia with this data.
     */
    create: XOR<zamowieniaCreateInput, zamowieniaUncheckedCreateInput>
    /**
     * In case the zamowienia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zamowieniaUpdateInput, zamowieniaUncheckedUpdateInput>
  }

  /**
   * zamowienia delete
   */
  export type zamowieniaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    /**
     * Filter which zamowienia to delete.
     */
    where: zamowieniaWhereUniqueInput
  }

  /**
   * zamowienia deleteMany
   */
  export type zamowieniaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zamowienias to delete
     */
    where?: zamowieniaWhereInput
    /**
     * Limit how many zamowienias to delete.
     */
    limit?: number
  }

  /**
   * zamowienia without action
   */
  export type zamowieniaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
  }


  /**
   * Model statusyzamowien
   */

  export type AggregateStatusyzamowien = {
    _count: StatusyzamowienCountAggregateOutputType | null
    _avg: StatusyzamowienAvgAggregateOutputType | null
    _sum: StatusyzamowienSumAggregateOutputType | null
    _min: StatusyzamowienMinAggregateOutputType | null
    _max: StatusyzamowienMaxAggregateOutputType | null
  }

  export type StatusyzamowienAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusyzamowienSumAggregateOutputType = {
    id: number | null
  }

  export type StatusyzamowienMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type StatusyzamowienMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type StatusyzamowienCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type StatusyzamowienAvgAggregateInputType = {
    id?: true
  }

  export type StatusyzamowienSumAggregateInputType = {
    id?: true
  }

  export type StatusyzamowienMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type StatusyzamowienMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type StatusyzamowienCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type StatusyzamowienAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statusyzamowien to aggregate.
     */
    where?: statusyzamowienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzamowiens to fetch.
     */
    orderBy?: statusyzamowienOrderByWithRelationInput | statusyzamowienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statusyzamowienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzamowiens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzamowiens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statusyzamowiens
    **/
    _count?: true | StatusyzamowienCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusyzamowienAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusyzamowienSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusyzamowienMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusyzamowienMaxAggregateInputType
  }

  export type GetStatusyzamowienAggregateType<T extends StatusyzamowienAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusyzamowien]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusyzamowien[P]>
      : GetScalarType<T[P], AggregateStatusyzamowien[P]>
  }




  export type statusyzamowienGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statusyzamowienWhereInput
    orderBy?: statusyzamowienOrderByWithAggregationInput | statusyzamowienOrderByWithAggregationInput[]
    by: StatusyzamowienScalarFieldEnum[] | StatusyzamowienScalarFieldEnum
    having?: statusyzamowienScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusyzamowienCountAggregateInputType | true
    _avg?: StatusyzamowienAvgAggregateInputType
    _sum?: StatusyzamowienSumAggregateInputType
    _min?: StatusyzamowienMinAggregateInputType
    _max?: StatusyzamowienMaxAggregateInputType
  }

  export type StatusyzamowienGroupByOutputType = {
    id: number
    nazwa: string
    _count: StatusyzamowienCountAggregateOutputType | null
    _avg: StatusyzamowienAvgAggregateOutputType | null
    _sum: StatusyzamowienSumAggregateOutputType | null
    _min: StatusyzamowienMinAggregateOutputType | null
    _max: StatusyzamowienMaxAggregateOutputType | null
  }

  type GetStatusyzamowienGroupByPayload<T extends statusyzamowienGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusyzamowienGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusyzamowienGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusyzamowienGroupByOutputType[P]>
            : GetScalarType<T[P], StatusyzamowienGroupByOutputType[P]>
        }
      >
    >


  export type statusyzamowienSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    zamowienia?: boolean | statusyzamowien$zamowieniaArgs<ExtArgs>
    _count?: boolean | StatusyzamowienCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusyzamowien"]>

  export type statusyzamowienSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["statusyzamowien"]>

  export type statusyzamowienSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["statusyzamowien"]>

  export type statusyzamowienSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type statusyzamowienOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["statusyzamowien"]>
  export type statusyzamowienInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zamowienia?: boolean | statusyzamowien$zamowieniaArgs<ExtArgs>
    _count?: boolean | StatusyzamowienCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type statusyzamowienIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type statusyzamowienIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $statusyzamowienPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statusyzamowien"
    objects: {
      zamowienia: Prisma.$zamowieniaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["statusyzamowien"]>
    composites: {}
  }

  type statusyzamowienGetPayload<S extends boolean | null | undefined | statusyzamowienDefaultArgs> = $Result.GetResult<Prisma.$statusyzamowienPayload, S>

  type statusyzamowienCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statusyzamowienFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusyzamowienCountAggregateInputType | true
    }

  export interface statusyzamowienDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statusyzamowien'], meta: { name: 'statusyzamowien' } }
    /**
     * Find zero or one Statusyzamowien that matches the filter.
     * @param {statusyzamowienFindUniqueArgs} args - Arguments to find a Statusyzamowien
     * @example
     * // Get one Statusyzamowien
     * const statusyzamowien = await prisma.statusyzamowien.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusyzamowienFindUniqueArgs>(args: SelectSubset<T, statusyzamowienFindUniqueArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Statusyzamowien that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusyzamowienFindUniqueOrThrowArgs} args - Arguments to find a Statusyzamowien
     * @example
     * // Get one Statusyzamowien
     * const statusyzamowien = await prisma.statusyzamowien.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusyzamowienFindUniqueOrThrowArgs>(args: SelectSubset<T, statusyzamowienFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statusyzamowien that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzamowienFindFirstArgs} args - Arguments to find a Statusyzamowien
     * @example
     * // Get one Statusyzamowien
     * const statusyzamowien = await prisma.statusyzamowien.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusyzamowienFindFirstArgs>(args?: SelectSubset<T, statusyzamowienFindFirstArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statusyzamowien that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzamowienFindFirstOrThrowArgs} args - Arguments to find a Statusyzamowien
     * @example
     * // Get one Statusyzamowien
     * const statusyzamowien = await prisma.statusyzamowien.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusyzamowienFindFirstOrThrowArgs>(args?: SelectSubset<T, statusyzamowienFindFirstOrThrowArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statusyzamowiens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzamowienFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statusyzamowiens
     * const statusyzamowiens = await prisma.statusyzamowien.findMany()
     * 
     * // Get first 10 Statusyzamowiens
     * const statusyzamowiens = await prisma.statusyzamowien.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusyzamowienWithIdOnly = await prisma.statusyzamowien.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statusyzamowienFindManyArgs>(args?: SelectSubset<T, statusyzamowienFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Statusyzamowien.
     * @param {statusyzamowienCreateArgs} args - Arguments to create a Statusyzamowien.
     * @example
     * // Create one Statusyzamowien
     * const Statusyzamowien = await prisma.statusyzamowien.create({
     *   data: {
     *     // ... data to create a Statusyzamowien
     *   }
     * })
     * 
     */
    create<T extends statusyzamowienCreateArgs>(args: SelectSubset<T, statusyzamowienCreateArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statusyzamowiens.
     * @param {statusyzamowienCreateManyArgs} args - Arguments to create many Statusyzamowiens.
     * @example
     * // Create many Statusyzamowiens
     * const statusyzamowien = await prisma.statusyzamowien.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statusyzamowienCreateManyArgs>(args?: SelectSubset<T, statusyzamowienCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Statusyzamowiens and returns the data saved in the database.
     * @param {statusyzamowienCreateManyAndReturnArgs} args - Arguments to create many Statusyzamowiens.
     * @example
     * // Create many Statusyzamowiens
     * const statusyzamowien = await prisma.statusyzamowien.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Statusyzamowiens and only return the `id`
     * const statusyzamowienWithIdOnly = await prisma.statusyzamowien.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends statusyzamowienCreateManyAndReturnArgs>(args?: SelectSubset<T, statusyzamowienCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Statusyzamowien.
     * @param {statusyzamowienDeleteArgs} args - Arguments to delete one Statusyzamowien.
     * @example
     * // Delete one Statusyzamowien
     * const Statusyzamowien = await prisma.statusyzamowien.delete({
     *   where: {
     *     // ... filter to delete one Statusyzamowien
     *   }
     * })
     * 
     */
    delete<T extends statusyzamowienDeleteArgs>(args: SelectSubset<T, statusyzamowienDeleteArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Statusyzamowien.
     * @param {statusyzamowienUpdateArgs} args - Arguments to update one Statusyzamowien.
     * @example
     * // Update one Statusyzamowien
     * const statusyzamowien = await prisma.statusyzamowien.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statusyzamowienUpdateArgs>(args: SelectSubset<T, statusyzamowienUpdateArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statusyzamowiens.
     * @param {statusyzamowienDeleteManyArgs} args - Arguments to filter Statusyzamowiens to delete.
     * @example
     * // Delete a few Statusyzamowiens
     * const { count } = await prisma.statusyzamowien.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statusyzamowienDeleteManyArgs>(args?: SelectSubset<T, statusyzamowienDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statusyzamowiens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzamowienUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statusyzamowiens
     * const statusyzamowien = await prisma.statusyzamowien.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statusyzamowienUpdateManyArgs>(args: SelectSubset<T, statusyzamowienUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statusyzamowiens and returns the data updated in the database.
     * @param {statusyzamowienUpdateManyAndReturnArgs} args - Arguments to update many Statusyzamowiens.
     * @example
     * // Update many Statusyzamowiens
     * const statusyzamowien = await prisma.statusyzamowien.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Statusyzamowiens and only return the `id`
     * const statusyzamowienWithIdOnly = await prisma.statusyzamowien.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends statusyzamowienUpdateManyAndReturnArgs>(args: SelectSubset<T, statusyzamowienUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Statusyzamowien.
     * @param {statusyzamowienUpsertArgs} args - Arguments to update or create a Statusyzamowien.
     * @example
     * // Update or create a Statusyzamowien
     * const statusyzamowien = await prisma.statusyzamowien.upsert({
     *   create: {
     *     // ... data to create a Statusyzamowien
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statusyzamowien we want to update
     *   }
     * })
     */
    upsert<T extends statusyzamowienUpsertArgs>(args: SelectSubset<T, statusyzamowienUpsertArgs<ExtArgs>>): Prisma__statusyzamowienClient<$Result.GetResult<Prisma.$statusyzamowienPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statusyzamowiens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzamowienCountArgs} args - Arguments to filter Statusyzamowiens to count.
     * @example
     * // Count the number of Statusyzamowiens
     * const count = await prisma.statusyzamowien.count({
     *   where: {
     *     // ... the filter for the Statusyzamowiens we want to count
     *   }
     * })
    **/
    count<T extends statusyzamowienCountArgs>(
      args?: Subset<T, statusyzamowienCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusyzamowienCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statusyzamowien.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusyzamowienAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusyzamowienAggregateArgs>(args: Subset<T, StatusyzamowienAggregateArgs>): Prisma.PrismaPromise<GetStatusyzamowienAggregateType<T>>

    /**
     * Group by Statusyzamowien.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzamowienGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statusyzamowienGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusyzamowienGroupByArgs['orderBy'] }
        : { orderBy?: statusyzamowienGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statusyzamowienGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusyzamowienGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statusyzamowien model
   */
  readonly fields: statusyzamowienFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statusyzamowien.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusyzamowienClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zamowienia<T extends statusyzamowien$zamowieniaArgs<ExtArgs> = {}>(args?: Subset<T, statusyzamowien$zamowieniaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zamowieniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statusyzamowien model
   */
  interface statusyzamowienFieldRefs {
    readonly id: FieldRef<"statusyzamowien", 'Int'>
    readonly nazwa: FieldRef<"statusyzamowien", 'String'>
  }
    

  // Custom InputTypes
  /**
   * statusyzamowien findUnique
   */
  export type statusyzamowienFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * Filter, which statusyzamowien to fetch.
     */
    where: statusyzamowienWhereUniqueInput
  }

  /**
   * statusyzamowien findUniqueOrThrow
   */
  export type statusyzamowienFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * Filter, which statusyzamowien to fetch.
     */
    where: statusyzamowienWhereUniqueInput
  }

  /**
   * statusyzamowien findFirst
   */
  export type statusyzamowienFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * Filter, which statusyzamowien to fetch.
     */
    where?: statusyzamowienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzamowiens to fetch.
     */
    orderBy?: statusyzamowienOrderByWithRelationInput | statusyzamowienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusyzamowiens.
     */
    cursor?: statusyzamowienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzamowiens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzamowiens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusyzamowiens.
     */
    distinct?: StatusyzamowienScalarFieldEnum | StatusyzamowienScalarFieldEnum[]
  }

  /**
   * statusyzamowien findFirstOrThrow
   */
  export type statusyzamowienFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * Filter, which statusyzamowien to fetch.
     */
    where?: statusyzamowienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzamowiens to fetch.
     */
    orderBy?: statusyzamowienOrderByWithRelationInput | statusyzamowienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusyzamowiens.
     */
    cursor?: statusyzamowienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzamowiens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzamowiens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusyzamowiens.
     */
    distinct?: StatusyzamowienScalarFieldEnum | StatusyzamowienScalarFieldEnum[]
  }

  /**
   * statusyzamowien findMany
   */
  export type statusyzamowienFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * Filter, which statusyzamowiens to fetch.
     */
    where?: statusyzamowienWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzamowiens to fetch.
     */
    orderBy?: statusyzamowienOrderByWithRelationInput | statusyzamowienOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statusyzamowiens.
     */
    cursor?: statusyzamowienWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzamowiens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzamowiens.
     */
    skip?: number
    distinct?: StatusyzamowienScalarFieldEnum | StatusyzamowienScalarFieldEnum[]
  }

  /**
   * statusyzamowien create
   */
  export type statusyzamowienCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * The data needed to create a statusyzamowien.
     */
    data: XOR<statusyzamowienCreateInput, statusyzamowienUncheckedCreateInput>
  }

  /**
   * statusyzamowien createMany
   */
  export type statusyzamowienCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statusyzamowiens.
     */
    data: statusyzamowienCreateManyInput | statusyzamowienCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statusyzamowien createManyAndReturn
   */
  export type statusyzamowienCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * The data used to create many statusyzamowiens.
     */
    data: statusyzamowienCreateManyInput | statusyzamowienCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statusyzamowien update
   */
  export type statusyzamowienUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * The data needed to update a statusyzamowien.
     */
    data: XOR<statusyzamowienUpdateInput, statusyzamowienUncheckedUpdateInput>
    /**
     * Choose, which statusyzamowien to update.
     */
    where: statusyzamowienWhereUniqueInput
  }

  /**
   * statusyzamowien updateMany
   */
  export type statusyzamowienUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statusyzamowiens.
     */
    data: XOR<statusyzamowienUpdateManyMutationInput, statusyzamowienUncheckedUpdateManyInput>
    /**
     * Filter which statusyzamowiens to update
     */
    where?: statusyzamowienWhereInput
    /**
     * Limit how many statusyzamowiens to update.
     */
    limit?: number
  }

  /**
   * statusyzamowien updateManyAndReturn
   */
  export type statusyzamowienUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * The data used to update statusyzamowiens.
     */
    data: XOR<statusyzamowienUpdateManyMutationInput, statusyzamowienUncheckedUpdateManyInput>
    /**
     * Filter which statusyzamowiens to update
     */
    where?: statusyzamowienWhereInput
    /**
     * Limit how many statusyzamowiens to update.
     */
    limit?: number
  }

  /**
   * statusyzamowien upsert
   */
  export type statusyzamowienUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * The filter to search for the statusyzamowien to update in case it exists.
     */
    where: statusyzamowienWhereUniqueInput
    /**
     * In case the statusyzamowien found by the `where` argument doesn't exist, create a new statusyzamowien with this data.
     */
    create: XOR<statusyzamowienCreateInput, statusyzamowienUncheckedCreateInput>
    /**
     * In case the statusyzamowien was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusyzamowienUpdateInput, statusyzamowienUncheckedUpdateInput>
  }

  /**
   * statusyzamowien delete
   */
  export type statusyzamowienDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
    /**
     * Filter which statusyzamowien to delete.
     */
    where: statusyzamowienWhereUniqueInput
  }

  /**
   * statusyzamowien deleteMany
   */
  export type statusyzamowienDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statusyzamowiens to delete
     */
    where?: statusyzamowienWhereInput
    /**
     * Limit how many statusyzamowiens to delete.
     */
    limit?: number
  }

  /**
   * statusyzamowien.zamowienia
   */
  export type statusyzamowien$zamowieniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zamowienia
     */
    select?: zamowieniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zamowienia
     */
    omit?: zamowieniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zamowieniaInclude<ExtArgs> | null
    where?: zamowieniaWhereInput
    orderBy?: zamowieniaOrderByWithRelationInput | zamowieniaOrderByWithRelationInput[]
    cursor?: zamowieniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZamowieniaScalarFieldEnum | ZamowieniaScalarFieldEnum[]
  }

  /**
   * statusyzamowien without action
   */
  export type statusyzamowienDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzamowien
     */
    select?: statusyzamowienSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzamowien
     */
    omit?: statusyzamowienOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzamowienInclude<ExtArgs> | null
  }


  /**
   * Model zlecenia
   */

  export type AggregateZlecenia = {
    _count: ZleceniaCountAggregateOutputType | null
    _avg: ZleceniaAvgAggregateOutputType | null
    _sum: ZleceniaSumAggregateOutputType | null
    _min: ZleceniaMinAggregateOutputType | null
    _max: ZleceniaMaxAggregateOutputType | null
  }

  export type ZleceniaAvgAggregateOutputType = {
    id: number | null
    zleceniodawca_id: number | null
    wykonawca_id: number | null
    status_id: number | null
    typ_id: number | null
  }

  export type ZleceniaSumAggregateOutputType = {
    id: number | null
    zleceniodawca_id: number | null
    wykonawca_id: number | null
    status_id: number | null
    typ_id: number | null
  }

  export type ZleceniaMinAggregateOutputType = {
    id: number | null
    tytul: string | null
    opis: string | null
    zleceniodawca_id: number | null
    wykonawca_id: number | null
    data_utworzenia: Date | null
    status_id: number | null
    typ_id: number | null
  }

  export type ZleceniaMaxAggregateOutputType = {
    id: number | null
    tytul: string | null
    opis: string | null
    zleceniodawca_id: number | null
    wykonawca_id: number | null
    data_utworzenia: Date | null
    status_id: number | null
    typ_id: number | null
  }

  export type ZleceniaCountAggregateOutputType = {
    id: number
    tytul: number
    opis: number
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia: number
    status_id: number
    typ_id: number
    _all: number
  }


  export type ZleceniaAvgAggregateInputType = {
    id?: true
    zleceniodawca_id?: true
    wykonawca_id?: true
    status_id?: true
    typ_id?: true
  }

  export type ZleceniaSumAggregateInputType = {
    id?: true
    zleceniodawca_id?: true
    wykonawca_id?: true
    status_id?: true
    typ_id?: true
  }

  export type ZleceniaMinAggregateInputType = {
    id?: true
    tytul?: true
    opis?: true
    zleceniodawca_id?: true
    wykonawca_id?: true
    data_utworzenia?: true
    status_id?: true
    typ_id?: true
  }

  export type ZleceniaMaxAggregateInputType = {
    id?: true
    tytul?: true
    opis?: true
    zleceniodawca_id?: true
    wykonawca_id?: true
    data_utworzenia?: true
    status_id?: true
    typ_id?: true
  }

  export type ZleceniaCountAggregateInputType = {
    id?: true
    tytul?: true
    opis?: true
    zleceniodawca_id?: true
    wykonawca_id?: true
    data_utworzenia?: true
    status_id?: true
    typ_id?: true
    _all?: true
  }

  export type ZleceniaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zlecenia to aggregate.
     */
    where?: zleceniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zlecenias to fetch.
     */
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zleceniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zlecenias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zlecenias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zlecenias
    **/
    _count?: true | ZleceniaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZleceniaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZleceniaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZleceniaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZleceniaMaxAggregateInputType
  }

  export type GetZleceniaAggregateType<T extends ZleceniaAggregateArgs> = {
        [P in keyof T & keyof AggregateZlecenia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZlecenia[P]>
      : GetScalarType<T[P], AggregateZlecenia[P]>
  }




  export type zleceniaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zleceniaWhereInput
    orderBy?: zleceniaOrderByWithAggregationInput | zleceniaOrderByWithAggregationInput[]
    by: ZleceniaScalarFieldEnum[] | ZleceniaScalarFieldEnum
    having?: zleceniaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZleceniaCountAggregateInputType | true
    _avg?: ZleceniaAvgAggregateInputType
    _sum?: ZleceniaSumAggregateInputType
    _min?: ZleceniaMinAggregateInputType
    _max?: ZleceniaMaxAggregateInputType
  }

  export type ZleceniaGroupByOutputType = {
    id: number
    tytul: string | null
    opis: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia: Date | null
    status_id: number
    typ_id: number
    _count: ZleceniaCountAggregateOutputType | null
    _avg: ZleceniaAvgAggregateOutputType | null
    _sum: ZleceniaSumAggregateOutputType | null
    _min: ZleceniaMinAggregateOutputType | null
    _max: ZleceniaMaxAggregateOutputType | null
  }

  type GetZleceniaGroupByPayload<T extends zleceniaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZleceniaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZleceniaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZleceniaGroupByOutputType[P]>
            : GetScalarType<T[P], ZleceniaGroupByOutputType[P]>
        }
      >
    >


  export type zleceniaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tytul?: boolean
    opis?: boolean
    zleceniodawca_id?: boolean
    wykonawca_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    typ_id?: boolean
    zleceniodawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    wykonawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyzlecenDefaultArgs<ExtArgs>
    typ?: boolean | typyzlecenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zlecenia"]>

  export type zleceniaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tytul?: boolean
    opis?: boolean
    zleceniodawca_id?: boolean
    wykonawca_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    typ_id?: boolean
    zleceniodawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    wykonawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyzlecenDefaultArgs<ExtArgs>
    typ?: boolean | typyzlecenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zlecenia"]>

  export type zleceniaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tytul?: boolean
    opis?: boolean
    zleceniodawca_id?: boolean
    wykonawca_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    typ_id?: boolean
    zleceniodawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    wykonawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyzlecenDefaultArgs<ExtArgs>
    typ?: boolean | typyzlecenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zlecenia"]>

  export type zleceniaSelectScalar = {
    id?: boolean
    tytul?: boolean
    opis?: boolean
    zleceniodawca_id?: boolean
    wykonawca_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    typ_id?: boolean
  }

  export type zleceniaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tytul" | "opis" | "zleceniodawca_id" | "wykonawca_id" | "data_utworzenia" | "status_id" | "typ_id", ExtArgs["result"]["zlecenia"]>
  export type zleceniaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zleceniodawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    wykonawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyzlecenDefaultArgs<ExtArgs>
    typ?: boolean | typyzlecenDefaultArgs<ExtArgs>
  }
  export type zleceniaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zleceniodawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    wykonawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyzlecenDefaultArgs<ExtArgs>
    typ?: boolean | typyzlecenDefaultArgs<ExtArgs>
  }
  export type zleceniaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zleceniodawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    wykonawca?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyzlecenDefaultArgs<ExtArgs>
    typ?: boolean | typyzlecenDefaultArgs<ExtArgs>
  }

  export type $zleceniaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zlecenia"
    objects: {
      zleceniodawca: Prisma.$uzytkownicyPayload<ExtArgs>
      wykonawca: Prisma.$uzytkownicyPayload<ExtArgs>
      status: Prisma.$statusyzlecenPayload<ExtArgs>
      typ: Prisma.$typyzlecenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tytul: string | null
      opis: string | null
      zleceniodawca_id: number
      wykonawca_id: number
      data_utworzenia: Date | null
      status_id: number
      typ_id: number
    }, ExtArgs["result"]["zlecenia"]>
    composites: {}
  }

  type zleceniaGetPayload<S extends boolean | null | undefined | zleceniaDefaultArgs> = $Result.GetResult<Prisma.$zleceniaPayload, S>

  type zleceniaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zleceniaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZleceniaCountAggregateInputType | true
    }

  export interface zleceniaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zlecenia'], meta: { name: 'zlecenia' } }
    /**
     * Find zero or one Zlecenia that matches the filter.
     * @param {zleceniaFindUniqueArgs} args - Arguments to find a Zlecenia
     * @example
     * // Get one Zlecenia
     * const zlecenia = await prisma.zlecenia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zleceniaFindUniqueArgs>(args: SelectSubset<T, zleceniaFindUniqueArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zlecenia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zleceniaFindUniqueOrThrowArgs} args - Arguments to find a Zlecenia
     * @example
     * // Get one Zlecenia
     * const zlecenia = await prisma.zlecenia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zleceniaFindUniqueOrThrowArgs>(args: SelectSubset<T, zleceniaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zlecenia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zleceniaFindFirstArgs} args - Arguments to find a Zlecenia
     * @example
     * // Get one Zlecenia
     * const zlecenia = await prisma.zlecenia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zleceniaFindFirstArgs>(args?: SelectSubset<T, zleceniaFindFirstArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zlecenia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zleceniaFindFirstOrThrowArgs} args - Arguments to find a Zlecenia
     * @example
     * // Get one Zlecenia
     * const zlecenia = await prisma.zlecenia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zleceniaFindFirstOrThrowArgs>(args?: SelectSubset<T, zleceniaFindFirstOrThrowArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zlecenias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zleceniaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zlecenias
     * const zlecenias = await prisma.zlecenia.findMany()
     * 
     * // Get first 10 Zlecenias
     * const zlecenias = await prisma.zlecenia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zleceniaWithIdOnly = await prisma.zlecenia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zleceniaFindManyArgs>(args?: SelectSubset<T, zleceniaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zlecenia.
     * @param {zleceniaCreateArgs} args - Arguments to create a Zlecenia.
     * @example
     * // Create one Zlecenia
     * const Zlecenia = await prisma.zlecenia.create({
     *   data: {
     *     // ... data to create a Zlecenia
     *   }
     * })
     * 
     */
    create<T extends zleceniaCreateArgs>(args: SelectSubset<T, zleceniaCreateArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zlecenias.
     * @param {zleceniaCreateManyArgs} args - Arguments to create many Zlecenias.
     * @example
     * // Create many Zlecenias
     * const zlecenia = await prisma.zlecenia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zleceniaCreateManyArgs>(args?: SelectSubset<T, zleceniaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zlecenias and returns the data saved in the database.
     * @param {zleceniaCreateManyAndReturnArgs} args - Arguments to create many Zlecenias.
     * @example
     * // Create many Zlecenias
     * const zlecenia = await prisma.zlecenia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zlecenias and only return the `id`
     * const zleceniaWithIdOnly = await prisma.zlecenia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zleceniaCreateManyAndReturnArgs>(args?: SelectSubset<T, zleceniaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zlecenia.
     * @param {zleceniaDeleteArgs} args - Arguments to delete one Zlecenia.
     * @example
     * // Delete one Zlecenia
     * const Zlecenia = await prisma.zlecenia.delete({
     *   where: {
     *     // ... filter to delete one Zlecenia
     *   }
     * })
     * 
     */
    delete<T extends zleceniaDeleteArgs>(args: SelectSubset<T, zleceniaDeleteArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zlecenia.
     * @param {zleceniaUpdateArgs} args - Arguments to update one Zlecenia.
     * @example
     * // Update one Zlecenia
     * const zlecenia = await prisma.zlecenia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zleceniaUpdateArgs>(args: SelectSubset<T, zleceniaUpdateArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zlecenias.
     * @param {zleceniaDeleteManyArgs} args - Arguments to filter Zlecenias to delete.
     * @example
     * // Delete a few Zlecenias
     * const { count } = await prisma.zlecenia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zleceniaDeleteManyArgs>(args?: SelectSubset<T, zleceniaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zlecenias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zleceniaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zlecenias
     * const zlecenia = await prisma.zlecenia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zleceniaUpdateManyArgs>(args: SelectSubset<T, zleceniaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zlecenias and returns the data updated in the database.
     * @param {zleceniaUpdateManyAndReturnArgs} args - Arguments to update many Zlecenias.
     * @example
     * // Update many Zlecenias
     * const zlecenia = await prisma.zlecenia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zlecenias and only return the `id`
     * const zleceniaWithIdOnly = await prisma.zlecenia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zleceniaUpdateManyAndReturnArgs>(args: SelectSubset<T, zleceniaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zlecenia.
     * @param {zleceniaUpsertArgs} args - Arguments to update or create a Zlecenia.
     * @example
     * // Update or create a Zlecenia
     * const zlecenia = await prisma.zlecenia.upsert({
     *   create: {
     *     // ... data to create a Zlecenia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zlecenia we want to update
     *   }
     * })
     */
    upsert<T extends zleceniaUpsertArgs>(args: SelectSubset<T, zleceniaUpsertArgs<ExtArgs>>): Prisma__zleceniaClient<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zlecenias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zleceniaCountArgs} args - Arguments to filter Zlecenias to count.
     * @example
     * // Count the number of Zlecenias
     * const count = await prisma.zlecenia.count({
     *   where: {
     *     // ... the filter for the Zlecenias we want to count
     *   }
     * })
    **/
    count<T extends zleceniaCountArgs>(
      args?: Subset<T, zleceniaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZleceniaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zlecenia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZleceniaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZleceniaAggregateArgs>(args: Subset<T, ZleceniaAggregateArgs>): Prisma.PrismaPromise<GetZleceniaAggregateType<T>>

    /**
     * Group by Zlecenia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zleceniaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zleceniaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zleceniaGroupByArgs['orderBy'] }
        : { orderBy?: zleceniaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zleceniaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZleceniaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zlecenia model
   */
  readonly fields: zleceniaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zlecenia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zleceniaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zleceniodawca<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    wykonawca<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends statusyzlecenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statusyzlecenDefaultArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    typ<T extends typyzlecenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, typyzlecenDefaultArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zlecenia model
   */
  interface zleceniaFieldRefs {
    readonly id: FieldRef<"zlecenia", 'Int'>
    readonly tytul: FieldRef<"zlecenia", 'String'>
    readonly opis: FieldRef<"zlecenia", 'String'>
    readonly zleceniodawca_id: FieldRef<"zlecenia", 'Int'>
    readonly wykonawca_id: FieldRef<"zlecenia", 'Int'>
    readonly data_utworzenia: FieldRef<"zlecenia", 'DateTime'>
    readonly status_id: FieldRef<"zlecenia", 'Int'>
    readonly typ_id: FieldRef<"zlecenia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * zlecenia findUnique
   */
  export type zleceniaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * Filter, which zlecenia to fetch.
     */
    where: zleceniaWhereUniqueInput
  }

  /**
   * zlecenia findUniqueOrThrow
   */
  export type zleceniaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * Filter, which zlecenia to fetch.
     */
    where: zleceniaWhereUniqueInput
  }

  /**
   * zlecenia findFirst
   */
  export type zleceniaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * Filter, which zlecenia to fetch.
     */
    where?: zleceniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zlecenias to fetch.
     */
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zlecenias.
     */
    cursor?: zleceniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zlecenias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zlecenias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zlecenias.
     */
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * zlecenia findFirstOrThrow
   */
  export type zleceniaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * Filter, which zlecenia to fetch.
     */
    where?: zleceniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zlecenias to fetch.
     */
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zlecenias.
     */
    cursor?: zleceniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zlecenias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zlecenias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zlecenias.
     */
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * zlecenia findMany
   */
  export type zleceniaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * Filter, which zlecenias to fetch.
     */
    where?: zleceniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zlecenias to fetch.
     */
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zlecenias.
     */
    cursor?: zleceniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zlecenias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zlecenias.
     */
    skip?: number
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * zlecenia create
   */
  export type zleceniaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * The data needed to create a zlecenia.
     */
    data: XOR<zleceniaCreateInput, zleceniaUncheckedCreateInput>
  }

  /**
   * zlecenia createMany
   */
  export type zleceniaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zlecenias.
     */
    data: zleceniaCreateManyInput | zleceniaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zlecenia createManyAndReturn
   */
  export type zleceniaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * The data used to create many zlecenias.
     */
    data: zleceniaCreateManyInput | zleceniaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * zlecenia update
   */
  export type zleceniaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * The data needed to update a zlecenia.
     */
    data: XOR<zleceniaUpdateInput, zleceniaUncheckedUpdateInput>
    /**
     * Choose, which zlecenia to update.
     */
    where: zleceniaWhereUniqueInput
  }

  /**
   * zlecenia updateMany
   */
  export type zleceniaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zlecenias.
     */
    data: XOR<zleceniaUpdateManyMutationInput, zleceniaUncheckedUpdateManyInput>
    /**
     * Filter which zlecenias to update
     */
    where?: zleceniaWhereInput
    /**
     * Limit how many zlecenias to update.
     */
    limit?: number
  }

  /**
   * zlecenia updateManyAndReturn
   */
  export type zleceniaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * The data used to update zlecenias.
     */
    data: XOR<zleceniaUpdateManyMutationInput, zleceniaUncheckedUpdateManyInput>
    /**
     * Filter which zlecenias to update
     */
    where?: zleceniaWhereInput
    /**
     * Limit how many zlecenias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * zlecenia upsert
   */
  export type zleceniaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * The filter to search for the zlecenia to update in case it exists.
     */
    where: zleceniaWhereUniqueInput
    /**
     * In case the zlecenia found by the `where` argument doesn't exist, create a new zlecenia with this data.
     */
    create: XOR<zleceniaCreateInput, zleceniaUncheckedCreateInput>
    /**
     * In case the zlecenia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zleceniaUpdateInput, zleceniaUncheckedUpdateInput>
  }

  /**
   * zlecenia delete
   */
  export type zleceniaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    /**
     * Filter which zlecenia to delete.
     */
    where: zleceniaWhereUniqueInput
  }

  /**
   * zlecenia deleteMany
   */
  export type zleceniaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zlecenias to delete
     */
    where?: zleceniaWhereInput
    /**
     * Limit how many zlecenias to delete.
     */
    limit?: number
  }

  /**
   * zlecenia without action
   */
  export type zleceniaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
  }


  /**
   * Model statusyzlecen
   */

  export type AggregateStatusyzlecen = {
    _count: StatusyzlecenCountAggregateOutputType | null
    _avg: StatusyzlecenAvgAggregateOutputType | null
    _sum: StatusyzlecenSumAggregateOutputType | null
    _min: StatusyzlecenMinAggregateOutputType | null
    _max: StatusyzlecenMaxAggregateOutputType | null
  }

  export type StatusyzlecenAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusyzlecenSumAggregateOutputType = {
    id: number | null
  }

  export type StatusyzlecenMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type StatusyzlecenMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type StatusyzlecenCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type StatusyzlecenAvgAggregateInputType = {
    id?: true
  }

  export type StatusyzlecenSumAggregateInputType = {
    id?: true
  }

  export type StatusyzlecenMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type StatusyzlecenMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type StatusyzlecenCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type StatusyzlecenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statusyzlecen to aggregate.
     */
    where?: statusyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzlecens to fetch.
     */
    orderBy?: statusyzlecenOrderByWithRelationInput | statusyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statusyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzlecens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statusyzlecens
    **/
    _count?: true | StatusyzlecenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusyzlecenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusyzlecenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusyzlecenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusyzlecenMaxAggregateInputType
  }

  export type GetStatusyzlecenAggregateType<T extends StatusyzlecenAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusyzlecen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusyzlecen[P]>
      : GetScalarType<T[P], AggregateStatusyzlecen[P]>
  }




  export type statusyzlecenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statusyzlecenWhereInput
    orderBy?: statusyzlecenOrderByWithAggregationInput | statusyzlecenOrderByWithAggregationInput[]
    by: StatusyzlecenScalarFieldEnum[] | StatusyzlecenScalarFieldEnum
    having?: statusyzlecenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusyzlecenCountAggregateInputType | true
    _avg?: StatusyzlecenAvgAggregateInputType
    _sum?: StatusyzlecenSumAggregateInputType
    _min?: StatusyzlecenMinAggregateInputType
    _max?: StatusyzlecenMaxAggregateInputType
  }

  export type StatusyzlecenGroupByOutputType = {
    id: number
    nazwa: string
    _count: StatusyzlecenCountAggregateOutputType | null
    _avg: StatusyzlecenAvgAggregateOutputType | null
    _sum: StatusyzlecenSumAggregateOutputType | null
    _min: StatusyzlecenMinAggregateOutputType | null
    _max: StatusyzlecenMaxAggregateOutputType | null
  }

  type GetStatusyzlecenGroupByPayload<T extends statusyzlecenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusyzlecenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusyzlecenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusyzlecenGroupByOutputType[P]>
            : GetScalarType<T[P], StatusyzlecenGroupByOutputType[P]>
        }
      >
    >


  export type statusyzlecenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    zlecenia?: boolean | statusyzlecen$zleceniaArgs<ExtArgs>
    _count?: boolean | StatusyzlecenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusyzlecen"]>

  export type statusyzlecenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["statusyzlecen"]>

  export type statusyzlecenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["statusyzlecen"]>

  export type statusyzlecenSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type statusyzlecenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["statusyzlecen"]>
  export type statusyzlecenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zlecenia?: boolean | statusyzlecen$zleceniaArgs<ExtArgs>
    _count?: boolean | StatusyzlecenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type statusyzlecenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type statusyzlecenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $statusyzlecenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statusyzlecen"
    objects: {
      zlecenia: Prisma.$zleceniaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["statusyzlecen"]>
    composites: {}
  }

  type statusyzlecenGetPayload<S extends boolean | null | undefined | statusyzlecenDefaultArgs> = $Result.GetResult<Prisma.$statusyzlecenPayload, S>

  type statusyzlecenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statusyzlecenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusyzlecenCountAggregateInputType | true
    }

  export interface statusyzlecenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statusyzlecen'], meta: { name: 'statusyzlecen' } }
    /**
     * Find zero or one Statusyzlecen that matches the filter.
     * @param {statusyzlecenFindUniqueArgs} args - Arguments to find a Statusyzlecen
     * @example
     * // Get one Statusyzlecen
     * const statusyzlecen = await prisma.statusyzlecen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusyzlecenFindUniqueArgs>(args: SelectSubset<T, statusyzlecenFindUniqueArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Statusyzlecen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusyzlecenFindUniqueOrThrowArgs} args - Arguments to find a Statusyzlecen
     * @example
     * // Get one Statusyzlecen
     * const statusyzlecen = await prisma.statusyzlecen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusyzlecenFindUniqueOrThrowArgs>(args: SelectSubset<T, statusyzlecenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statusyzlecen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzlecenFindFirstArgs} args - Arguments to find a Statusyzlecen
     * @example
     * // Get one Statusyzlecen
     * const statusyzlecen = await prisma.statusyzlecen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusyzlecenFindFirstArgs>(args?: SelectSubset<T, statusyzlecenFindFirstArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statusyzlecen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzlecenFindFirstOrThrowArgs} args - Arguments to find a Statusyzlecen
     * @example
     * // Get one Statusyzlecen
     * const statusyzlecen = await prisma.statusyzlecen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusyzlecenFindFirstOrThrowArgs>(args?: SelectSubset<T, statusyzlecenFindFirstOrThrowArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statusyzlecens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzlecenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statusyzlecens
     * const statusyzlecens = await prisma.statusyzlecen.findMany()
     * 
     * // Get first 10 Statusyzlecens
     * const statusyzlecens = await prisma.statusyzlecen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusyzlecenWithIdOnly = await prisma.statusyzlecen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statusyzlecenFindManyArgs>(args?: SelectSubset<T, statusyzlecenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Statusyzlecen.
     * @param {statusyzlecenCreateArgs} args - Arguments to create a Statusyzlecen.
     * @example
     * // Create one Statusyzlecen
     * const Statusyzlecen = await prisma.statusyzlecen.create({
     *   data: {
     *     // ... data to create a Statusyzlecen
     *   }
     * })
     * 
     */
    create<T extends statusyzlecenCreateArgs>(args: SelectSubset<T, statusyzlecenCreateArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statusyzlecens.
     * @param {statusyzlecenCreateManyArgs} args - Arguments to create many Statusyzlecens.
     * @example
     * // Create many Statusyzlecens
     * const statusyzlecen = await prisma.statusyzlecen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statusyzlecenCreateManyArgs>(args?: SelectSubset<T, statusyzlecenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Statusyzlecens and returns the data saved in the database.
     * @param {statusyzlecenCreateManyAndReturnArgs} args - Arguments to create many Statusyzlecens.
     * @example
     * // Create many Statusyzlecens
     * const statusyzlecen = await prisma.statusyzlecen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Statusyzlecens and only return the `id`
     * const statusyzlecenWithIdOnly = await prisma.statusyzlecen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends statusyzlecenCreateManyAndReturnArgs>(args?: SelectSubset<T, statusyzlecenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Statusyzlecen.
     * @param {statusyzlecenDeleteArgs} args - Arguments to delete one Statusyzlecen.
     * @example
     * // Delete one Statusyzlecen
     * const Statusyzlecen = await prisma.statusyzlecen.delete({
     *   where: {
     *     // ... filter to delete one Statusyzlecen
     *   }
     * })
     * 
     */
    delete<T extends statusyzlecenDeleteArgs>(args: SelectSubset<T, statusyzlecenDeleteArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Statusyzlecen.
     * @param {statusyzlecenUpdateArgs} args - Arguments to update one Statusyzlecen.
     * @example
     * // Update one Statusyzlecen
     * const statusyzlecen = await prisma.statusyzlecen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statusyzlecenUpdateArgs>(args: SelectSubset<T, statusyzlecenUpdateArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statusyzlecens.
     * @param {statusyzlecenDeleteManyArgs} args - Arguments to filter Statusyzlecens to delete.
     * @example
     * // Delete a few Statusyzlecens
     * const { count } = await prisma.statusyzlecen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statusyzlecenDeleteManyArgs>(args?: SelectSubset<T, statusyzlecenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statusyzlecens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzlecenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statusyzlecens
     * const statusyzlecen = await prisma.statusyzlecen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statusyzlecenUpdateManyArgs>(args: SelectSubset<T, statusyzlecenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statusyzlecens and returns the data updated in the database.
     * @param {statusyzlecenUpdateManyAndReturnArgs} args - Arguments to update many Statusyzlecens.
     * @example
     * // Update many Statusyzlecens
     * const statusyzlecen = await prisma.statusyzlecen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Statusyzlecens and only return the `id`
     * const statusyzlecenWithIdOnly = await prisma.statusyzlecen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends statusyzlecenUpdateManyAndReturnArgs>(args: SelectSubset<T, statusyzlecenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Statusyzlecen.
     * @param {statusyzlecenUpsertArgs} args - Arguments to update or create a Statusyzlecen.
     * @example
     * // Update or create a Statusyzlecen
     * const statusyzlecen = await prisma.statusyzlecen.upsert({
     *   create: {
     *     // ... data to create a Statusyzlecen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statusyzlecen we want to update
     *   }
     * })
     */
    upsert<T extends statusyzlecenUpsertArgs>(args: SelectSubset<T, statusyzlecenUpsertArgs<ExtArgs>>): Prisma__statusyzlecenClient<$Result.GetResult<Prisma.$statusyzlecenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statusyzlecens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzlecenCountArgs} args - Arguments to filter Statusyzlecens to count.
     * @example
     * // Count the number of Statusyzlecens
     * const count = await prisma.statusyzlecen.count({
     *   where: {
     *     // ... the filter for the Statusyzlecens we want to count
     *   }
     * })
    **/
    count<T extends statusyzlecenCountArgs>(
      args?: Subset<T, statusyzlecenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusyzlecenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statusyzlecen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusyzlecenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusyzlecenAggregateArgs>(args: Subset<T, StatusyzlecenAggregateArgs>): Prisma.PrismaPromise<GetStatusyzlecenAggregateType<T>>

    /**
     * Group by Statusyzlecen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyzlecenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statusyzlecenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusyzlecenGroupByArgs['orderBy'] }
        : { orderBy?: statusyzlecenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statusyzlecenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusyzlecenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statusyzlecen model
   */
  readonly fields: statusyzlecenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statusyzlecen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusyzlecenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zlecenia<T extends statusyzlecen$zleceniaArgs<ExtArgs> = {}>(args?: Subset<T, statusyzlecen$zleceniaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statusyzlecen model
   */
  interface statusyzlecenFieldRefs {
    readonly id: FieldRef<"statusyzlecen", 'Int'>
    readonly nazwa: FieldRef<"statusyzlecen", 'String'>
  }
    

  // Custom InputTypes
  /**
   * statusyzlecen findUnique
   */
  export type statusyzlecenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which statusyzlecen to fetch.
     */
    where: statusyzlecenWhereUniqueInput
  }

  /**
   * statusyzlecen findUniqueOrThrow
   */
  export type statusyzlecenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which statusyzlecen to fetch.
     */
    where: statusyzlecenWhereUniqueInput
  }

  /**
   * statusyzlecen findFirst
   */
  export type statusyzlecenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which statusyzlecen to fetch.
     */
    where?: statusyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzlecens to fetch.
     */
    orderBy?: statusyzlecenOrderByWithRelationInput | statusyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusyzlecens.
     */
    cursor?: statusyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzlecens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusyzlecens.
     */
    distinct?: StatusyzlecenScalarFieldEnum | StatusyzlecenScalarFieldEnum[]
  }

  /**
   * statusyzlecen findFirstOrThrow
   */
  export type statusyzlecenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which statusyzlecen to fetch.
     */
    where?: statusyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzlecens to fetch.
     */
    orderBy?: statusyzlecenOrderByWithRelationInput | statusyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusyzlecens.
     */
    cursor?: statusyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzlecens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusyzlecens.
     */
    distinct?: StatusyzlecenScalarFieldEnum | StatusyzlecenScalarFieldEnum[]
  }

  /**
   * statusyzlecen findMany
   */
  export type statusyzlecenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which statusyzlecens to fetch.
     */
    where?: statusyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyzlecens to fetch.
     */
    orderBy?: statusyzlecenOrderByWithRelationInput | statusyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statusyzlecens.
     */
    cursor?: statusyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyzlecens.
     */
    skip?: number
    distinct?: StatusyzlecenScalarFieldEnum | StatusyzlecenScalarFieldEnum[]
  }

  /**
   * statusyzlecen create
   */
  export type statusyzlecenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * The data needed to create a statusyzlecen.
     */
    data: XOR<statusyzlecenCreateInput, statusyzlecenUncheckedCreateInput>
  }

  /**
   * statusyzlecen createMany
   */
  export type statusyzlecenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statusyzlecens.
     */
    data: statusyzlecenCreateManyInput | statusyzlecenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statusyzlecen createManyAndReturn
   */
  export type statusyzlecenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * The data used to create many statusyzlecens.
     */
    data: statusyzlecenCreateManyInput | statusyzlecenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statusyzlecen update
   */
  export type statusyzlecenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * The data needed to update a statusyzlecen.
     */
    data: XOR<statusyzlecenUpdateInput, statusyzlecenUncheckedUpdateInput>
    /**
     * Choose, which statusyzlecen to update.
     */
    where: statusyzlecenWhereUniqueInput
  }

  /**
   * statusyzlecen updateMany
   */
  export type statusyzlecenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statusyzlecens.
     */
    data: XOR<statusyzlecenUpdateManyMutationInput, statusyzlecenUncheckedUpdateManyInput>
    /**
     * Filter which statusyzlecens to update
     */
    where?: statusyzlecenWhereInput
    /**
     * Limit how many statusyzlecens to update.
     */
    limit?: number
  }

  /**
   * statusyzlecen updateManyAndReturn
   */
  export type statusyzlecenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * The data used to update statusyzlecens.
     */
    data: XOR<statusyzlecenUpdateManyMutationInput, statusyzlecenUncheckedUpdateManyInput>
    /**
     * Filter which statusyzlecens to update
     */
    where?: statusyzlecenWhereInput
    /**
     * Limit how many statusyzlecens to update.
     */
    limit?: number
  }

  /**
   * statusyzlecen upsert
   */
  export type statusyzlecenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * The filter to search for the statusyzlecen to update in case it exists.
     */
    where: statusyzlecenWhereUniqueInput
    /**
     * In case the statusyzlecen found by the `where` argument doesn't exist, create a new statusyzlecen with this data.
     */
    create: XOR<statusyzlecenCreateInput, statusyzlecenUncheckedCreateInput>
    /**
     * In case the statusyzlecen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusyzlecenUpdateInput, statusyzlecenUncheckedUpdateInput>
  }

  /**
   * statusyzlecen delete
   */
  export type statusyzlecenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
    /**
     * Filter which statusyzlecen to delete.
     */
    where: statusyzlecenWhereUniqueInput
  }

  /**
   * statusyzlecen deleteMany
   */
  export type statusyzlecenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statusyzlecens to delete
     */
    where?: statusyzlecenWhereInput
    /**
     * Limit how many statusyzlecens to delete.
     */
    limit?: number
  }

  /**
   * statusyzlecen.zlecenia
   */
  export type statusyzlecen$zleceniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    where?: zleceniaWhereInput
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    cursor?: zleceniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * statusyzlecen without action
   */
  export type statusyzlecenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyzlecen
     */
    select?: statusyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyzlecen
     */
    omit?: statusyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyzlecenInclude<ExtArgs> | null
  }


  /**
   * Model typyzlecen
   */

  export type AggregateTypyzlecen = {
    _count: TypyzlecenCountAggregateOutputType | null
    _avg: TypyzlecenAvgAggregateOutputType | null
    _sum: TypyzlecenSumAggregateOutputType | null
    _min: TypyzlecenMinAggregateOutputType | null
    _max: TypyzlecenMaxAggregateOutputType | null
  }

  export type TypyzlecenAvgAggregateOutputType = {
    id: number | null
  }

  export type TypyzlecenSumAggregateOutputType = {
    id: number | null
  }

  export type TypyzlecenMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type TypyzlecenMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type TypyzlecenCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type TypyzlecenAvgAggregateInputType = {
    id?: true
  }

  export type TypyzlecenSumAggregateInputType = {
    id?: true
  }

  export type TypyzlecenMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type TypyzlecenMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type TypyzlecenCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type TypyzlecenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which typyzlecen to aggregate.
     */
    where?: typyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typyzlecens to fetch.
     */
    orderBy?: typyzlecenOrderByWithRelationInput | typyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: typyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typyzlecens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned typyzlecens
    **/
    _count?: true | TypyzlecenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypyzlecenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypyzlecenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypyzlecenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypyzlecenMaxAggregateInputType
  }

  export type GetTypyzlecenAggregateType<T extends TypyzlecenAggregateArgs> = {
        [P in keyof T & keyof AggregateTypyzlecen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypyzlecen[P]>
      : GetScalarType<T[P], AggregateTypyzlecen[P]>
  }




  export type typyzlecenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: typyzlecenWhereInput
    orderBy?: typyzlecenOrderByWithAggregationInput | typyzlecenOrderByWithAggregationInput[]
    by: TypyzlecenScalarFieldEnum[] | TypyzlecenScalarFieldEnum
    having?: typyzlecenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypyzlecenCountAggregateInputType | true
    _avg?: TypyzlecenAvgAggregateInputType
    _sum?: TypyzlecenSumAggregateInputType
    _min?: TypyzlecenMinAggregateInputType
    _max?: TypyzlecenMaxAggregateInputType
  }

  export type TypyzlecenGroupByOutputType = {
    id: number
    nazwa: string
    _count: TypyzlecenCountAggregateOutputType | null
    _avg: TypyzlecenAvgAggregateOutputType | null
    _sum: TypyzlecenSumAggregateOutputType | null
    _min: TypyzlecenMinAggregateOutputType | null
    _max: TypyzlecenMaxAggregateOutputType | null
  }

  type GetTypyzlecenGroupByPayload<T extends typyzlecenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypyzlecenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypyzlecenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypyzlecenGroupByOutputType[P]>
            : GetScalarType<T[P], TypyzlecenGroupByOutputType[P]>
        }
      >
    >


  export type typyzlecenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    zlecenia?: boolean | typyzlecen$zleceniaArgs<ExtArgs>
    _count?: boolean | TypyzlecenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typyzlecen"]>

  export type typyzlecenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["typyzlecen"]>

  export type typyzlecenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["typyzlecen"]>

  export type typyzlecenSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type typyzlecenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["typyzlecen"]>
  export type typyzlecenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zlecenia?: boolean | typyzlecen$zleceniaArgs<ExtArgs>
    _count?: boolean | TypyzlecenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type typyzlecenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type typyzlecenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $typyzlecenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "typyzlecen"
    objects: {
      zlecenia: Prisma.$zleceniaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["typyzlecen"]>
    composites: {}
  }

  type typyzlecenGetPayload<S extends boolean | null | undefined | typyzlecenDefaultArgs> = $Result.GetResult<Prisma.$typyzlecenPayload, S>

  type typyzlecenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<typyzlecenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypyzlecenCountAggregateInputType | true
    }

  export interface typyzlecenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['typyzlecen'], meta: { name: 'typyzlecen' } }
    /**
     * Find zero or one Typyzlecen that matches the filter.
     * @param {typyzlecenFindUniqueArgs} args - Arguments to find a Typyzlecen
     * @example
     * // Get one Typyzlecen
     * const typyzlecen = await prisma.typyzlecen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends typyzlecenFindUniqueArgs>(args: SelectSubset<T, typyzlecenFindUniqueArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Typyzlecen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {typyzlecenFindUniqueOrThrowArgs} args - Arguments to find a Typyzlecen
     * @example
     * // Get one Typyzlecen
     * const typyzlecen = await prisma.typyzlecen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends typyzlecenFindUniqueOrThrowArgs>(args: SelectSubset<T, typyzlecenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Typyzlecen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typyzlecenFindFirstArgs} args - Arguments to find a Typyzlecen
     * @example
     * // Get one Typyzlecen
     * const typyzlecen = await prisma.typyzlecen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends typyzlecenFindFirstArgs>(args?: SelectSubset<T, typyzlecenFindFirstArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Typyzlecen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typyzlecenFindFirstOrThrowArgs} args - Arguments to find a Typyzlecen
     * @example
     * // Get one Typyzlecen
     * const typyzlecen = await prisma.typyzlecen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends typyzlecenFindFirstOrThrowArgs>(args?: SelectSubset<T, typyzlecenFindFirstOrThrowArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Typyzlecens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typyzlecenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Typyzlecens
     * const typyzlecens = await prisma.typyzlecen.findMany()
     * 
     * // Get first 10 Typyzlecens
     * const typyzlecens = await prisma.typyzlecen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typyzlecenWithIdOnly = await prisma.typyzlecen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends typyzlecenFindManyArgs>(args?: SelectSubset<T, typyzlecenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Typyzlecen.
     * @param {typyzlecenCreateArgs} args - Arguments to create a Typyzlecen.
     * @example
     * // Create one Typyzlecen
     * const Typyzlecen = await prisma.typyzlecen.create({
     *   data: {
     *     // ... data to create a Typyzlecen
     *   }
     * })
     * 
     */
    create<T extends typyzlecenCreateArgs>(args: SelectSubset<T, typyzlecenCreateArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Typyzlecens.
     * @param {typyzlecenCreateManyArgs} args - Arguments to create many Typyzlecens.
     * @example
     * // Create many Typyzlecens
     * const typyzlecen = await prisma.typyzlecen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends typyzlecenCreateManyArgs>(args?: SelectSubset<T, typyzlecenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Typyzlecens and returns the data saved in the database.
     * @param {typyzlecenCreateManyAndReturnArgs} args - Arguments to create many Typyzlecens.
     * @example
     * // Create many Typyzlecens
     * const typyzlecen = await prisma.typyzlecen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Typyzlecens and only return the `id`
     * const typyzlecenWithIdOnly = await prisma.typyzlecen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends typyzlecenCreateManyAndReturnArgs>(args?: SelectSubset<T, typyzlecenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Typyzlecen.
     * @param {typyzlecenDeleteArgs} args - Arguments to delete one Typyzlecen.
     * @example
     * // Delete one Typyzlecen
     * const Typyzlecen = await prisma.typyzlecen.delete({
     *   where: {
     *     // ... filter to delete one Typyzlecen
     *   }
     * })
     * 
     */
    delete<T extends typyzlecenDeleteArgs>(args: SelectSubset<T, typyzlecenDeleteArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Typyzlecen.
     * @param {typyzlecenUpdateArgs} args - Arguments to update one Typyzlecen.
     * @example
     * // Update one Typyzlecen
     * const typyzlecen = await prisma.typyzlecen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends typyzlecenUpdateArgs>(args: SelectSubset<T, typyzlecenUpdateArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Typyzlecens.
     * @param {typyzlecenDeleteManyArgs} args - Arguments to filter Typyzlecens to delete.
     * @example
     * // Delete a few Typyzlecens
     * const { count } = await prisma.typyzlecen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends typyzlecenDeleteManyArgs>(args?: SelectSubset<T, typyzlecenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Typyzlecens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typyzlecenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Typyzlecens
     * const typyzlecen = await prisma.typyzlecen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends typyzlecenUpdateManyArgs>(args: SelectSubset<T, typyzlecenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Typyzlecens and returns the data updated in the database.
     * @param {typyzlecenUpdateManyAndReturnArgs} args - Arguments to update many Typyzlecens.
     * @example
     * // Update many Typyzlecens
     * const typyzlecen = await prisma.typyzlecen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Typyzlecens and only return the `id`
     * const typyzlecenWithIdOnly = await prisma.typyzlecen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends typyzlecenUpdateManyAndReturnArgs>(args: SelectSubset<T, typyzlecenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Typyzlecen.
     * @param {typyzlecenUpsertArgs} args - Arguments to update or create a Typyzlecen.
     * @example
     * // Update or create a Typyzlecen
     * const typyzlecen = await prisma.typyzlecen.upsert({
     *   create: {
     *     // ... data to create a Typyzlecen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Typyzlecen we want to update
     *   }
     * })
     */
    upsert<T extends typyzlecenUpsertArgs>(args: SelectSubset<T, typyzlecenUpsertArgs<ExtArgs>>): Prisma__typyzlecenClient<$Result.GetResult<Prisma.$typyzlecenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Typyzlecens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typyzlecenCountArgs} args - Arguments to filter Typyzlecens to count.
     * @example
     * // Count the number of Typyzlecens
     * const count = await prisma.typyzlecen.count({
     *   where: {
     *     // ... the filter for the Typyzlecens we want to count
     *   }
     * })
    **/
    count<T extends typyzlecenCountArgs>(
      args?: Subset<T, typyzlecenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypyzlecenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Typyzlecen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypyzlecenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypyzlecenAggregateArgs>(args: Subset<T, TypyzlecenAggregateArgs>): Prisma.PrismaPromise<GetTypyzlecenAggregateType<T>>

    /**
     * Group by Typyzlecen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typyzlecenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends typyzlecenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: typyzlecenGroupByArgs['orderBy'] }
        : { orderBy?: typyzlecenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, typyzlecenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypyzlecenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the typyzlecen model
   */
  readonly fields: typyzlecenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for typyzlecen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__typyzlecenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zlecenia<T extends typyzlecen$zleceniaArgs<ExtArgs> = {}>(args?: Subset<T, typyzlecen$zleceniaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zleceniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the typyzlecen model
   */
  interface typyzlecenFieldRefs {
    readonly id: FieldRef<"typyzlecen", 'Int'>
    readonly nazwa: FieldRef<"typyzlecen", 'String'>
  }
    

  // Custom InputTypes
  /**
   * typyzlecen findUnique
   */
  export type typyzlecenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which typyzlecen to fetch.
     */
    where: typyzlecenWhereUniqueInput
  }

  /**
   * typyzlecen findUniqueOrThrow
   */
  export type typyzlecenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which typyzlecen to fetch.
     */
    where: typyzlecenWhereUniqueInput
  }

  /**
   * typyzlecen findFirst
   */
  export type typyzlecenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which typyzlecen to fetch.
     */
    where?: typyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typyzlecens to fetch.
     */
    orderBy?: typyzlecenOrderByWithRelationInput | typyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for typyzlecens.
     */
    cursor?: typyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typyzlecens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of typyzlecens.
     */
    distinct?: TypyzlecenScalarFieldEnum | TypyzlecenScalarFieldEnum[]
  }

  /**
   * typyzlecen findFirstOrThrow
   */
  export type typyzlecenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which typyzlecen to fetch.
     */
    where?: typyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typyzlecens to fetch.
     */
    orderBy?: typyzlecenOrderByWithRelationInput | typyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for typyzlecens.
     */
    cursor?: typyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typyzlecens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of typyzlecens.
     */
    distinct?: TypyzlecenScalarFieldEnum | TypyzlecenScalarFieldEnum[]
  }

  /**
   * typyzlecen findMany
   */
  export type typyzlecenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * Filter, which typyzlecens to fetch.
     */
    where?: typyzlecenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typyzlecens to fetch.
     */
    orderBy?: typyzlecenOrderByWithRelationInput | typyzlecenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing typyzlecens.
     */
    cursor?: typyzlecenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typyzlecens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typyzlecens.
     */
    skip?: number
    distinct?: TypyzlecenScalarFieldEnum | TypyzlecenScalarFieldEnum[]
  }

  /**
   * typyzlecen create
   */
  export type typyzlecenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * The data needed to create a typyzlecen.
     */
    data: XOR<typyzlecenCreateInput, typyzlecenUncheckedCreateInput>
  }

  /**
   * typyzlecen createMany
   */
  export type typyzlecenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many typyzlecens.
     */
    data: typyzlecenCreateManyInput | typyzlecenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * typyzlecen createManyAndReturn
   */
  export type typyzlecenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * The data used to create many typyzlecens.
     */
    data: typyzlecenCreateManyInput | typyzlecenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * typyzlecen update
   */
  export type typyzlecenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * The data needed to update a typyzlecen.
     */
    data: XOR<typyzlecenUpdateInput, typyzlecenUncheckedUpdateInput>
    /**
     * Choose, which typyzlecen to update.
     */
    where: typyzlecenWhereUniqueInput
  }

  /**
   * typyzlecen updateMany
   */
  export type typyzlecenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update typyzlecens.
     */
    data: XOR<typyzlecenUpdateManyMutationInput, typyzlecenUncheckedUpdateManyInput>
    /**
     * Filter which typyzlecens to update
     */
    where?: typyzlecenWhereInput
    /**
     * Limit how many typyzlecens to update.
     */
    limit?: number
  }

  /**
   * typyzlecen updateManyAndReturn
   */
  export type typyzlecenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * The data used to update typyzlecens.
     */
    data: XOR<typyzlecenUpdateManyMutationInput, typyzlecenUncheckedUpdateManyInput>
    /**
     * Filter which typyzlecens to update
     */
    where?: typyzlecenWhereInput
    /**
     * Limit how many typyzlecens to update.
     */
    limit?: number
  }

  /**
   * typyzlecen upsert
   */
  export type typyzlecenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * The filter to search for the typyzlecen to update in case it exists.
     */
    where: typyzlecenWhereUniqueInput
    /**
     * In case the typyzlecen found by the `where` argument doesn't exist, create a new typyzlecen with this data.
     */
    create: XOR<typyzlecenCreateInput, typyzlecenUncheckedCreateInput>
    /**
     * In case the typyzlecen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<typyzlecenUpdateInput, typyzlecenUncheckedUpdateInput>
  }

  /**
   * typyzlecen delete
   */
  export type typyzlecenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
    /**
     * Filter which typyzlecen to delete.
     */
    where: typyzlecenWhereUniqueInput
  }

  /**
   * typyzlecen deleteMany
   */
  export type typyzlecenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which typyzlecens to delete
     */
    where?: typyzlecenWhereInput
    /**
     * Limit how many typyzlecens to delete.
     */
    limit?: number
  }

  /**
   * typyzlecen.zlecenia
   */
  export type typyzlecen$zleceniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zlecenia
     */
    select?: zleceniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zlecenia
     */
    omit?: zleceniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zleceniaInclude<ExtArgs> | null
    where?: zleceniaWhereInput
    orderBy?: zleceniaOrderByWithRelationInput | zleceniaOrderByWithRelationInput[]
    cursor?: zleceniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZleceniaScalarFieldEnum | ZleceniaScalarFieldEnum[]
  }

  /**
   * typyzlecen without action
   */
  export type typyzlecenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the typyzlecen
     */
    select?: typyzlecenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the typyzlecen
     */
    omit?: typyzlecenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: typyzlecenInclude<ExtArgs> | null
  }


  /**
   * Model projekty
   */

  export type AggregateProjekty = {
    _count: ProjektyCountAggregateOutputType | null
    _avg: ProjektyAvgAggregateOutputType | null
    _sum: ProjektySumAggregateOutputType | null
    _min: ProjektyMinAggregateOutputType | null
    _max: ProjektyMaxAggregateOutputType | null
  }

  export type ProjektyAvgAggregateOutputType = {
    id: number | null
    autor_id: number | null
    status_id: number | null
  }

  export type ProjektySumAggregateOutputType = {
    id: number | null
    autor_id: number | null
    status_id: number | null
  }

  export type ProjektyMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
    opis: string | null
    autor_id: number | null
    data_utworzenia: Date | null
    status_id: number | null
  }

  export type ProjektyMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
    opis: string | null
    autor_id: number | null
    data_utworzenia: Date | null
    status_id: number | null
  }

  export type ProjektyCountAggregateOutputType = {
    id: number
    nazwa: number
    opis: number
    autor_id: number
    data_utworzenia: number
    status_id: number
    _all: number
  }


  export type ProjektyAvgAggregateInputType = {
    id?: true
    autor_id?: true
    status_id?: true
  }

  export type ProjektySumAggregateInputType = {
    id?: true
    autor_id?: true
    status_id?: true
  }

  export type ProjektyMinAggregateInputType = {
    id?: true
    nazwa?: true
    opis?: true
    autor_id?: true
    data_utworzenia?: true
    status_id?: true
  }

  export type ProjektyMaxAggregateInputType = {
    id?: true
    nazwa?: true
    opis?: true
    autor_id?: true
    data_utworzenia?: true
    status_id?: true
  }

  export type ProjektyCountAggregateInputType = {
    id?: true
    nazwa?: true
    opis?: true
    autor_id?: true
    data_utworzenia?: true
    status_id?: true
    _all?: true
  }

  export type ProjektyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projekty to aggregate.
     */
    where?: projektyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projekties to fetch.
     */
    orderBy?: projektyOrderByWithRelationInput | projektyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projektyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projekties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projekties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projekties
    **/
    _count?: true | ProjektyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjektyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjektySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjektyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjektyMaxAggregateInputType
  }

  export type GetProjektyAggregateType<T extends ProjektyAggregateArgs> = {
        [P in keyof T & keyof AggregateProjekty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjekty[P]>
      : GetScalarType<T[P], AggregateProjekty[P]>
  }




  export type projektyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projektyWhereInput
    orderBy?: projektyOrderByWithAggregationInput | projektyOrderByWithAggregationInput[]
    by: ProjektyScalarFieldEnum[] | ProjektyScalarFieldEnum
    having?: projektyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjektyCountAggregateInputType | true
    _avg?: ProjektyAvgAggregateInputType
    _sum?: ProjektySumAggregateInputType
    _min?: ProjektyMinAggregateInputType
    _max?: ProjektyMaxAggregateInputType
  }

  export type ProjektyGroupByOutputType = {
    id: number
    nazwa: string | null
    opis: string | null
    autor_id: number
    data_utworzenia: Date | null
    status_id: number
    _count: ProjektyCountAggregateOutputType | null
    _avg: ProjektyAvgAggregateOutputType | null
    _sum: ProjektySumAggregateOutputType | null
    _min: ProjektyMinAggregateOutputType | null
    _max: ProjektyMaxAggregateOutputType | null
  }

  type GetProjektyGroupByPayload<T extends projektyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjektyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjektyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjektyGroupByOutputType[P]>
            : GetScalarType<T[P], ProjektyGroupByOutputType[P]>
        }
      >
    >


  export type projektySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    autor_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyprojektowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projekty"]>

  export type projektySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    autor_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyprojektowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projekty"]>

  export type projektySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    autor_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyprojektowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projekty"]>

  export type projektySelectScalar = {
    id?: boolean
    nazwa?: boolean
    opis?: boolean
    autor_id?: boolean
    data_utworzenia?: boolean
    status_id?: boolean
  }

  export type projektyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa" | "opis" | "autor_id" | "data_utworzenia" | "status_id", ExtArgs["result"]["projekty"]>
  export type projektyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyprojektowDefaultArgs<ExtArgs>
  }
  export type projektyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyprojektowDefaultArgs<ExtArgs>
  }
  export type projektyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    status?: boolean | statusyprojektowDefaultArgs<ExtArgs>
  }

  export type $projektyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projekty"
    objects: {
      autor: Prisma.$uzytkownicyPayload<ExtArgs>
      status: Prisma.$statusyprojektowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string | null
      opis: string | null
      autor_id: number
      data_utworzenia: Date | null
      status_id: number
    }, ExtArgs["result"]["projekty"]>
    composites: {}
  }

  type projektyGetPayload<S extends boolean | null | undefined | projektyDefaultArgs> = $Result.GetResult<Prisma.$projektyPayload, S>

  type projektyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projektyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjektyCountAggregateInputType | true
    }

  export interface projektyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projekty'], meta: { name: 'projekty' } }
    /**
     * Find zero or one Projekty that matches the filter.
     * @param {projektyFindUniqueArgs} args - Arguments to find a Projekty
     * @example
     * // Get one Projekty
     * const projekty = await prisma.projekty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projektyFindUniqueArgs>(args: SelectSubset<T, projektyFindUniqueArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projekty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projektyFindUniqueOrThrowArgs} args - Arguments to find a Projekty
     * @example
     * // Get one Projekty
     * const projekty = await prisma.projekty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projektyFindUniqueOrThrowArgs>(args: SelectSubset<T, projektyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projekty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projektyFindFirstArgs} args - Arguments to find a Projekty
     * @example
     * // Get one Projekty
     * const projekty = await prisma.projekty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projektyFindFirstArgs>(args?: SelectSubset<T, projektyFindFirstArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projekty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projektyFindFirstOrThrowArgs} args - Arguments to find a Projekty
     * @example
     * // Get one Projekty
     * const projekty = await prisma.projekty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projektyFindFirstOrThrowArgs>(args?: SelectSubset<T, projektyFindFirstOrThrowArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projekties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projektyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projekties
     * const projekties = await prisma.projekty.findMany()
     * 
     * // Get first 10 Projekties
     * const projekties = await prisma.projekty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projektyWithIdOnly = await prisma.projekty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projektyFindManyArgs>(args?: SelectSubset<T, projektyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projekty.
     * @param {projektyCreateArgs} args - Arguments to create a Projekty.
     * @example
     * // Create one Projekty
     * const Projekty = await prisma.projekty.create({
     *   data: {
     *     // ... data to create a Projekty
     *   }
     * })
     * 
     */
    create<T extends projektyCreateArgs>(args: SelectSubset<T, projektyCreateArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projekties.
     * @param {projektyCreateManyArgs} args - Arguments to create many Projekties.
     * @example
     * // Create many Projekties
     * const projekty = await prisma.projekty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projektyCreateManyArgs>(args?: SelectSubset<T, projektyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projekties and returns the data saved in the database.
     * @param {projektyCreateManyAndReturnArgs} args - Arguments to create many Projekties.
     * @example
     * // Create many Projekties
     * const projekty = await prisma.projekty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projekties and only return the `id`
     * const projektyWithIdOnly = await prisma.projekty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projektyCreateManyAndReturnArgs>(args?: SelectSubset<T, projektyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Projekty.
     * @param {projektyDeleteArgs} args - Arguments to delete one Projekty.
     * @example
     * // Delete one Projekty
     * const Projekty = await prisma.projekty.delete({
     *   where: {
     *     // ... filter to delete one Projekty
     *   }
     * })
     * 
     */
    delete<T extends projektyDeleteArgs>(args: SelectSubset<T, projektyDeleteArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projekty.
     * @param {projektyUpdateArgs} args - Arguments to update one Projekty.
     * @example
     * // Update one Projekty
     * const projekty = await prisma.projekty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projektyUpdateArgs>(args: SelectSubset<T, projektyUpdateArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projekties.
     * @param {projektyDeleteManyArgs} args - Arguments to filter Projekties to delete.
     * @example
     * // Delete a few Projekties
     * const { count } = await prisma.projekty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projektyDeleteManyArgs>(args?: SelectSubset<T, projektyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projekties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projektyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projekties
     * const projekty = await prisma.projekty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projektyUpdateManyArgs>(args: SelectSubset<T, projektyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projekties and returns the data updated in the database.
     * @param {projektyUpdateManyAndReturnArgs} args - Arguments to update many Projekties.
     * @example
     * // Update many Projekties
     * const projekty = await prisma.projekty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projekties and only return the `id`
     * const projektyWithIdOnly = await prisma.projekty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projektyUpdateManyAndReturnArgs>(args: SelectSubset<T, projektyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Projekty.
     * @param {projektyUpsertArgs} args - Arguments to update or create a Projekty.
     * @example
     * // Update or create a Projekty
     * const projekty = await prisma.projekty.upsert({
     *   create: {
     *     // ... data to create a Projekty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projekty we want to update
     *   }
     * })
     */
    upsert<T extends projektyUpsertArgs>(args: SelectSubset<T, projektyUpsertArgs<ExtArgs>>): Prisma__projektyClient<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projekties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projektyCountArgs} args - Arguments to filter Projekties to count.
     * @example
     * // Count the number of Projekties
     * const count = await prisma.projekty.count({
     *   where: {
     *     // ... the filter for the Projekties we want to count
     *   }
     * })
    **/
    count<T extends projektyCountArgs>(
      args?: Subset<T, projektyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjektyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projekty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjektyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjektyAggregateArgs>(args: Subset<T, ProjektyAggregateArgs>): Prisma.PrismaPromise<GetProjektyAggregateType<T>>

    /**
     * Group by Projekty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projektyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projektyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projektyGroupByArgs['orderBy'] }
        : { orderBy?: projektyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projektyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjektyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projekty model
   */
  readonly fields: projektyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projekty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projektyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autor<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends statusyprojektowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statusyprojektowDefaultArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projekty model
   */
  interface projektyFieldRefs {
    readonly id: FieldRef<"projekty", 'Int'>
    readonly nazwa: FieldRef<"projekty", 'String'>
    readonly opis: FieldRef<"projekty", 'String'>
    readonly autor_id: FieldRef<"projekty", 'Int'>
    readonly data_utworzenia: FieldRef<"projekty", 'DateTime'>
    readonly status_id: FieldRef<"projekty", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * projekty findUnique
   */
  export type projektyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * Filter, which projekty to fetch.
     */
    where: projektyWhereUniqueInput
  }

  /**
   * projekty findUniqueOrThrow
   */
  export type projektyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * Filter, which projekty to fetch.
     */
    where: projektyWhereUniqueInput
  }

  /**
   * projekty findFirst
   */
  export type projektyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * Filter, which projekty to fetch.
     */
    where?: projektyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projekties to fetch.
     */
    orderBy?: projektyOrderByWithRelationInput | projektyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projekties.
     */
    cursor?: projektyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projekties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projekties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projekties.
     */
    distinct?: ProjektyScalarFieldEnum | ProjektyScalarFieldEnum[]
  }

  /**
   * projekty findFirstOrThrow
   */
  export type projektyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * Filter, which projekty to fetch.
     */
    where?: projektyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projekties to fetch.
     */
    orderBy?: projektyOrderByWithRelationInput | projektyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projekties.
     */
    cursor?: projektyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projekties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projekties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projekties.
     */
    distinct?: ProjektyScalarFieldEnum | ProjektyScalarFieldEnum[]
  }

  /**
   * projekty findMany
   */
  export type projektyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * Filter, which projekties to fetch.
     */
    where?: projektyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projekties to fetch.
     */
    orderBy?: projektyOrderByWithRelationInput | projektyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projekties.
     */
    cursor?: projektyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projekties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projekties.
     */
    skip?: number
    distinct?: ProjektyScalarFieldEnum | ProjektyScalarFieldEnum[]
  }

  /**
   * projekty create
   */
  export type projektyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * The data needed to create a projekty.
     */
    data: XOR<projektyCreateInput, projektyUncheckedCreateInput>
  }

  /**
   * projekty createMany
   */
  export type projektyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projekties.
     */
    data: projektyCreateManyInput | projektyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projekty createManyAndReturn
   */
  export type projektyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * The data used to create many projekties.
     */
    data: projektyCreateManyInput | projektyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projekty update
   */
  export type projektyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * The data needed to update a projekty.
     */
    data: XOR<projektyUpdateInput, projektyUncheckedUpdateInput>
    /**
     * Choose, which projekty to update.
     */
    where: projektyWhereUniqueInput
  }

  /**
   * projekty updateMany
   */
  export type projektyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projekties.
     */
    data: XOR<projektyUpdateManyMutationInput, projektyUncheckedUpdateManyInput>
    /**
     * Filter which projekties to update
     */
    where?: projektyWhereInput
    /**
     * Limit how many projekties to update.
     */
    limit?: number
  }

  /**
   * projekty updateManyAndReturn
   */
  export type projektyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * The data used to update projekties.
     */
    data: XOR<projektyUpdateManyMutationInput, projektyUncheckedUpdateManyInput>
    /**
     * Filter which projekties to update
     */
    where?: projektyWhereInput
    /**
     * Limit how many projekties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projekty upsert
   */
  export type projektyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * The filter to search for the projekty to update in case it exists.
     */
    where: projektyWhereUniqueInput
    /**
     * In case the projekty found by the `where` argument doesn't exist, create a new projekty with this data.
     */
    create: XOR<projektyCreateInput, projektyUncheckedCreateInput>
    /**
     * In case the projekty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projektyUpdateInput, projektyUncheckedUpdateInput>
  }

  /**
   * projekty delete
   */
  export type projektyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    /**
     * Filter which projekty to delete.
     */
    where: projektyWhereUniqueInput
  }

  /**
   * projekty deleteMany
   */
  export type projektyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projekties to delete
     */
    where?: projektyWhereInput
    /**
     * Limit how many projekties to delete.
     */
    limit?: number
  }

  /**
   * projekty without action
   */
  export type projektyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
  }


  /**
   * Model statusyprojektow
   */

  export type AggregateStatusyprojektow = {
    _count: StatusyprojektowCountAggregateOutputType | null
    _avg: StatusyprojektowAvgAggregateOutputType | null
    _sum: StatusyprojektowSumAggregateOutputType | null
    _min: StatusyprojektowMinAggregateOutputType | null
    _max: StatusyprojektowMaxAggregateOutputType | null
  }

  export type StatusyprojektowAvgAggregateOutputType = {
    id: number | null
  }

  export type StatusyprojektowSumAggregateOutputType = {
    id: number | null
  }

  export type StatusyprojektowMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type StatusyprojektowMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type StatusyprojektowCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type StatusyprojektowAvgAggregateInputType = {
    id?: true
  }

  export type StatusyprojektowSumAggregateInputType = {
    id?: true
  }

  export type StatusyprojektowMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type StatusyprojektowMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type StatusyprojektowCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type StatusyprojektowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statusyprojektow to aggregate.
     */
    where?: statusyprojektowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyprojektows to fetch.
     */
    orderBy?: statusyprojektowOrderByWithRelationInput | statusyprojektowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statusyprojektowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyprojektows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyprojektows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statusyprojektows
    **/
    _count?: true | StatusyprojektowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusyprojektowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusyprojektowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusyprojektowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusyprojektowMaxAggregateInputType
  }

  export type GetStatusyprojektowAggregateType<T extends StatusyprojektowAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusyprojektow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusyprojektow[P]>
      : GetScalarType<T[P], AggregateStatusyprojektow[P]>
  }




  export type statusyprojektowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statusyprojektowWhereInput
    orderBy?: statusyprojektowOrderByWithAggregationInput | statusyprojektowOrderByWithAggregationInput[]
    by: StatusyprojektowScalarFieldEnum[] | StatusyprojektowScalarFieldEnum
    having?: statusyprojektowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusyprojektowCountAggregateInputType | true
    _avg?: StatusyprojektowAvgAggregateInputType
    _sum?: StatusyprojektowSumAggregateInputType
    _min?: StatusyprojektowMinAggregateInputType
    _max?: StatusyprojektowMaxAggregateInputType
  }

  export type StatusyprojektowGroupByOutputType = {
    id: number
    nazwa: string
    _count: StatusyprojektowCountAggregateOutputType | null
    _avg: StatusyprojektowAvgAggregateOutputType | null
    _sum: StatusyprojektowSumAggregateOutputType | null
    _min: StatusyprojektowMinAggregateOutputType | null
    _max: StatusyprojektowMaxAggregateOutputType | null
  }

  type GetStatusyprojektowGroupByPayload<T extends statusyprojektowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusyprojektowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusyprojektowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusyprojektowGroupByOutputType[P]>
            : GetScalarType<T[P], StatusyprojektowGroupByOutputType[P]>
        }
      >
    >


  export type statusyprojektowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    projekty?: boolean | statusyprojektow$projektyArgs<ExtArgs>
    _count?: boolean | StatusyprojektowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusyprojektow"]>

  export type statusyprojektowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["statusyprojektow"]>

  export type statusyprojektowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["statusyprojektow"]>

  export type statusyprojektowSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type statusyprojektowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["statusyprojektow"]>
  export type statusyprojektowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projekty?: boolean | statusyprojektow$projektyArgs<ExtArgs>
    _count?: boolean | StatusyprojektowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type statusyprojektowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type statusyprojektowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $statusyprojektowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statusyprojektow"
    objects: {
      projekty: Prisma.$projektyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["statusyprojektow"]>
    composites: {}
  }

  type statusyprojektowGetPayload<S extends boolean | null | undefined | statusyprojektowDefaultArgs> = $Result.GetResult<Prisma.$statusyprojektowPayload, S>

  type statusyprojektowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statusyprojektowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusyprojektowCountAggregateInputType | true
    }

  export interface statusyprojektowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statusyprojektow'], meta: { name: 'statusyprojektow' } }
    /**
     * Find zero or one Statusyprojektow that matches the filter.
     * @param {statusyprojektowFindUniqueArgs} args - Arguments to find a Statusyprojektow
     * @example
     * // Get one Statusyprojektow
     * const statusyprojektow = await prisma.statusyprojektow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusyprojektowFindUniqueArgs>(args: SelectSubset<T, statusyprojektowFindUniqueArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Statusyprojektow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusyprojektowFindUniqueOrThrowArgs} args - Arguments to find a Statusyprojektow
     * @example
     * // Get one Statusyprojektow
     * const statusyprojektow = await prisma.statusyprojektow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusyprojektowFindUniqueOrThrowArgs>(args: SelectSubset<T, statusyprojektowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statusyprojektow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyprojektowFindFirstArgs} args - Arguments to find a Statusyprojektow
     * @example
     * // Get one Statusyprojektow
     * const statusyprojektow = await prisma.statusyprojektow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusyprojektowFindFirstArgs>(args?: SelectSubset<T, statusyprojektowFindFirstArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statusyprojektow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyprojektowFindFirstOrThrowArgs} args - Arguments to find a Statusyprojektow
     * @example
     * // Get one Statusyprojektow
     * const statusyprojektow = await prisma.statusyprojektow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusyprojektowFindFirstOrThrowArgs>(args?: SelectSubset<T, statusyprojektowFindFirstOrThrowArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statusyprojektows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyprojektowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statusyprojektows
     * const statusyprojektows = await prisma.statusyprojektow.findMany()
     * 
     * // Get first 10 Statusyprojektows
     * const statusyprojektows = await prisma.statusyprojektow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusyprojektowWithIdOnly = await prisma.statusyprojektow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statusyprojektowFindManyArgs>(args?: SelectSubset<T, statusyprojektowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Statusyprojektow.
     * @param {statusyprojektowCreateArgs} args - Arguments to create a Statusyprojektow.
     * @example
     * // Create one Statusyprojektow
     * const Statusyprojektow = await prisma.statusyprojektow.create({
     *   data: {
     *     // ... data to create a Statusyprojektow
     *   }
     * })
     * 
     */
    create<T extends statusyprojektowCreateArgs>(args: SelectSubset<T, statusyprojektowCreateArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statusyprojektows.
     * @param {statusyprojektowCreateManyArgs} args - Arguments to create many Statusyprojektows.
     * @example
     * // Create many Statusyprojektows
     * const statusyprojektow = await prisma.statusyprojektow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statusyprojektowCreateManyArgs>(args?: SelectSubset<T, statusyprojektowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Statusyprojektows and returns the data saved in the database.
     * @param {statusyprojektowCreateManyAndReturnArgs} args - Arguments to create many Statusyprojektows.
     * @example
     * // Create many Statusyprojektows
     * const statusyprojektow = await prisma.statusyprojektow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Statusyprojektows and only return the `id`
     * const statusyprojektowWithIdOnly = await prisma.statusyprojektow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends statusyprojektowCreateManyAndReturnArgs>(args?: SelectSubset<T, statusyprojektowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Statusyprojektow.
     * @param {statusyprojektowDeleteArgs} args - Arguments to delete one Statusyprojektow.
     * @example
     * // Delete one Statusyprojektow
     * const Statusyprojektow = await prisma.statusyprojektow.delete({
     *   where: {
     *     // ... filter to delete one Statusyprojektow
     *   }
     * })
     * 
     */
    delete<T extends statusyprojektowDeleteArgs>(args: SelectSubset<T, statusyprojektowDeleteArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Statusyprojektow.
     * @param {statusyprojektowUpdateArgs} args - Arguments to update one Statusyprojektow.
     * @example
     * // Update one Statusyprojektow
     * const statusyprojektow = await prisma.statusyprojektow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statusyprojektowUpdateArgs>(args: SelectSubset<T, statusyprojektowUpdateArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statusyprojektows.
     * @param {statusyprojektowDeleteManyArgs} args - Arguments to filter Statusyprojektows to delete.
     * @example
     * // Delete a few Statusyprojektows
     * const { count } = await prisma.statusyprojektow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statusyprojektowDeleteManyArgs>(args?: SelectSubset<T, statusyprojektowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statusyprojektows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyprojektowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statusyprojektows
     * const statusyprojektow = await prisma.statusyprojektow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statusyprojektowUpdateManyArgs>(args: SelectSubset<T, statusyprojektowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statusyprojektows and returns the data updated in the database.
     * @param {statusyprojektowUpdateManyAndReturnArgs} args - Arguments to update many Statusyprojektows.
     * @example
     * // Update many Statusyprojektows
     * const statusyprojektow = await prisma.statusyprojektow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Statusyprojektows and only return the `id`
     * const statusyprojektowWithIdOnly = await prisma.statusyprojektow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends statusyprojektowUpdateManyAndReturnArgs>(args: SelectSubset<T, statusyprojektowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Statusyprojektow.
     * @param {statusyprojektowUpsertArgs} args - Arguments to update or create a Statusyprojektow.
     * @example
     * // Update or create a Statusyprojektow
     * const statusyprojektow = await prisma.statusyprojektow.upsert({
     *   create: {
     *     // ... data to create a Statusyprojektow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statusyprojektow we want to update
     *   }
     * })
     */
    upsert<T extends statusyprojektowUpsertArgs>(args: SelectSubset<T, statusyprojektowUpsertArgs<ExtArgs>>): Prisma__statusyprojektowClient<$Result.GetResult<Prisma.$statusyprojektowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statusyprojektows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyprojektowCountArgs} args - Arguments to filter Statusyprojektows to count.
     * @example
     * // Count the number of Statusyprojektows
     * const count = await prisma.statusyprojektow.count({
     *   where: {
     *     // ... the filter for the Statusyprojektows we want to count
     *   }
     * })
    **/
    count<T extends statusyprojektowCountArgs>(
      args?: Subset<T, statusyprojektowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusyprojektowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statusyprojektow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusyprojektowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusyprojektowAggregateArgs>(args: Subset<T, StatusyprojektowAggregateArgs>): Prisma.PrismaPromise<GetStatusyprojektowAggregateType<T>>

    /**
     * Group by Statusyprojektow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusyprojektowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statusyprojektowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusyprojektowGroupByArgs['orderBy'] }
        : { orderBy?: statusyprojektowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statusyprojektowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusyprojektowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statusyprojektow model
   */
  readonly fields: statusyprojektowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statusyprojektow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusyprojektowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projekty<T extends statusyprojektow$projektyArgs<ExtArgs> = {}>(args?: Subset<T, statusyprojektow$projektyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projektyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statusyprojektow model
   */
  interface statusyprojektowFieldRefs {
    readonly id: FieldRef<"statusyprojektow", 'Int'>
    readonly nazwa: FieldRef<"statusyprojektow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * statusyprojektow findUnique
   */
  export type statusyprojektowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * Filter, which statusyprojektow to fetch.
     */
    where: statusyprojektowWhereUniqueInput
  }

  /**
   * statusyprojektow findUniqueOrThrow
   */
  export type statusyprojektowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * Filter, which statusyprojektow to fetch.
     */
    where: statusyprojektowWhereUniqueInput
  }

  /**
   * statusyprojektow findFirst
   */
  export type statusyprojektowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * Filter, which statusyprojektow to fetch.
     */
    where?: statusyprojektowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyprojektows to fetch.
     */
    orderBy?: statusyprojektowOrderByWithRelationInput | statusyprojektowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusyprojektows.
     */
    cursor?: statusyprojektowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyprojektows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyprojektows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusyprojektows.
     */
    distinct?: StatusyprojektowScalarFieldEnum | StatusyprojektowScalarFieldEnum[]
  }

  /**
   * statusyprojektow findFirstOrThrow
   */
  export type statusyprojektowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * Filter, which statusyprojektow to fetch.
     */
    where?: statusyprojektowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyprojektows to fetch.
     */
    orderBy?: statusyprojektowOrderByWithRelationInput | statusyprojektowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statusyprojektows.
     */
    cursor?: statusyprojektowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyprojektows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyprojektows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statusyprojektows.
     */
    distinct?: StatusyprojektowScalarFieldEnum | StatusyprojektowScalarFieldEnum[]
  }

  /**
   * statusyprojektow findMany
   */
  export type statusyprojektowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * Filter, which statusyprojektows to fetch.
     */
    where?: statusyprojektowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statusyprojektows to fetch.
     */
    orderBy?: statusyprojektowOrderByWithRelationInput | statusyprojektowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statusyprojektows.
     */
    cursor?: statusyprojektowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statusyprojektows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statusyprojektows.
     */
    skip?: number
    distinct?: StatusyprojektowScalarFieldEnum | StatusyprojektowScalarFieldEnum[]
  }

  /**
   * statusyprojektow create
   */
  export type statusyprojektowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * The data needed to create a statusyprojektow.
     */
    data: XOR<statusyprojektowCreateInput, statusyprojektowUncheckedCreateInput>
  }

  /**
   * statusyprojektow createMany
   */
  export type statusyprojektowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statusyprojektows.
     */
    data: statusyprojektowCreateManyInput | statusyprojektowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statusyprojektow createManyAndReturn
   */
  export type statusyprojektowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * The data used to create many statusyprojektows.
     */
    data: statusyprojektowCreateManyInput | statusyprojektowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statusyprojektow update
   */
  export type statusyprojektowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * The data needed to update a statusyprojektow.
     */
    data: XOR<statusyprojektowUpdateInput, statusyprojektowUncheckedUpdateInput>
    /**
     * Choose, which statusyprojektow to update.
     */
    where: statusyprojektowWhereUniqueInput
  }

  /**
   * statusyprojektow updateMany
   */
  export type statusyprojektowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statusyprojektows.
     */
    data: XOR<statusyprojektowUpdateManyMutationInput, statusyprojektowUncheckedUpdateManyInput>
    /**
     * Filter which statusyprojektows to update
     */
    where?: statusyprojektowWhereInput
    /**
     * Limit how many statusyprojektows to update.
     */
    limit?: number
  }

  /**
   * statusyprojektow updateManyAndReturn
   */
  export type statusyprojektowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * The data used to update statusyprojektows.
     */
    data: XOR<statusyprojektowUpdateManyMutationInput, statusyprojektowUncheckedUpdateManyInput>
    /**
     * Filter which statusyprojektows to update
     */
    where?: statusyprojektowWhereInput
    /**
     * Limit how many statusyprojektows to update.
     */
    limit?: number
  }

  /**
   * statusyprojektow upsert
   */
  export type statusyprojektowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * The filter to search for the statusyprojektow to update in case it exists.
     */
    where: statusyprojektowWhereUniqueInput
    /**
     * In case the statusyprojektow found by the `where` argument doesn't exist, create a new statusyprojektow with this data.
     */
    create: XOR<statusyprojektowCreateInput, statusyprojektowUncheckedCreateInput>
    /**
     * In case the statusyprojektow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusyprojektowUpdateInput, statusyprojektowUncheckedUpdateInput>
  }

  /**
   * statusyprojektow delete
   */
  export type statusyprojektowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
    /**
     * Filter which statusyprojektow to delete.
     */
    where: statusyprojektowWhereUniqueInput
  }

  /**
   * statusyprojektow deleteMany
   */
  export type statusyprojektowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statusyprojektows to delete
     */
    where?: statusyprojektowWhereInput
    /**
     * Limit how many statusyprojektows to delete.
     */
    limit?: number
  }

  /**
   * statusyprojektow.projekty
   */
  export type statusyprojektow$projektyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projekty
     */
    select?: projektySelect<ExtArgs> | null
    /**
     * Omit specific fields from the projekty
     */
    omit?: projektyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projektyInclude<ExtArgs> | null
    where?: projektyWhereInput
    orderBy?: projektyOrderByWithRelationInput | projektyOrderByWithRelationInput[]
    cursor?: projektyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjektyScalarFieldEnum | ProjektyScalarFieldEnum[]
  }

  /**
   * statusyprojektow without action
   */
  export type statusyprojektowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statusyprojektow
     */
    select?: statusyprojektowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statusyprojektow
     */
    omit?: statusyprojektowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusyprojektowInclude<ExtArgs> | null
  }


  /**
   * Model producentkatalog
   */

  export type AggregateProducentkatalog = {
    _count: ProducentkatalogCountAggregateOutputType | null
    _avg: ProducentkatalogAvgAggregateOutputType | null
    _sum: ProducentkatalogSumAggregateOutputType | null
    _min: ProducentkatalogMinAggregateOutputType | null
    _max: ProducentkatalogMaxAggregateOutputType | null
  }

  export type ProducentkatalogAvgAggregateOutputType = {
    id: number | null
    producent_id: number | null
    kategoria_id: number | null
  }

  export type ProducentkatalogSumAggregateOutputType = {
    id: number | null
    producent_id: number | null
    kategoria_id: number | null
  }

  export type ProducentkatalogMinAggregateOutputType = {
    id: number | null
    producent_id: number | null
    opis: string | null
    strona_www: string | null
    kategoria_id: number | null
  }

  export type ProducentkatalogMaxAggregateOutputType = {
    id: number | null
    producent_id: number | null
    opis: string | null
    strona_www: string | null
    kategoria_id: number | null
  }

  export type ProducentkatalogCountAggregateOutputType = {
    id: number
    producent_id: number
    opis: number
    strona_www: number
    kategoria_id: number
    _all: number
  }


  export type ProducentkatalogAvgAggregateInputType = {
    id?: true
    producent_id?: true
    kategoria_id?: true
  }

  export type ProducentkatalogSumAggregateInputType = {
    id?: true
    producent_id?: true
    kategoria_id?: true
  }

  export type ProducentkatalogMinAggregateInputType = {
    id?: true
    producent_id?: true
    opis?: true
    strona_www?: true
    kategoria_id?: true
  }

  export type ProducentkatalogMaxAggregateInputType = {
    id?: true
    producent_id?: true
    opis?: true
    strona_www?: true
    kategoria_id?: true
  }

  export type ProducentkatalogCountAggregateInputType = {
    id?: true
    producent_id?: true
    opis?: true
    strona_www?: true
    kategoria_id?: true
    _all?: true
  }

  export type ProducentkatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which producentkatalog to aggregate.
     */
    where?: producentkatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producentkatalogs to fetch.
     */
    orderBy?: producentkatalogOrderByWithRelationInput | producentkatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: producentkatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producentkatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producentkatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned producentkatalogs
    **/
    _count?: true | ProducentkatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProducentkatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProducentkatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProducentkatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProducentkatalogMaxAggregateInputType
  }

  export type GetProducentkatalogAggregateType<T extends ProducentkatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateProducentkatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducentkatalog[P]>
      : GetScalarType<T[P], AggregateProducentkatalog[P]>
  }




  export type producentkatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: producentkatalogWhereInput
    orderBy?: producentkatalogOrderByWithAggregationInput | producentkatalogOrderByWithAggregationInput[]
    by: ProducentkatalogScalarFieldEnum[] | ProducentkatalogScalarFieldEnum
    having?: producentkatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProducentkatalogCountAggregateInputType | true
    _avg?: ProducentkatalogAvgAggregateInputType
    _sum?: ProducentkatalogSumAggregateInputType
    _min?: ProducentkatalogMinAggregateInputType
    _max?: ProducentkatalogMaxAggregateInputType
  }

  export type ProducentkatalogGroupByOutputType = {
    id: number
    producent_id: number
    opis: string | null
    strona_www: string | null
    kategoria_id: number
    _count: ProducentkatalogCountAggregateOutputType | null
    _avg: ProducentkatalogAvgAggregateOutputType | null
    _sum: ProducentkatalogSumAggregateOutputType | null
    _min: ProducentkatalogMinAggregateOutputType | null
    _max: ProducentkatalogMaxAggregateOutputType | null
  }

  type GetProducentkatalogGroupByPayload<T extends producentkatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProducentkatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProducentkatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProducentkatalogGroupByOutputType[P]>
            : GetScalarType<T[P], ProducentkatalogGroupByOutputType[P]>
        }
      >
    >


  export type producentkatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    producent_id?: boolean
    opis?: boolean
    strona_www?: boolean
    kategoria_id?: boolean
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproducentowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producentkatalog"]>

  export type producentkatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    producent_id?: boolean
    opis?: boolean
    strona_www?: boolean
    kategoria_id?: boolean
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproducentowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producentkatalog"]>

  export type producentkatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    producent_id?: boolean
    opis?: boolean
    strona_www?: boolean
    kategoria_id?: boolean
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproducentowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producentkatalog"]>

  export type producentkatalogSelectScalar = {
    id?: boolean
    producent_id?: boolean
    opis?: boolean
    strona_www?: boolean
    kategoria_id?: boolean
  }

  export type producentkatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "producent_id" | "opis" | "strona_www" | "kategoria_id", ExtArgs["result"]["producentkatalog"]>
  export type producentkatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproducentowDefaultArgs<ExtArgs>
  }
  export type producentkatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproducentowDefaultArgs<ExtArgs>
  }
  export type producentkatalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producent?: boolean | uzytkownicyDefaultArgs<ExtArgs>
    kategoria?: boolean | kategorieproducentowDefaultArgs<ExtArgs>
  }

  export type $producentkatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "producentkatalog"
    objects: {
      producent: Prisma.$uzytkownicyPayload<ExtArgs>
      kategoria: Prisma.$kategorieproducentowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      producent_id: number
      opis: string | null
      strona_www: string | null
      kategoria_id: number
    }, ExtArgs["result"]["producentkatalog"]>
    composites: {}
  }

  type producentkatalogGetPayload<S extends boolean | null | undefined | producentkatalogDefaultArgs> = $Result.GetResult<Prisma.$producentkatalogPayload, S>

  type producentkatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<producentkatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProducentkatalogCountAggregateInputType | true
    }

  export interface producentkatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['producentkatalog'], meta: { name: 'producentkatalog' } }
    /**
     * Find zero or one Producentkatalog that matches the filter.
     * @param {producentkatalogFindUniqueArgs} args - Arguments to find a Producentkatalog
     * @example
     * // Get one Producentkatalog
     * const producentkatalog = await prisma.producentkatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends producentkatalogFindUniqueArgs>(args: SelectSubset<T, producentkatalogFindUniqueArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Producentkatalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {producentkatalogFindUniqueOrThrowArgs} args - Arguments to find a Producentkatalog
     * @example
     * // Get one Producentkatalog
     * const producentkatalog = await prisma.producentkatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends producentkatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, producentkatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Producentkatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producentkatalogFindFirstArgs} args - Arguments to find a Producentkatalog
     * @example
     * // Get one Producentkatalog
     * const producentkatalog = await prisma.producentkatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends producentkatalogFindFirstArgs>(args?: SelectSubset<T, producentkatalogFindFirstArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Producentkatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producentkatalogFindFirstOrThrowArgs} args - Arguments to find a Producentkatalog
     * @example
     * // Get one Producentkatalog
     * const producentkatalog = await prisma.producentkatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends producentkatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, producentkatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Producentkatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producentkatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Producentkatalogs
     * const producentkatalogs = await prisma.producentkatalog.findMany()
     * 
     * // Get first 10 Producentkatalogs
     * const producentkatalogs = await prisma.producentkatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const producentkatalogWithIdOnly = await prisma.producentkatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends producentkatalogFindManyArgs>(args?: SelectSubset<T, producentkatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Producentkatalog.
     * @param {producentkatalogCreateArgs} args - Arguments to create a Producentkatalog.
     * @example
     * // Create one Producentkatalog
     * const Producentkatalog = await prisma.producentkatalog.create({
     *   data: {
     *     // ... data to create a Producentkatalog
     *   }
     * })
     * 
     */
    create<T extends producentkatalogCreateArgs>(args: SelectSubset<T, producentkatalogCreateArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Producentkatalogs.
     * @param {producentkatalogCreateManyArgs} args - Arguments to create many Producentkatalogs.
     * @example
     * // Create many Producentkatalogs
     * const producentkatalog = await prisma.producentkatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends producentkatalogCreateManyArgs>(args?: SelectSubset<T, producentkatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Producentkatalogs and returns the data saved in the database.
     * @param {producentkatalogCreateManyAndReturnArgs} args - Arguments to create many Producentkatalogs.
     * @example
     * // Create many Producentkatalogs
     * const producentkatalog = await prisma.producentkatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Producentkatalogs and only return the `id`
     * const producentkatalogWithIdOnly = await prisma.producentkatalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends producentkatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, producentkatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Producentkatalog.
     * @param {producentkatalogDeleteArgs} args - Arguments to delete one Producentkatalog.
     * @example
     * // Delete one Producentkatalog
     * const Producentkatalog = await prisma.producentkatalog.delete({
     *   where: {
     *     // ... filter to delete one Producentkatalog
     *   }
     * })
     * 
     */
    delete<T extends producentkatalogDeleteArgs>(args: SelectSubset<T, producentkatalogDeleteArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Producentkatalog.
     * @param {producentkatalogUpdateArgs} args - Arguments to update one Producentkatalog.
     * @example
     * // Update one Producentkatalog
     * const producentkatalog = await prisma.producentkatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends producentkatalogUpdateArgs>(args: SelectSubset<T, producentkatalogUpdateArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Producentkatalogs.
     * @param {producentkatalogDeleteManyArgs} args - Arguments to filter Producentkatalogs to delete.
     * @example
     * // Delete a few Producentkatalogs
     * const { count } = await prisma.producentkatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends producentkatalogDeleteManyArgs>(args?: SelectSubset<T, producentkatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Producentkatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producentkatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Producentkatalogs
     * const producentkatalog = await prisma.producentkatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends producentkatalogUpdateManyArgs>(args: SelectSubset<T, producentkatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Producentkatalogs and returns the data updated in the database.
     * @param {producentkatalogUpdateManyAndReturnArgs} args - Arguments to update many Producentkatalogs.
     * @example
     * // Update many Producentkatalogs
     * const producentkatalog = await prisma.producentkatalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Producentkatalogs and only return the `id`
     * const producentkatalogWithIdOnly = await prisma.producentkatalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends producentkatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, producentkatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Producentkatalog.
     * @param {producentkatalogUpsertArgs} args - Arguments to update or create a Producentkatalog.
     * @example
     * // Update or create a Producentkatalog
     * const producentkatalog = await prisma.producentkatalog.upsert({
     *   create: {
     *     // ... data to create a Producentkatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producentkatalog we want to update
     *   }
     * })
     */
    upsert<T extends producentkatalogUpsertArgs>(args: SelectSubset<T, producentkatalogUpsertArgs<ExtArgs>>): Prisma__producentkatalogClient<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Producentkatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producentkatalogCountArgs} args - Arguments to filter Producentkatalogs to count.
     * @example
     * // Count the number of Producentkatalogs
     * const count = await prisma.producentkatalog.count({
     *   where: {
     *     // ... the filter for the Producentkatalogs we want to count
     *   }
     * })
    **/
    count<T extends producentkatalogCountArgs>(
      args?: Subset<T, producentkatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProducentkatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producentkatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProducentkatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProducentkatalogAggregateArgs>(args: Subset<T, ProducentkatalogAggregateArgs>): Prisma.PrismaPromise<GetProducentkatalogAggregateType<T>>

    /**
     * Group by Producentkatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producentkatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends producentkatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: producentkatalogGroupByArgs['orderBy'] }
        : { orderBy?: producentkatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, producentkatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducentkatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the producentkatalog model
   */
  readonly fields: producentkatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for producentkatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__producentkatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producent<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kategoria<T extends kategorieproducentowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kategorieproducentowDefaultArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the producentkatalog model
   */
  interface producentkatalogFieldRefs {
    readonly id: FieldRef<"producentkatalog", 'Int'>
    readonly producent_id: FieldRef<"producentkatalog", 'Int'>
    readonly opis: FieldRef<"producentkatalog", 'String'>
    readonly strona_www: FieldRef<"producentkatalog", 'String'>
    readonly kategoria_id: FieldRef<"producentkatalog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * producentkatalog findUnique
   */
  export type producentkatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * Filter, which producentkatalog to fetch.
     */
    where: producentkatalogWhereUniqueInput
  }

  /**
   * producentkatalog findUniqueOrThrow
   */
  export type producentkatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * Filter, which producentkatalog to fetch.
     */
    where: producentkatalogWhereUniqueInput
  }

  /**
   * producentkatalog findFirst
   */
  export type producentkatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * Filter, which producentkatalog to fetch.
     */
    where?: producentkatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producentkatalogs to fetch.
     */
    orderBy?: producentkatalogOrderByWithRelationInput | producentkatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producentkatalogs.
     */
    cursor?: producentkatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producentkatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producentkatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producentkatalogs.
     */
    distinct?: ProducentkatalogScalarFieldEnum | ProducentkatalogScalarFieldEnum[]
  }

  /**
   * producentkatalog findFirstOrThrow
   */
  export type producentkatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * Filter, which producentkatalog to fetch.
     */
    where?: producentkatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producentkatalogs to fetch.
     */
    orderBy?: producentkatalogOrderByWithRelationInput | producentkatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producentkatalogs.
     */
    cursor?: producentkatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producentkatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producentkatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producentkatalogs.
     */
    distinct?: ProducentkatalogScalarFieldEnum | ProducentkatalogScalarFieldEnum[]
  }

  /**
   * producentkatalog findMany
   */
  export type producentkatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * Filter, which producentkatalogs to fetch.
     */
    where?: producentkatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producentkatalogs to fetch.
     */
    orderBy?: producentkatalogOrderByWithRelationInput | producentkatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing producentkatalogs.
     */
    cursor?: producentkatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producentkatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producentkatalogs.
     */
    skip?: number
    distinct?: ProducentkatalogScalarFieldEnum | ProducentkatalogScalarFieldEnum[]
  }

  /**
   * producentkatalog create
   */
  export type producentkatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a producentkatalog.
     */
    data: XOR<producentkatalogCreateInput, producentkatalogUncheckedCreateInput>
  }

  /**
   * producentkatalog createMany
   */
  export type producentkatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many producentkatalogs.
     */
    data: producentkatalogCreateManyInput | producentkatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * producentkatalog createManyAndReturn
   */
  export type producentkatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * The data used to create many producentkatalogs.
     */
    data: producentkatalogCreateManyInput | producentkatalogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * producentkatalog update
   */
  export type producentkatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a producentkatalog.
     */
    data: XOR<producentkatalogUpdateInput, producentkatalogUncheckedUpdateInput>
    /**
     * Choose, which producentkatalog to update.
     */
    where: producentkatalogWhereUniqueInput
  }

  /**
   * producentkatalog updateMany
   */
  export type producentkatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update producentkatalogs.
     */
    data: XOR<producentkatalogUpdateManyMutationInput, producentkatalogUncheckedUpdateManyInput>
    /**
     * Filter which producentkatalogs to update
     */
    where?: producentkatalogWhereInput
    /**
     * Limit how many producentkatalogs to update.
     */
    limit?: number
  }

  /**
   * producentkatalog updateManyAndReturn
   */
  export type producentkatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * The data used to update producentkatalogs.
     */
    data: XOR<producentkatalogUpdateManyMutationInput, producentkatalogUncheckedUpdateManyInput>
    /**
     * Filter which producentkatalogs to update
     */
    where?: producentkatalogWhereInput
    /**
     * Limit how many producentkatalogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * producentkatalog upsert
   */
  export type producentkatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the producentkatalog to update in case it exists.
     */
    where: producentkatalogWhereUniqueInput
    /**
     * In case the producentkatalog found by the `where` argument doesn't exist, create a new producentkatalog with this data.
     */
    create: XOR<producentkatalogCreateInput, producentkatalogUncheckedCreateInput>
    /**
     * In case the producentkatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<producentkatalogUpdateInput, producentkatalogUncheckedUpdateInput>
  }

  /**
   * producentkatalog delete
   */
  export type producentkatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    /**
     * Filter which producentkatalog to delete.
     */
    where: producentkatalogWhereUniqueInput
  }

  /**
   * producentkatalog deleteMany
   */
  export type producentkatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which producentkatalogs to delete
     */
    where?: producentkatalogWhereInput
    /**
     * Limit how many producentkatalogs to delete.
     */
    limit?: number
  }

  /**
   * producentkatalog without action
   */
  export type producentkatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
  }


  /**
   * Model kategorieproducentow
   */

  export type AggregateKategorieproducentow = {
    _count: KategorieproducentowCountAggregateOutputType | null
    _avg: KategorieproducentowAvgAggregateOutputType | null
    _sum: KategorieproducentowSumAggregateOutputType | null
    _min: KategorieproducentowMinAggregateOutputType | null
    _max: KategorieproducentowMaxAggregateOutputType | null
  }

  export type KategorieproducentowAvgAggregateOutputType = {
    id: number | null
  }

  export type KategorieproducentowSumAggregateOutputType = {
    id: number | null
  }

  export type KategorieproducentowMinAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type KategorieproducentowMaxAggregateOutputType = {
    id: number | null
    nazwa: string | null
  }

  export type KategorieproducentowCountAggregateOutputType = {
    id: number
    nazwa: number
    _all: number
  }


  export type KategorieproducentowAvgAggregateInputType = {
    id?: true
  }

  export type KategorieproducentowSumAggregateInputType = {
    id?: true
  }

  export type KategorieproducentowMinAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type KategorieproducentowMaxAggregateInputType = {
    id?: true
    nazwa?: true
  }

  export type KategorieproducentowCountAggregateInputType = {
    id?: true
    nazwa?: true
    _all?: true
  }

  export type KategorieproducentowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategorieproducentow to aggregate.
     */
    where?: kategorieproducentowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproducentows to fetch.
     */
    orderBy?: kategorieproducentowOrderByWithRelationInput | kategorieproducentowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kategorieproducentowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproducentows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproducentows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kategorieproducentows
    **/
    _count?: true | KategorieproducentowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KategorieproducentowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KategorieproducentowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KategorieproducentowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KategorieproducentowMaxAggregateInputType
  }

  export type GetKategorieproducentowAggregateType<T extends KategorieproducentowAggregateArgs> = {
        [P in keyof T & keyof AggregateKategorieproducentow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategorieproducentow[P]>
      : GetScalarType<T[P], AggregateKategorieproducentow[P]>
  }




  export type kategorieproducentowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kategorieproducentowWhereInput
    orderBy?: kategorieproducentowOrderByWithAggregationInput | kategorieproducentowOrderByWithAggregationInput[]
    by: KategorieproducentowScalarFieldEnum[] | KategorieproducentowScalarFieldEnum
    having?: kategorieproducentowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KategorieproducentowCountAggregateInputType | true
    _avg?: KategorieproducentowAvgAggregateInputType
    _sum?: KategorieproducentowSumAggregateInputType
    _min?: KategorieproducentowMinAggregateInputType
    _max?: KategorieproducentowMaxAggregateInputType
  }

  export type KategorieproducentowGroupByOutputType = {
    id: number
    nazwa: string
    _count: KategorieproducentowCountAggregateOutputType | null
    _avg: KategorieproducentowAvgAggregateOutputType | null
    _sum: KategorieproducentowSumAggregateOutputType | null
    _min: KategorieproducentowMinAggregateOutputType | null
    _max: KategorieproducentowMaxAggregateOutputType | null
  }

  type GetKategorieproducentowGroupByPayload<T extends kategorieproducentowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KategorieproducentowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KategorieproducentowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KategorieproducentowGroupByOutputType[P]>
            : GetScalarType<T[P], KategorieproducentowGroupByOutputType[P]>
        }
      >
    >


  export type kategorieproducentowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
    producentkatalog?: boolean | kategorieproducentow$producentkatalogArgs<ExtArgs>
    _count?: boolean | KategorieproducentowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategorieproducentow"]>

  export type kategorieproducentowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["kategorieproducentow"]>

  export type kategorieproducentowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nazwa?: boolean
  }, ExtArgs["result"]["kategorieproducentow"]>

  export type kategorieproducentowSelectScalar = {
    id?: boolean
    nazwa?: boolean
  }

  export type kategorieproducentowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nazwa", ExtArgs["result"]["kategorieproducentow"]>
  export type kategorieproducentowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producentkatalog?: boolean | kategorieproducentow$producentkatalogArgs<ExtArgs>
    _count?: boolean | KategorieproducentowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type kategorieproducentowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type kategorieproducentowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $kategorieproducentowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kategorieproducentow"
    objects: {
      producentkatalog: Prisma.$producentkatalogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nazwa: string
    }, ExtArgs["result"]["kategorieproducentow"]>
    composites: {}
  }

  type kategorieproducentowGetPayload<S extends boolean | null | undefined | kategorieproducentowDefaultArgs> = $Result.GetResult<Prisma.$kategorieproducentowPayload, S>

  type kategorieproducentowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<kategorieproducentowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KategorieproducentowCountAggregateInputType | true
    }

  export interface kategorieproducentowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kategorieproducentow'], meta: { name: 'kategorieproducentow' } }
    /**
     * Find zero or one Kategorieproducentow that matches the filter.
     * @param {kategorieproducentowFindUniqueArgs} args - Arguments to find a Kategorieproducentow
     * @example
     * // Get one Kategorieproducentow
     * const kategorieproducentow = await prisma.kategorieproducentow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kategorieproducentowFindUniqueArgs>(args: SelectSubset<T, kategorieproducentowFindUniqueArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kategorieproducentow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {kategorieproducentowFindUniqueOrThrowArgs} args - Arguments to find a Kategorieproducentow
     * @example
     * // Get one Kategorieproducentow
     * const kategorieproducentow = await prisma.kategorieproducentow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kategorieproducentowFindUniqueOrThrowArgs>(args: SelectSubset<T, kategorieproducentowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kategorieproducentow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproducentowFindFirstArgs} args - Arguments to find a Kategorieproducentow
     * @example
     * // Get one Kategorieproducentow
     * const kategorieproducentow = await prisma.kategorieproducentow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kategorieproducentowFindFirstArgs>(args?: SelectSubset<T, kategorieproducentowFindFirstArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kategorieproducentow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproducentowFindFirstOrThrowArgs} args - Arguments to find a Kategorieproducentow
     * @example
     * // Get one Kategorieproducentow
     * const kategorieproducentow = await prisma.kategorieproducentow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kategorieproducentowFindFirstOrThrowArgs>(args?: SelectSubset<T, kategorieproducentowFindFirstOrThrowArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kategorieproducentows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproducentowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kategorieproducentows
     * const kategorieproducentows = await prisma.kategorieproducentow.findMany()
     * 
     * // Get first 10 Kategorieproducentows
     * const kategorieproducentows = await prisma.kategorieproducentow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kategorieproducentowWithIdOnly = await prisma.kategorieproducentow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kategorieproducentowFindManyArgs>(args?: SelectSubset<T, kategorieproducentowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kategorieproducentow.
     * @param {kategorieproducentowCreateArgs} args - Arguments to create a Kategorieproducentow.
     * @example
     * // Create one Kategorieproducentow
     * const Kategorieproducentow = await prisma.kategorieproducentow.create({
     *   data: {
     *     // ... data to create a Kategorieproducentow
     *   }
     * })
     * 
     */
    create<T extends kategorieproducentowCreateArgs>(args: SelectSubset<T, kategorieproducentowCreateArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kategorieproducentows.
     * @param {kategorieproducentowCreateManyArgs} args - Arguments to create many Kategorieproducentows.
     * @example
     * // Create many Kategorieproducentows
     * const kategorieproducentow = await prisma.kategorieproducentow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kategorieproducentowCreateManyArgs>(args?: SelectSubset<T, kategorieproducentowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kategorieproducentows and returns the data saved in the database.
     * @param {kategorieproducentowCreateManyAndReturnArgs} args - Arguments to create many Kategorieproducentows.
     * @example
     * // Create many Kategorieproducentows
     * const kategorieproducentow = await prisma.kategorieproducentow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kategorieproducentows and only return the `id`
     * const kategorieproducentowWithIdOnly = await prisma.kategorieproducentow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends kategorieproducentowCreateManyAndReturnArgs>(args?: SelectSubset<T, kategorieproducentowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kategorieproducentow.
     * @param {kategorieproducentowDeleteArgs} args - Arguments to delete one Kategorieproducentow.
     * @example
     * // Delete one Kategorieproducentow
     * const Kategorieproducentow = await prisma.kategorieproducentow.delete({
     *   where: {
     *     // ... filter to delete one Kategorieproducentow
     *   }
     * })
     * 
     */
    delete<T extends kategorieproducentowDeleteArgs>(args: SelectSubset<T, kategorieproducentowDeleteArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kategorieproducentow.
     * @param {kategorieproducentowUpdateArgs} args - Arguments to update one Kategorieproducentow.
     * @example
     * // Update one Kategorieproducentow
     * const kategorieproducentow = await prisma.kategorieproducentow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kategorieproducentowUpdateArgs>(args: SelectSubset<T, kategorieproducentowUpdateArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kategorieproducentows.
     * @param {kategorieproducentowDeleteManyArgs} args - Arguments to filter Kategorieproducentows to delete.
     * @example
     * // Delete a few Kategorieproducentows
     * const { count } = await prisma.kategorieproducentow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kategorieproducentowDeleteManyArgs>(args?: SelectSubset<T, kategorieproducentowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategorieproducentows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproducentowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kategorieproducentows
     * const kategorieproducentow = await prisma.kategorieproducentow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kategorieproducentowUpdateManyArgs>(args: SelectSubset<T, kategorieproducentowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kategorieproducentows and returns the data updated in the database.
     * @param {kategorieproducentowUpdateManyAndReturnArgs} args - Arguments to update many Kategorieproducentows.
     * @example
     * // Update many Kategorieproducentows
     * const kategorieproducentow = await prisma.kategorieproducentow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kategorieproducentows and only return the `id`
     * const kategorieproducentowWithIdOnly = await prisma.kategorieproducentow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends kategorieproducentowUpdateManyAndReturnArgs>(args: SelectSubset<T, kategorieproducentowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kategorieproducentow.
     * @param {kategorieproducentowUpsertArgs} args - Arguments to update or create a Kategorieproducentow.
     * @example
     * // Update or create a Kategorieproducentow
     * const kategorieproducentow = await prisma.kategorieproducentow.upsert({
     *   create: {
     *     // ... data to create a Kategorieproducentow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kategorieproducentow we want to update
     *   }
     * })
     */
    upsert<T extends kategorieproducentowUpsertArgs>(args: SelectSubset<T, kategorieproducentowUpsertArgs<ExtArgs>>): Prisma__kategorieproducentowClient<$Result.GetResult<Prisma.$kategorieproducentowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kategorieproducentows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproducentowCountArgs} args - Arguments to filter Kategorieproducentows to count.
     * @example
     * // Count the number of Kategorieproducentows
     * const count = await prisma.kategorieproducentow.count({
     *   where: {
     *     // ... the filter for the Kategorieproducentows we want to count
     *   }
     * })
    **/
    count<T extends kategorieproducentowCountArgs>(
      args?: Subset<T, kategorieproducentowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KategorieproducentowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kategorieproducentow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategorieproducentowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KategorieproducentowAggregateArgs>(args: Subset<T, KategorieproducentowAggregateArgs>): Prisma.PrismaPromise<GetKategorieproducentowAggregateType<T>>

    /**
     * Group by Kategorieproducentow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategorieproducentowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kategorieproducentowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kategorieproducentowGroupByArgs['orderBy'] }
        : { orderBy?: kategorieproducentowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kategorieproducentowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategorieproducentowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kategorieproducentow model
   */
  readonly fields: kategorieproducentowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kategorieproducentow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kategorieproducentowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producentkatalog<T extends kategorieproducentow$producentkatalogArgs<ExtArgs> = {}>(args?: Subset<T, kategorieproducentow$producentkatalogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$producentkatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kategorieproducentow model
   */
  interface kategorieproducentowFieldRefs {
    readonly id: FieldRef<"kategorieproducentow", 'Int'>
    readonly nazwa: FieldRef<"kategorieproducentow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kategorieproducentow findUnique
   */
  export type kategorieproducentowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproducentow to fetch.
     */
    where: kategorieproducentowWhereUniqueInput
  }

  /**
   * kategorieproducentow findUniqueOrThrow
   */
  export type kategorieproducentowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproducentow to fetch.
     */
    where: kategorieproducentowWhereUniqueInput
  }

  /**
   * kategorieproducentow findFirst
   */
  export type kategorieproducentowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproducentow to fetch.
     */
    where?: kategorieproducentowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproducentows to fetch.
     */
    orderBy?: kategorieproducentowOrderByWithRelationInput | kategorieproducentowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategorieproducentows.
     */
    cursor?: kategorieproducentowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproducentows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproducentows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategorieproducentows.
     */
    distinct?: KategorieproducentowScalarFieldEnum | KategorieproducentowScalarFieldEnum[]
  }

  /**
   * kategorieproducentow findFirstOrThrow
   */
  export type kategorieproducentowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproducentow to fetch.
     */
    where?: kategorieproducentowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproducentows to fetch.
     */
    orderBy?: kategorieproducentowOrderByWithRelationInput | kategorieproducentowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategorieproducentows.
     */
    cursor?: kategorieproducentowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproducentows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproducentows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategorieproducentows.
     */
    distinct?: KategorieproducentowScalarFieldEnum | KategorieproducentowScalarFieldEnum[]
  }

  /**
   * kategorieproducentow findMany
   */
  export type kategorieproducentowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * Filter, which kategorieproducentows to fetch.
     */
    where?: kategorieproducentowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategorieproducentows to fetch.
     */
    orderBy?: kategorieproducentowOrderByWithRelationInput | kategorieproducentowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kategorieproducentows.
     */
    cursor?: kategorieproducentowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategorieproducentows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategorieproducentows.
     */
    skip?: number
    distinct?: KategorieproducentowScalarFieldEnum | KategorieproducentowScalarFieldEnum[]
  }

  /**
   * kategorieproducentow create
   */
  export type kategorieproducentowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * The data needed to create a kategorieproducentow.
     */
    data: XOR<kategorieproducentowCreateInput, kategorieproducentowUncheckedCreateInput>
  }

  /**
   * kategorieproducentow createMany
   */
  export type kategorieproducentowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kategorieproducentows.
     */
    data: kategorieproducentowCreateManyInput | kategorieproducentowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategorieproducentow createManyAndReturn
   */
  export type kategorieproducentowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * The data used to create many kategorieproducentows.
     */
    data: kategorieproducentowCreateManyInput | kategorieproducentowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategorieproducentow update
   */
  export type kategorieproducentowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * The data needed to update a kategorieproducentow.
     */
    data: XOR<kategorieproducentowUpdateInput, kategorieproducentowUncheckedUpdateInput>
    /**
     * Choose, which kategorieproducentow to update.
     */
    where: kategorieproducentowWhereUniqueInput
  }

  /**
   * kategorieproducentow updateMany
   */
  export type kategorieproducentowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kategorieproducentows.
     */
    data: XOR<kategorieproducentowUpdateManyMutationInput, kategorieproducentowUncheckedUpdateManyInput>
    /**
     * Filter which kategorieproducentows to update
     */
    where?: kategorieproducentowWhereInput
    /**
     * Limit how many kategorieproducentows to update.
     */
    limit?: number
  }

  /**
   * kategorieproducentow updateManyAndReturn
   */
  export type kategorieproducentowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * The data used to update kategorieproducentows.
     */
    data: XOR<kategorieproducentowUpdateManyMutationInput, kategorieproducentowUncheckedUpdateManyInput>
    /**
     * Filter which kategorieproducentows to update
     */
    where?: kategorieproducentowWhereInput
    /**
     * Limit how many kategorieproducentows to update.
     */
    limit?: number
  }

  /**
   * kategorieproducentow upsert
   */
  export type kategorieproducentowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * The filter to search for the kategorieproducentow to update in case it exists.
     */
    where: kategorieproducentowWhereUniqueInput
    /**
     * In case the kategorieproducentow found by the `where` argument doesn't exist, create a new kategorieproducentow with this data.
     */
    create: XOR<kategorieproducentowCreateInput, kategorieproducentowUncheckedCreateInput>
    /**
     * In case the kategorieproducentow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kategorieproducentowUpdateInput, kategorieproducentowUncheckedUpdateInput>
  }

  /**
   * kategorieproducentow delete
   */
  export type kategorieproducentowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
    /**
     * Filter which kategorieproducentow to delete.
     */
    where: kategorieproducentowWhereUniqueInput
  }

  /**
   * kategorieproducentow deleteMany
   */
  export type kategorieproducentowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategorieproducentows to delete
     */
    where?: kategorieproducentowWhereInput
    /**
     * Limit how many kategorieproducentows to delete.
     */
    limit?: number
  }

  /**
   * kategorieproducentow.producentkatalog
   */
  export type kategorieproducentow$producentkatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producentkatalog
     */
    select?: producentkatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the producentkatalog
     */
    omit?: producentkatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: producentkatalogInclude<ExtArgs> | null
    where?: producentkatalogWhereInput
    orderBy?: producentkatalogOrderByWithRelationInput | producentkatalogOrderByWithRelationInput[]
    cursor?: producentkatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProducentkatalogScalarFieldEnum | ProducentkatalogScalarFieldEnum[]
  }

  /**
   * kategorieproducentow without action
   */
  export type kategorieproducentowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategorieproducentow
     */
    select?: kategorieproducentowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategorieproducentow
     */
    omit?: kategorieproducentowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategorieproducentowInclude<ExtArgs> | null
  }


  /**
   * Model podwykonawcy
   */

  export type AggregatePodwykonawcy = {
    _count: PodwykonawcyCountAggregateOutputType | null
    _avg: PodwykonawcyAvgAggregateOutputType | null
    _sum: PodwykonawcySumAggregateOutputType | null
    _min: PodwykonawcyMinAggregateOutputType | null
    _max: PodwykonawcyMaxAggregateOutputType | null
  }

  export type PodwykonawcyAvgAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
  }

  export type PodwykonawcySumAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
  }

  export type PodwykonawcyMinAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    specjalizacja: string | null
    opis: string | null
    kontakt: string | null
  }

  export type PodwykonawcyMaxAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    specjalizacja: string | null
    opis: string | null
    kontakt: string | null
  }

  export type PodwykonawcyCountAggregateOutputType = {
    id: number
    uzytkownik_id: number
    specjalizacja: number
    opis: number
    kontakt: number
    _all: number
  }


  export type PodwykonawcyAvgAggregateInputType = {
    id?: true
    uzytkownik_id?: true
  }

  export type PodwykonawcySumAggregateInputType = {
    id?: true
    uzytkownik_id?: true
  }

  export type PodwykonawcyMinAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    specjalizacja?: true
    opis?: true
    kontakt?: true
  }

  export type PodwykonawcyMaxAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    specjalizacja?: true
    opis?: true
    kontakt?: true
  }

  export type PodwykonawcyCountAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    specjalizacja?: true
    opis?: true
    kontakt?: true
    _all?: true
  }

  export type PodwykonawcyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which podwykonawcy to aggregate.
     */
    where?: podwykonawcyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of podwykonawcies to fetch.
     */
    orderBy?: podwykonawcyOrderByWithRelationInput | podwykonawcyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: podwykonawcyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` podwykonawcies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` podwykonawcies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned podwykonawcies
    **/
    _count?: true | PodwykonawcyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PodwykonawcyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PodwykonawcySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PodwykonawcyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PodwykonawcyMaxAggregateInputType
  }

  export type GetPodwykonawcyAggregateType<T extends PodwykonawcyAggregateArgs> = {
        [P in keyof T & keyof AggregatePodwykonawcy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePodwykonawcy[P]>
      : GetScalarType<T[P], AggregatePodwykonawcy[P]>
  }




  export type podwykonawcyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: podwykonawcyWhereInput
    orderBy?: podwykonawcyOrderByWithAggregationInput | podwykonawcyOrderByWithAggregationInput[]
    by: PodwykonawcyScalarFieldEnum[] | PodwykonawcyScalarFieldEnum
    having?: podwykonawcyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PodwykonawcyCountAggregateInputType | true
    _avg?: PodwykonawcyAvgAggregateInputType
    _sum?: PodwykonawcySumAggregateInputType
    _min?: PodwykonawcyMinAggregateInputType
    _max?: PodwykonawcyMaxAggregateInputType
  }

  export type PodwykonawcyGroupByOutputType = {
    id: number
    uzytkownik_id: number
    specjalizacja: string | null
    opis: string | null
    kontakt: string | null
    _count: PodwykonawcyCountAggregateOutputType | null
    _avg: PodwykonawcyAvgAggregateOutputType | null
    _sum: PodwykonawcySumAggregateOutputType | null
    _min: PodwykonawcyMinAggregateOutputType | null
    _max: PodwykonawcyMaxAggregateOutputType | null
  }

  type GetPodwykonawcyGroupByPayload<T extends podwykonawcyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PodwykonawcyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PodwykonawcyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PodwykonawcyGroupByOutputType[P]>
            : GetScalarType<T[P], PodwykonawcyGroupByOutputType[P]>
        }
      >
    >


  export type podwykonawcySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podwykonawcy"]>

  export type podwykonawcySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podwykonawcy"]>

  export type podwykonawcySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["podwykonawcy"]>

  export type podwykonawcySelectScalar = {
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
  }

  export type podwykonawcyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uzytkownik_id" | "specjalizacja" | "opis" | "kontakt", ExtArgs["result"]["podwykonawcy"]>
  export type podwykonawcyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }
  export type podwykonawcyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }
  export type podwykonawcyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }

  export type $podwykonawcyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "podwykonawcy"
    objects: {
      uzytkownik: Prisma.$uzytkownicyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uzytkownik_id: number
      specjalizacja: string | null
      opis: string | null
      kontakt: string | null
    }, ExtArgs["result"]["podwykonawcy"]>
    composites: {}
  }

  type podwykonawcyGetPayload<S extends boolean | null | undefined | podwykonawcyDefaultArgs> = $Result.GetResult<Prisma.$podwykonawcyPayload, S>

  type podwykonawcyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<podwykonawcyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PodwykonawcyCountAggregateInputType | true
    }

  export interface podwykonawcyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['podwykonawcy'], meta: { name: 'podwykonawcy' } }
    /**
     * Find zero or one Podwykonawcy that matches the filter.
     * @param {podwykonawcyFindUniqueArgs} args - Arguments to find a Podwykonawcy
     * @example
     * // Get one Podwykonawcy
     * const podwykonawcy = await prisma.podwykonawcy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends podwykonawcyFindUniqueArgs>(args: SelectSubset<T, podwykonawcyFindUniqueArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Podwykonawcy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {podwykonawcyFindUniqueOrThrowArgs} args - Arguments to find a Podwykonawcy
     * @example
     * // Get one Podwykonawcy
     * const podwykonawcy = await prisma.podwykonawcy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends podwykonawcyFindUniqueOrThrowArgs>(args: SelectSubset<T, podwykonawcyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Podwykonawcy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {podwykonawcyFindFirstArgs} args - Arguments to find a Podwykonawcy
     * @example
     * // Get one Podwykonawcy
     * const podwykonawcy = await prisma.podwykonawcy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends podwykonawcyFindFirstArgs>(args?: SelectSubset<T, podwykonawcyFindFirstArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Podwykonawcy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {podwykonawcyFindFirstOrThrowArgs} args - Arguments to find a Podwykonawcy
     * @example
     * // Get one Podwykonawcy
     * const podwykonawcy = await prisma.podwykonawcy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends podwykonawcyFindFirstOrThrowArgs>(args?: SelectSubset<T, podwykonawcyFindFirstOrThrowArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Podwykonawcies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {podwykonawcyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Podwykonawcies
     * const podwykonawcies = await prisma.podwykonawcy.findMany()
     * 
     * // Get first 10 Podwykonawcies
     * const podwykonawcies = await prisma.podwykonawcy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const podwykonawcyWithIdOnly = await prisma.podwykonawcy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends podwykonawcyFindManyArgs>(args?: SelectSubset<T, podwykonawcyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Podwykonawcy.
     * @param {podwykonawcyCreateArgs} args - Arguments to create a Podwykonawcy.
     * @example
     * // Create one Podwykonawcy
     * const Podwykonawcy = await prisma.podwykonawcy.create({
     *   data: {
     *     // ... data to create a Podwykonawcy
     *   }
     * })
     * 
     */
    create<T extends podwykonawcyCreateArgs>(args: SelectSubset<T, podwykonawcyCreateArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Podwykonawcies.
     * @param {podwykonawcyCreateManyArgs} args - Arguments to create many Podwykonawcies.
     * @example
     * // Create many Podwykonawcies
     * const podwykonawcy = await prisma.podwykonawcy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends podwykonawcyCreateManyArgs>(args?: SelectSubset<T, podwykonawcyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Podwykonawcies and returns the data saved in the database.
     * @param {podwykonawcyCreateManyAndReturnArgs} args - Arguments to create many Podwykonawcies.
     * @example
     * // Create many Podwykonawcies
     * const podwykonawcy = await prisma.podwykonawcy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Podwykonawcies and only return the `id`
     * const podwykonawcyWithIdOnly = await prisma.podwykonawcy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends podwykonawcyCreateManyAndReturnArgs>(args?: SelectSubset<T, podwykonawcyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Podwykonawcy.
     * @param {podwykonawcyDeleteArgs} args - Arguments to delete one Podwykonawcy.
     * @example
     * // Delete one Podwykonawcy
     * const Podwykonawcy = await prisma.podwykonawcy.delete({
     *   where: {
     *     // ... filter to delete one Podwykonawcy
     *   }
     * })
     * 
     */
    delete<T extends podwykonawcyDeleteArgs>(args: SelectSubset<T, podwykonawcyDeleteArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Podwykonawcy.
     * @param {podwykonawcyUpdateArgs} args - Arguments to update one Podwykonawcy.
     * @example
     * // Update one Podwykonawcy
     * const podwykonawcy = await prisma.podwykonawcy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends podwykonawcyUpdateArgs>(args: SelectSubset<T, podwykonawcyUpdateArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Podwykonawcies.
     * @param {podwykonawcyDeleteManyArgs} args - Arguments to filter Podwykonawcies to delete.
     * @example
     * // Delete a few Podwykonawcies
     * const { count } = await prisma.podwykonawcy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends podwykonawcyDeleteManyArgs>(args?: SelectSubset<T, podwykonawcyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Podwykonawcies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {podwykonawcyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Podwykonawcies
     * const podwykonawcy = await prisma.podwykonawcy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends podwykonawcyUpdateManyArgs>(args: SelectSubset<T, podwykonawcyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Podwykonawcies and returns the data updated in the database.
     * @param {podwykonawcyUpdateManyAndReturnArgs} args - Arguments to update many Podwykonawcies.
     * @example
     * // Update many Podwykonawcies
     * const podwykonawcy = await prisma.podwykonawcy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Podwykonawcies and only return the `id`
     * const podwykonawcyWithIdOnly = await prisma.podwykonawcy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends podwykonawcyUpdateManyAndReturnArgs>(args: SelectSubset<T, podwykonawcyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Podwykonawcy.
     * @param {podwykonawcyUpsertArgs} args - Arguments to update or create a Podwykonawcy.
     * @example
     * // Update or create a Podwykonawcy
     * const podwykonawcy = await prisma.podwykonawcy.upsert({
     *   create: {
     *     // ... data to create a Podwykonawcy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Podwykonawcy we want to update
     *   }
     * })
     */
    upsert<T extends podwykonawcyUpsertArgs>(args: SelectSubset<T, podwykonawcyUpsertArgs<ExtArgs>>): Prisma__podwykonawcyClient<$Result.GetResult<Prisma.$podwykonawcyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Podwykonawcies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {podwykonawcyCountArgs} args - Arguments to filter Podwykonawcies to count.
     * @example
     * // Count the number of Podwykonawcies
     * const count = await prisma.podwykonawcy.count({
     *   where: {
     *     // ... the filter for the Podwykonawcies we want to count
     *   }
     * })
    **/
    count<T extends podwykonawcyCountArgs>(
      args?: Subset<T, podwykonawcyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PodwykonawcyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Podwykonawcy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PodwykonawcyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PodwykonawcyAggregateArgs>(args: Subset<T, PodwykonawcyAggregateArgs>): Prisma.PrismaPromise<GetPodwykonawcyAggregateType<T>>

    /**
     * Group by Podwykonawcy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {podwykonawcyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends podwykonawcyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: podwykonawcyGroupByArgs['orderBy'] }
        : { orderBy?: podwykonawcyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, podwykonawcyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPodwykonawcyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the podwykonawcy model
   */
  readonly fields: podwykonawcyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for podwykonawcy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__podwykonawcyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uzytkownik<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the podwykonawcy model
   */
  interface podwykonawcyFieldRefs {
    readonly id: FieldRef<"podwykonawcy", 'Int'>
    readonly uzytkownik_id: FieldRef<"podwykonawcy", 'Int'>
    readonly specjalizacja: FieldRef<"podwykonawcy", 'String'>
    readonly opis: FieldRef<"podwykonawcy", 'String'>
    readonly kontakt: FieldRef<"podwykonawcy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * podwykonawcy findUnique
   */
  export type podwykonawcyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * Filter, which podwykonawcy to fetch.
     */
    where: podwykonawcyWhereUniqueInput
  }

  /**
   * podwykonawcy findUniqueOrThrow
   */
  export type podwykonawcyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * Filter, which podwykonawcy to fetch.
     */
    where: podwykonawcyWhereUniqueInput
  }

  /**
   * podwykonawcy findFirst
   */
  export type podwykonawcyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * Filter, which podwykonawcy to fetch.
     */
    where?: podwykonawcyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of podwykonawcies to fetch.
     */
    orderBy?: podwykonawcyOrderByWithRelationInput | podwykonawcyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for podwykonawcies.
     */
    cursor?: podwykonawcyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` podwykonawcies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` podwykonawcies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of podwykonawcies.
     */
    distinct?: PodwykonawcyScalarFieldEnum | PodwykonawcyScalarFieldEnum[]
  }

  /**
   * podwykonawcy findFirstOrThrow
   */
  export type podwykonawcyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * Filter, which podwykonawcy to fetch.
     */
    where?: podwykonawcyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of podwykonawcies to fetch.
     */
    orderBy?: podwykonawcyOrderByWithRelationInput | podwykonawcyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for podwykonawcies.
     */
    cursor?: podwykonawcyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` podwykonawcies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` podwykonawcies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of podwykonawcies.
     */
    distinct?: PodwykonawcyScalarFieldEnum | PodwykonawcyScalarFieldEnum[]
  }

  /**
   * podwykonawcy findMany
   */
  export type podwykonawcyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * Filter, which podwykonawcies to fetch.
     */
    where?: podwykonawcyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of podwykonawcies to fetch.
     */
    orderBy?: podwykonawcyOrderByWithRelationInput | podwykonawcyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing podwykonawcies.
     */
    cursor?: podwykonawcyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` podwykonawcies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` podwykonawcies.
     */
    skip?: number
    distinct?: PodwykonawcyScalarFieldEnum | PodwykonawcyScalarFieldEnum[]
  }

  /**
   * podwykonawcy create
   */
  export type podwykonawcyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * The data needed to create a podwykonawcy.
     */
    data: XOR<podwykonawcyCreateInput, podwykonawcyUncheckedCreateInput>
  }

  /**
   * podwykonawcy createMany
   */
  export type podwykonawcyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many podwykonawcies.
     */
    data: podwykonawcyCreateManyInput | podwykonawcyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * podwykonawcy createManyAndReturn
   */
  export type podwykonawcyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * The data used to create many podwykonawcies.
     */
    data: podwykonawcyCreateManyInput | podwykonawcyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * podwykonawcy update
   */
  export type podwykonawcyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * The data needed to update a podwykonawcy.
     */
    data: XOR<podwykonawcyUpdateInput, podwykonawcyUncheckedUpdateInput>
    /**
     * Choose, which podwykonawcy to update.
     */
    where: podwykonawcyWhereUniqueInput
  }

  /**
   * podwykonawcy updateMany
   */
  export type podwykonawcyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update podwykonawcies.
     */
    data: XOR<podwykonawcyUpdateManyMutationInput, podwykonawcyUncheckedUpdateManyInput>
    /**
     * Filter which podwykonawcies to update
     */
    where?: podwykonawcyWhereInput
    /**
     * Limit how many podwykonawcies to update.
     */
    limit?: number
  }

  /**
   * podwykonawcy updateManyAndReturn
   */
  export type podwykonawcyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * The data used to update podwykonawcies.
     */
    data: XOR<podwykonawcyUpdateManyMutationInput, podwykonawcyUncheckedUpdateManyInput>
    /**
     * Filter which podwykonawcies to update
     */
    where?: podwykonawcyWhereInput
    /**
     * Limit how many podwykonawcies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * podwykonawcy upsert
   */
  export type podwykonawcyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * The filter to search for the podwykonawcy to update in case it exists.
     */
    where: podwykonawcyWhereUniqueInput
    /**
     * In case the podwykonawcy found by the `where` argument doesn't exist, create a new podwykonawcy with this data.
     */
    create: XOR<podwykonawcyCreateInput, podwykonawcyUncheckedCreateInput>
    /**
     * In case the podwykonawcy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<podwykonawcyUpdateInput, podwykonawcyUncheckedUpdateInput>
  }

  /**
   * podwykonawcy delete
   */
  export type podwykonawcyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
    /**
     * Filter which podwykonawcy to delete.
     */
    where: podwykonawcyWhereUniqueInput
  }

  /**
   * podwykonawcy deleteMany
   */
  export type podwykonawcyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which podwykonawcies to delete
     */
    where?: podwykonawcyWhereInput
    /**
     * Limit how many podwykonawcies to delete.
     */
    limit?: number
  }

  /**
   * podwykonawcy without action
   */
  export type podwykonawcyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the podwykonawcy
     */
    select?: podwykonawcySelect<ExtArgs> | null
    /**
     * Omit specific fields from the podwykonawcy
     */
    omit?: podwykonawcyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: podwykonawcyInclude<ExtArgs> | null
  }


  /**
   * Model freelancerzy
   */

  export type AggregateFreelancerzy = {
    _count: FreelancerzyCountAggregateOutputType | null
    _avg: FreelancerzyAvgAggregateOutputType | null
    _sum: FreelancerzySumAggregateOutputType | null
    _min: FreelancerzyMinAggregateOutputType | null
    _max: FreelancerzyMaxAggregateOutputType | null
  }

  export type FreelancerzyAvgAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
  }

  export type FreelancerzySumAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
  }

  export type FreelancerzyMinAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    specjalizacja: string | null
    opis: string | null
    kontakt: string | null
  }

  export type FreelancerzyMaxAggregateOutputType = {
    id: number | null
    uzytkownik_id: number | null
    specjalizacja: string | null
    opis: string | null
    kontakt: string | null
  }

  export type FreelancerzyCountAggregateOutputType = {
    id: number
    uzytkownik_id: number
    specjalizacja: number
    opis: number
    kontakt: number
    _all: number
  }


  export type FreelancerzyAvgAggregateInputType = {
    id?: true
    uzytkownik_id?: true
  }

  export type FreelancerzySumAggregateInputType = {
    id?: true
    uzytkownik_id?: true
  }

  export type FreelancerzyMinAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    specjalizacja?: true
    opis?: true
    kontakt?: true
  }

  export type FreelancerzyMaxAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    specjalizacja?: true
    opis?: true
    kontakt?: true
  }

  export type FreelancerzyCountAggregateInputType = {
    id?: true
    uzytkownik_id?: true
    specjalizacja?: true
    opis?: true
    kontakt?: true
    _all?: true
  }

  export type FreelancerzyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which freelancerzy to aggregate.
     */
    where?: freelancerzyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freelancerzies to fetch.
     */
    orderBy?: freelancerzyOrderByWithRelationInput | freelancerzyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: freelancerzyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freelancerzies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freelancerzies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned freelancerzies
    **/
    _count?: true | FreelancerzyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreelancerzyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreelancerzySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelancerzyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelancerzyMaxAggregateInputType
  }

  export type GetFreelancerzyAggregateType<T extends FreelancerzyAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelancerzy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelancerzy[P]>
      : GetScalarType<T[P], AggregateFreelancerzy[P]>
  }




  export type freelancerzyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: freelancerzyWhereInput
    orderBy?: freelancerzyOrderByWithAggregationInput | freelancerzyOrderByWithAggregationInput[]
    by: FreelancerzyScalarFieldEnum[] | FreelancerzyScalarFieldEnum
    having?: freelancerzyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelancerzyCountAggregateInputType | true
    _avg?: FreelancerzyAvgAggregateInputType
    _sum?: FreelancerzySumAggregateInputType
    _min?: FreelancerzyMinAggregateInputType
    _max?: FreelancerzyMaxAggregateInputType
  }

  export type FreelancerzyGroupByOutputType = {
    id: number
    uzytkownik_id: number
    specjalizacja: string | null
    opis: string | null
    kontakt: string | null
    _count: FreelancerzyCountAggregateOutputType | null
    _avg: FreelancerzyAvgAggregateOutputType | null
    _sum: FreelancerzySumAggregateOutputType | null
    _min: FreelancerzyMinAggregateOutputType | null
    _max: FreelancerzyMaxAggregateOutputType | null
  }

  type GetFreelancerzyGroupByPayload<T extends freelancerzyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelancerzyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelancerzyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelancerzyGroupByOutputType[P]>
            : GetScalarType<T[P], FreelancerzyGroupByOutputType[P]>
        }
      >
    >


  export type freelancerzySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerzy"]>

  export type freelancerzySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerzy"]>

  export type freelancerzySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerzy"]>

  export type freelancerzySelectScalar = {
    id?: boolean
    uzytkownik_id?: boolean
    specjalizacja?: boolean
    opis?: boolean
    kontakt?: boolean
  }

  export type freelancerzyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uzytkownik_id" | "specjalizacja" | "opis" | "kontakt", ExtArgs["result"]["freelancerzy"]>
  export type freelancerzyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }
  export type freelancerzyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }
  export type freelancerzyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uzytkownik?: boolean | uzytkownicyDefaultArgs<ExtArgs>
  }

  export type $freelancerzyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "freelancerzy"
    objects: {
      uzytkownik: Prisma.$uzytkownicyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uzytkownik_id: number
      specjalizacja: string | null
      opis: string | null
      kontakt: string | null
    }, ExtArgs["result"]["freelancerzy"]>
    composites: {}
  }

  type freelancerzyGetPayload<S extends boolean | null | undefined | freelancerzyDefaultArgs> = $Result.GetResult<Prisma.$freelancerzyPayload, S>

  type freelancerzyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<freelancerzyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelancerzyCountAggregateInputType | true
    }

  export interface freelancerzyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['freelancerzy'], meta: { name: 'freelancerzy' } }
    /**
     * Find zero or one Freelancerzy that matches the filter.
     * @param {freelancerzyFindUniqueArgs} args - Arguments to find a Freelancerzy
     * @example
     * // Get one Freelancerzy
     * const freelancerzy = await prisma.freelancerzy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends freelancerzyFindUniqueArgs>(args: SelectSubset<T, freelancerzyFindUniqueArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Freelancerzy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {freelancerzyFindUniqueOrThrowArgs} args - Arguments to find a Freelancerzy
     * @example
     * // Get one Freelancerzy
     * const freelancerzy = await prisma.freelancerzy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends freelancerzyFindUniqueOrThrowArgs>(args: SelectSubset<T, freelancerzyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Freelancerzy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freelancerzyFindFirstArgs} args - Arguments to find a Freelancerzy
     * @example
     * // Get one Freelancerzy
     * const freelancerzy = await prisma.freelancerzy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends freelancerzyFindFirstArgs>(args?: SelectSubset<T, freelancerzyFindFirstArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Freelancerzy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freelancerzyFindFirstOrThrowArgs} args - Arguments to find a Freelancerzy
     * @example
     * // Get one Freelancerzy
     * const freelancerzy = await prisma.freelancerzy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends freelancerzyFindFirstOrThrowArgs>(args?: SelectSubset<T, freelancerzyFindFirstOrThrowArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Freelancerzies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freelancerzyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Freelancerzies
     * const freelancerzies = await prisma.freelancerzy.findMany()
     * 
     * // Get first 10 Freelancerzies
     * const freelancerzies = await prisma.freelancerzy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelancerzyWithIdOnly = await prisma.freelancerzy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends freelancerzyFindManyArgs>(args?: SelectSubset<T, freelancerzyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Freelancerzy.
     * @param {freelancerzyCreateArgs} args - Arguments to create a Freelancerzy.
     * @example
     * // Create one Freelancerzy
     * const Freelancerzy = await prisma.freelancerzy.create({
     *   data: {
     *     // ... data to create a Freelancerzy
     *   }
     * })
     * 
     */
    create<T extends freelancerzyCreateArgs>(args: SelectSubset<T, freelancerzyCreateArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Freelancerzies.
     * @param {freelancerzyCreateManyArgs} args - Arguments to create many Freelancerzies.
     * @example
     * // Create many Freelancerzies
     * const freelancerzy = await prisma.freelancerzy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends freelancerzyCreateManyArgs>(args?: SelectSubset<T, freelancerzyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Freelancerzies and returns the data saved in the database.
     * @param {freelancerzyCreateManyAndReturnArgs} args - Arguments to create many Freelancerzies.
     * @example
     * // Create many Freelancerzies
     * const freelancerzy = await prisma.freelancerzy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Freelancerzies and only return the `id`
     * const freelancerzyWithIdOnly = await prisma.freelancerzy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends freelancerzyCreateManyAndReturnArgs>(args?: SelectSubset<T, freelancerzyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Freelancerzy.
     * @param {freelancerzyDeleteArgs} args - Arguments to delete one Freelancerzy.
     * @example
     * // Delete one Freelancerzy
     * const Freelancerzy = await prisma.freelancerzy.delete({
     *   where: {
     *     // ... filter to delete one Freelancerzy
     *   }
     * })
     * 
     */
    delete<T extends freelancerzyDeleteArgs>(args: SelectSubset<T, freelancerzyDeleteArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Freelancerzy.
     * @param {freelancerzyUpdateArgs} args - Arguments to update one Freelancerzy.
     * @example
     * // Update one Freelancerzy
     * const freelancerzy = await prisma.freelancerzy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends freelancerzyUpdateArgs>(args: SelectSubset<T, freelancerzyUpdateArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Freelancerzies.
     * @param {freelancerzyDeleteManyArgs} args - Arguments to filter Freelancerzies to delete.
     * @example
     * // Delete a few Freelancerzies
     * const { count } = await prisma.freelancerzy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends freelancerzyDeleteManyArgs>(args?: SelectSubset<T, freelancerzyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Freelancerzies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freelancerzyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Freelancerzies
     * const freelancerzy = await prisma.freelancerzy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends freelancerzyUpdateManyArgs>(args: SelectSubset<T, freelancerzyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Freelancerzies and returns the data updated in the database.
     * @param {freelancerzyUpdateManyAndReturnArgs} args - Arguments to update many Freelancerzies.
     * @example
     * // Update many Freelancerzies
     * const freelancerzy = await prisma.freelancerzy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Freelancerzies and only return the `id`
     * const freelancerzyWithIdOnly = await prisma.freelancerzy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends freelancerzyUpdateManyAndReturnArgs>(args: SelectSubset<T, freelancerzyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Freelancerzy.
     * @param {freelancerzyUpsertArgs} args - Arguments to update or create a Freelancerzy.
     * @example
     * // Update or create a Freelancerzy
     * const freelancerzy = await prisma.freelancerzy.upsert({
     *   create: {
     *     // ... data to create a Freelancerzy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Freelancerzy we want to update
     *   }
     * })
     */
    upsert<T extends freelancerzyUpsertArgs>(args: SelectSubset<T, freelancerzyUpsertArgs<ExtArgs>>): Prisma__freelancerzyClient<$Result.GetResult<Prisma.$freelancerzyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Freelancerzies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freelancerzyCountArgs} args - Arguments to filter Freelancerzies to count.
     * @example
     * // Count the number of Freelancerzies
     * const count = await prisma.freelancerzy.count({
     *   where: {
     *     // ... the filter for the Freelancerzies we want to count
     *   }
     * })
    **/
    count<T extends freelancerzyCountArgs>(
      args?: Subset<T, freelancerzyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelancerzyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Freelancerzy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerzyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelancerzyAggregateArgs>(args: Subset<T, FreelancerzyAggregateArgs>): Prisma.PrismaPromise<GetFreelancerzyAggregateType<T>>

    /**
     * Group by Freelancerzy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freelancerzyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends freelancerzyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: freelancerzyGroupByArgs['orderBy'] }
        : { orderBy?: freelancerzyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, freelancerzyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelancerzyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the freelancerzy model
   */
  readonly fields: freelancerzyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for freelancerzy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__freelancerzyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uzytkownik<T extends uzytkownicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, uzytkownicyDefaultArgs<ExtArgs>>): Prisma__uzytkownicyClient<$Result.GetResult<Prisma.$uzytkownicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the freelancerzy model
   */
  interface freelancerzyFieldRefs {
    readonly id: FieldRef<"freelancerzy", 'Int'>
    readonly uzytkownik_id: FieldRef<"freelancerzy", 'Int'>
    readonly specjalizacja: FieldRef<"freelancerzy", 'String'>
    readonly opis: FieldRef<"freelancerzy", 'String'>
    readonly kontakt: FieldRef<"freelancerzy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * freelancerzy findUnique
   */
  export type freelancerzyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * Filter, which freelancerzy to fetch.
     */
    where: freelancerzyWhereUniqueInput
  }

  /**
   * freelancerzy findUniqueOrThrow
   */
  export type freelancerzyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * Filter, which freelancerzy to fetch.
     */
    where: freelancerzyWhereUniqueInput
  }

  /**
   * freelancerzy findFirst
   */
  export type freelancerzyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * Filter, which freelancerzy to fetch.
     */
    where?: freelancerzyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freelancerzies to fetch.
     */
    orderBy?: freelancerzyOrderByWithRelationInput | freelancerzyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for freelancerzies.
     */
    cursor?: freelancerzyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freelancerzies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freelancerzies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of freelancerzies.
     */
    distinct?: FreelancerzyScalarFieldEnum | FreelancerzyScalarFieldEnum[]
  }

  /**
   * freelancerzy findFirstOrThrow
   */
  export type freelancerzyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * Filter, which freelancerzy to fetch.
     */
    where?: freelancerzyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freelancerzies to fetch.
     */
    orderBy?: freelancerzyOrderByWithRelationInput | freelancerzyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for freelancerzies.
     */
    cursor?: freelancerzyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freelancerzies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freelancerzies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of freelancerzies.
     */
    distinct?: FreelancerzyScalarFieldEnum | FreelancerzyScalarFieldEnum[]
  }

  /**
   * freelancerzy findMany
   */
  export type freelancerzyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * Filter, which freelancerzies to fetch.
     */
    where?: freelancerzyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freelancerzies to fetch.
     */
    orderBy?: freelancerzyOrderByWithRelationInput | freelancerzyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing freelancerzies.
     */
    cursor?: freelancerzyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freelancerzies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freelancerzies.
     */
    skip?: number
    distinct?: FreelancerzyScalarFieldEnum | FreelancerzyScalarFieldEnum[]
  }

  /**
   * freelancerzy create
   */
  export type freelancerzyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * The data needed to create a freelancerzy.
     */
    data: XOR<freelancerzyCreateInput, freelancerzyUncheckedCreateInput>
  }

  /**
   * freelancerzy createMany
   */
  export type freelancerzyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many freelancerzies.
     */
    data: freelancerzyCreateManyInput | freelancerzyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * freelancerzy createManyAndReturn
   */
  export type freelancerzyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * The data used to create many freelancerzies.
     */
    data: freelancerzyCreateManyInput | freelancerzyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * freelancerzy update
   */
  export type freelancerzyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * The data needed to update a freelancerzy.
     */
    data: XOR<freelancerzyUpdateInput, freelancerzyUncheckedUpdateInput>
    /**
     * Choose, which freelancerzy to update.
     */
    where: freelancerzyWhereUniqueInput
  }

  /**
   * freelancerzy updateMany
   */
  export type freelancerzyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update freelancerzies.
     */
    data: XOR<freelancerzyUpdateManyMutationInput, freelancerzyUncheckedUpdateManyInput>
    /**
     * Filter which freelancerzies to update
     */
    where?: freelancerzyWhereInput
    /**
     * Limit how many freelancerzies to update.
     */
    limit?: number
  }

  /**
   * freelancerzy updateManyAndReturn
   */
  export type freelancerzyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * The data used to update freelancerzies.
     */
    data: XOR<freelancerzyUpdateManyMutationInput, freelancerzyUncheckedUpdateManyInput>
    /**
     * Filter which freelancerzies to update
     */
    where?: freelancerzyWhereInput
    /**
     * Limit how many freelancerzies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * freelancerzy upsert
   */
  export type freelancerzyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * The filter to search for the freelancerzy to update in case it exists.
     */
    where: freelancerzyWhereUniqueInput
    /**
     * In case the freelancerzy found by the `where` argument doesn't exist, create a new freelancerzy with this data.
     */
    create: XOR<freelancerzyCreateInput, freelancerzyUncheckedCreateInput>
    /**
     * In case the freelancerzy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<freelancerzyUpdateInput, freelancerzyUncheckedUpdateInput>
  }

  /**
   * freelancerzy delete
   */
  export type freelancerzyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
    /**
     * Filter which freelancerzy to delete.
     */
    where: freelancerzyWhereUniqueInput
  }

  /**
   * freelancerzy deleteMany
   */
  export type freelancerzyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which freelancerzies to delete
     */
    where?: freelancerzyWhereInput
    /**
     * Limit how many freelancerzies to delete.
     */
    limit?: number
  }

  /**
   * freelancerzy without action
   */
  export type freelancerzyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freelancerzy
     */
    select?: freelancerzySelect<ExtArgs> | null
    /**
     * Omit specific fields from the freelancerzy
     */
    omit?: freelancerzyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: freelancerzyInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UzytkownicyScalarFieldEnum: {
    id: 'id',
    imie: 'imie',
    nazwisko: 'nazwisko',
    email: 'email',
    haslo: 'haslo',
    rola_id: 'rola_id',
    data_rejestracji: 'data_rejestracji'
  };

  export type UzytkownicyScalarFieldEnum = (typeof UzytkownicyScalarFieldEnum)[keyof typeof UzytkownicyScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ArtykulyScalarFieldEnum: {
    id: 'id',
    tytul: 'tytul',
    tresc: 'tresc',
    data_publikacji: 'data_publikacji',
    autor_id: 'autor_id',
    kategoria_id: 'kategoria_id'
  };

  export type ArtykulyScalarFieldEnum = (typeof ArtykulyScalarFieldEnum)[keyof typeof ArtykulyScalarFieldEnum]


  export const KategorieartykulowScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type KategorieartykulowScalarFieldEnum = (typeof KategorieartykulowScalarFieldEnum)[keyof typeof KategorieartykulowScalarFieldEnum]


  export const ProduktyScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa',
    opis: 'opis',
    producent_id: 'producent_id',
    cena: 'cena',
    kategoria_id: 'kategoria_id',
    data_dodania: 'data_dodania'
  };

  export type ProduktyScalarFieldEnum = (typeof ProduktyScalarFieldEnum)[keyof typeof ProduktyScalarFieldEnum]


  export const KategorieproduktowScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type KategorieproduktowScalarFieldEnum = (typeof KategorieproduktowScalarFieldEnum)[keyof typeof KategorieproduktowScalarFieldEnum]


  export const ZamowieniaScalarFieldEnum: {
    id: 'id',
    uzytkownik_id: 'uzytkownik_id',
    produkt_id: 'produkt_id',
    ilosc: 'ilosc',
    data_zamowienia: 'data_zamowienia',
    status_id: 'status_id'
  };

  export type ZamowieniaScalarFieldEnum = (typeof ZamowieniaScalarFieldEnum)[keyof typeof ZamowieniaScalarFieldEnum]


  export const StatusyzamowienScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type StatusyzamowienScalarFieldEnum = (typeof StatusyzamowienScalarFieldEnum)[keyof typeof StatusyzamowienScalarFieldEnum]


  export const ZleceniaScalarFieldEnum: {
    id: 'id',
    tytul: 'tytul',
    opis: 'opis',
    zleceniodawca_id: 'zleceniodawca_id',
    wykonawca_id: 'wykonawca_id',
    data_utworzenia: 'data_utworzenia',
    status_id: 'status_id',
    typ_id: 'typ_id'
  };

  export type ZleceniaScalarFieldEnum = (typeof ZleceniaScalarFieldEnum)[keyof typeof ZleceniaScalarFieldEnum]


  export const StatusyzlecenScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type StatusyzlecenScalarFieldEnum = (typeof StatusyzlecenScalarFieldEnum)[keyof typeof StatusyzlecenScalarFieldEnum]


  export const TypyzlecenScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type TypyzlecenScalarFieldEnum = (typeof TypyzlecenScalarFieldEnum)[keyof typeof TypyzlecenScalarFieldEnum]


  export const ProjektyScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa',
    opis: 'opis',
    autor_id: 'autor_id',
    data_utworzenia: 'data_utworzenia',
    status_id: 'status_id'
  };

  export type ProjektyScalarFieldEnum = (typeof ProjektyScalarFieldEnum)[keyof typeof ProjektyScalarFieldEnum]


  export const StatusyprojektowScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type StatusyprojektowScalarFieldEnum = (typeof StatusyprojektowScalarFieldEnum)[keyof typeof StatusyprojektowScalarFieldEnum]


  export const ProducentkatalogScalarFieldEnum: {
    id: 'id',
    producent_id: 'producent_id',
    opis: 'opis',
    strona_www: 'strona_www',
    kategoria_id: 'kategoria_id'
  };

  export type ProducentkatalogScalarFieldEnum = (typeof ProducentkatalogScalarFieldEnum)[keyof typeof ProducentkatalogScalarFieldEnum]


  export const KategorieproducentowScalarFieldEnum: {
    id: 'id',
    nazwa: 'nazwa'
  };

  export type KategorieproducentowScalarFieldEnum = (typeof KategorieproducentowScalarFieldEnum)[keyof typeof KategorieproducentowScalarFieldEnum]


  export const PodwykonawcyScalarFieldEnum: {
    id: 'id',
    uzytkownik_id: 'uzytkownik_id',
    specjalizacja: 'specjalizacja',
    opis: 'opis',
    kontakt: 'kontakt'
  };

  export type PodwykonawcyScalarFieldEnum = (typeof PodwykonawcyScalarFieldEnum)[keyof typeof PodwykonawcyScalarFieldEnum]


  export const FreelancerzyScalarFieldEnum: {
    id: 'id',
    uzytkownik_id: 'uzytkownik_id',
    specjalizacja: 'specjalizacja',
    opis: 'opis',
    kontakt: 'kontakt'
  };

  export type FreelancerzyScalarFieldEnum = (typeof FreelancerzyScalarFieldEnum)[keyof typeof FreelancerzyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type uzytkownicyWhereInput = {
    AND?: uzytkownicyWhereInput | uzytkownicyWhereInput[]
    OR?: uzytkownicyWhereInput[]
    NOT?: uzytkownicyWhereInput | uzytkownicyWhereInput[]
    id?: IntFilter<"uzytkownicy"> | number
    imie?: StringNullableFilter<"uzytkownicy"> | string | null
    nazwisko?: StringNullableFilter<"uzytkownicy"> | string | null
    email?: StringFilter<"uzytkownicy"> | string
    haslo?: StringFilter<"uzytkownicy"> | string
    rola_id?: IntFilter<"uzytkownicy"> | number
    data_rejestracji?: DateTimeNullableFilter<"uzytkownicy"> | Date | string | null
    rola?: XOR<RoleScalarRelationFilter, roleWhereInput>
    artykuly?: ArtykulyListRelationFilter
    produkty?: ProduktyListRelationFilter
    zamowienia?: ZamowieniaListRelationFilter
    zlecenia_zleceniodawca?: ZleceniaListRelationFilter
    zlecenia_wykonawca?: ZleceniaListRelationFilter
    projekty?: ProjektyListRelationFilter
    producent_katalog?: ProducentkatalogListRelationFilter
    podwykonawcy?: XOR<PodwykonawcyNullableScalarRelationFilter, podwykonawcyWhereInput> | null
    freelancerzy?: XOR<FreelancerzyNullableScalarRelationFilter, freelancerzyWhereInput> | null
  }

  export type uzytkownicyOrderByWithRelationInput = {
    id?: SortOrder
    imie?: SortOrderInput | SortOrder
    nazwisko?: SortOrderInput | SortOrder
    email?: SortOrder
    haslo?: SortOrder
    rola_id?: SortOrder
    data_rejestracji?: SortOrderInput | SortOrder
    rola?: roleOrderByWithRelationInput
    artykuly?: artykulyOrderByRelationAggregateInput
    produkty?: produktyOrderByRelationAggregateInput
    zamowienia?: zamowieniaOrderByRelationAggregateInput
    zlecenia_zleceniodawca?: zleceniaOrderByRelationAggregateInput
    zlecenia_wykonawca?: zleceniaOrderByRelationAggregateInput
    projekty?: projektyOrderByRelationAggregateInput
    producent_katalog?: producentkatalogOrderByRelationAggregateInput
    podwykonawcy?: podwykonawcyOrderByWithRelationInput
    freelancerzy?: freelancerzyOrderByWithRelationInput
  }

  export type uzytkownicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: uzytkownicyWhereInput | uzytkownicyWhereInput[]
    OR?: uzytkownicyWhereInput[]
    NOT?: uzytkownicyWhereInput | uzytkownicyWhereInput[]
    imie?: StringNullableFilter<"uzytkownicy"> | string | null
    nazwisko?: StringNullableFilter<"uzytkownicy"> | string | null
    haslo?: StringFilter<"uzytkownicy"> | string
    rola_id?: IntFilter<"uzytkownicy"> | number
    data_rejestracji?: DateTimeNullableFilter<"uzytkownicy"> | Date | string | null
    rola?: XOR<RoleScalarRelationFilter, roleWhereInput>
    artykuly?: ArtykulyListRelationFilter
    produkty?: ProduktyListRelationFilter
    zamowienia?: ZamowieniaListRelationFilter
    zlecenia_zleceniodawca?: ZleceniaListRelationFilter
    zlecenia_wykonawca?: ZleceniaListRelationFilter
    projekty?: ProjektyListRelationFilter
    producent_katalog?: ProducentkatalogListRelationFilter
    podwykonawcy?: XOR<PodwykonawcyNullableScalarRelationFilter, podwykonawcyWhereInput> | null
    freelancerzy?: XOR<FreelancerzyNullableScalarRelationFilter, freelancerzyWhereInput> | null
  }, "id" | "email">

  export type uzytkownicyOrderByWithAggregationInput = {
    id?: SortOrder
    imie?: SortOrderInput | SortOrder
    nazwisko?: SortOrderInput | SortOrder
    email?: SortOrder
    haslo?: SortOrder
    rola_id?: SortOrder
    data_rejestracji?: SortOrderInput | SortOrder
    _count?: uzytkownicyCountOrderByAggregateInput
    _avg?: uzytkownicyAvgOrderByAggregateInput
    _max?: uzytkownicyMaxOrderByAggregateInput
    _min?: uzytkownicyMinOrderByAggregateInput
    _sum?: uzytkownicySumOrderByAggregateInput
  }

  export type uzytkownicyScalarWhereWithAggregatesInput = {
    AND?: uzytkownicyScalarWhereWithAggregatesInput | uzytkownicyScalarWhereWithAggregatesInput[]
    OR?: uzytkownicyScalarWhereWithAggregatesInput[]
    NOT?: uzytkownicyScalarWhereWithAggregatesInput | uzytkownicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"uzytkownicy"> | number
    imie?: StringNullableWithAggregatesFilter<"uzytkownicy"> | string | null
    nazwisko?: StringNullableWithAggregatesFilter<"uzytkownicy"> | string | null
    email?: StringWithAggregatesFilter<"uzytkownicy"> | string
    haslo?: StringWithAggregatesFilter<"uzytkownicy"> | string
    rola_id?: IntWithAggregatesFilter<"uzytkownicy"> | number
    data_rejestracji?: DateTimeNullableWithAggregatesFilter<"uzytkownicy"> | Date | string | null
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: IntFilter<"role"> | number
    nazwa?: StringFilter<"role"> | string
    uzytkownicy?: UzytkownicyListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    uzytkownicy?: uzytkownicyOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    uzytkownicy?: UzytkownicyListRelationFilter
  }, "id" | "nazwa">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"role"> | number
    nazwa?: StringWithAggregatesFilter<"role"> | string
  }

  export type artykulyWhereInput = {
    AND?: artykulyWhereInput | artykulyWhereInput[]
    OR?: artykulyWhereInput[]
    NOT?: artykulyWhereInput | artykulyWhereInput[]
    id?: IntFilter<"artykuly"> | number
    tytul?: StringNullableFilter<"artykuly"> | string | null
    tresc?: StringNullableFilter<"artykuly"> | string | null
    data_publikacji?: DateTimeNullableFilter<"artykuly"> | Date | string | null
    autor_id?: IntFilter<"artykuly"> | number
    kategoria_id?: IntFilter<"artykuly"> | number
    autor?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    kategoria?: XOR<KategorieartykulowScalarRelationFilter, kategorieartykulowWhereInput>
  }

  export type artykulyOrderByWithRelationInput = {
    id?: SortOrder
    tytul?: SortOrderInput | SortOrder
    tresc?: SortOrderInput | SortOrder
    data_publikacji?: SortOrderInput | SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
    autor?: uzytkownicyOrderByWithRelationInput
    kategoria?: kategorieartykulowOrderByWithRelationInput
  }

  export type artykulyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: artykulyWhereInput | artykulyWhereInput[]
    OR?: artykulyWhereInput[]
    NOT?: artykulyWhereInput | artykulyWhereInput[]
    tytul?: StringNullableFilter<"artykuly"> | string | null
    tresc?: StringNullableFilter<"artykuly"> | string | null
    data_publikacji?: DateTimeNullableFilter<"artykuly"> | Date | string | null
    autor_id?: IntFilter<"artykuly"> | number
    kategoria_id?: IntFilter<"artykuly"> | number
    autor?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    kategoria?: XOR<KategorieartykulowScalarRelationFilter, kategorieartykulowWhereInput>
  }, "id">

  export type artykulyOrderByWithAggregationInput = {
    id?: SortOrder
    tytul?: SortOrderInput | SortOrder
    tresc?: SortOrderInput | SortOrder
    data_publikacji?: SortOrderInput | SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
    _count?: artykulyCountOrderByAggregateInput
    _avg?: artykulyAvgOrderByAggregateInput
    _max?: artykulyMaxOrderByAggregateInput
    _min?: artykulyMinOrderByAggregateInput
    _sum?: artykulySumOrderByAggregateInput
  }

  export type artykulyScalarWhereWithAggregatesInput = {
    AND?: artykulyScalarWhereWithAggregatesInput | artykulyScalarWhereWithAggregatesInput[]
    OR?: artykulyScalarWhereWithAggregatesInput[]
    NOT?: artykulyScalarWhereWithAggregatesInput | artykulyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"artykuly"> | number
    tytul?: StringNullableWithAggregatesFilter<"artykuly"> | string | null
    tresc?: StringNullableWithAggregatesFilter<"artykuly"> | string | null
    data_publikacji?: DateTimeNullableWithAggregatesFilter<"artykuly"> | Date | string | null
    autor_id?: IntWithAggregatesFilter<"artykuly"> | number
    kategoria_id?: IntWithAggregatesFilter<"artykuly"> | number
  }

  export type kategorieartykulowWhereInput = {
    AND?: kategorieartykulowWhereInput | kategorieartykulowWhereInput[]
    OR?: kategorieartykulowWhereInput[]
    NOT?: kategorieartykulowWhereInput | kategorieartykulowWhereInput[]
    id?: IntFilter<"kategorieartykulow"> | number
    nazwa?: StringFilter<"kategorieartykulow"> | string
    artykuly?: ArtykulyListRelationFilter
  }

  export type kategorieartykulowOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    artykuly?: artykulyOrderByRelationAggregateInput
  }

  export type kategorieartykulowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: kategorieartykulowWhereInput | kategorieartykulowWhereInput[]
    OR?: kategorieartykulowWhereInput[]
    NOT?: kategorieartykulowWhereInput | kategorieartykulowWhereInput[]
    artykuly?: ArtykulyListRelationFilter
  }, "id" | "nazwa">

  export type kategorieartykulowOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: kategorieartykulowCountOrderByAggregateInput
    _avg?: kategorieartykulowAvgOrderByAggregateInput
    _max?: kategorieartykulowMaxOrderByAggregateInput
    _min?: kategorieartykulowMinOrderByAggregateInput
    _sum?: kategorieartykulowSumOrderByAggregateInput
  }

  export type kategorieartykulowScalarWhereWithAggregatesInput = {
    AND?: kategorieartykulowScalarWhereWithAggregatesInput | kategorieartykulowScalarWhereWithAggregatesInput[]
    OR?: kategorieartykulowScalarWhereWithAggregatesInput[]
    NOT?: kategorieartykulowScalarWhereWithAggregatesInput | kategorieartykulowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kategorieartykulow"> | number
    nazwa?: StringWithAggregatesFilter<"kategorieartykulow"> | string
  }

  export type produktyWhereInput = {
    AND?: produktyWhereInput | produktyWhereInput[]
    OR?: produktyWhereInput[]
    NOT?: produktyWhereInput | produktyWhereInput[]
    id?: IntFilter<"produkty"> | number
    nazwa?: StringNullableFilter<"produkty"> | string | null
    opis?: StringNullableFilter<"produkty"> | string | null
    producent_id?: IntFilter<"produkty"> | number
    cena?: DecimalNullableFilter<"produkty"> | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFilter<"produkty"> | number
    data_dodania?: DateTimeNullableFilter<"produkty"> | Date | string | null
    producent?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    kategoria?: XOR<KategorieproduktowScalarRelationFilter, kategorieproduktowWhereInput>
    zamowienia?: ZamowieniaListRelationFilter
  }

  export type produktyOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    producent_id?: SortOrder
    cena?: SortOrderInput | SortOrder
    kategoria_id?: SortOrder
    data_dodania?: SortOrderInput | SortOrder
    producent?: uzytkownicyOrderByWithRelationInput
    kategoria?: kategorieproduktowOrderByWithRelationInput
    zamowienia?: zamowieniaOrderByRelationAggregateInput
  }

  export type produktyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: produktyWhereInput | produktyWhereInput[]
    OR?: produktyWhereInput[]
    NOT?: produktyWhereInput | produktyWhereInput[]
    nazwa?: StringNullableFilter<"produkty"> | string | null
    opis?: StringNullableFilter<"produkty"> | string | null
    producent_id?: IntFilter<"produkty"> | number
    cena?: DecimalNullableFilter<"produkty"> | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFilter<"produkty"> | number
    data_dodania?: DateTimeNullableFilter<"produkty"> | Date | string | null
    producent?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    kategoria?: XOR<KategorieproduktowScalarRelationFilter, kategorieproduktowWhereInput>
    zamowienia?: ZamowieniaListRelationFilter
  }, "id">

  export type produktyOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    producent_id?: SortOrder
    cena?: SortOrderInput | SortOrder
    kategoria_id?: SortOrder
    data_dodania?: SortOrderInput | SortOrder
    _count?: produktyCountOrderByAggregateInput
    _avg?: produktyAvgOrderByAggregateInput
    _max?: produktyMaxOrderByAggregateInput
    _min?: produktyMinOrderByAggregateInput
    _sum?: produktySumOrderByAggregateInput
  }

  export type produktyScalarWhereWithAggregatesInput = {
    AND?: produktyScalarWhereWithAggregatesInput | produktyScalarWhereWithAggregatesInput[]
    OR?: produktyScalarWhereWithAggregatesInput[]
    NOT?: produktyScalarWhereWithAggregatesInput | produktyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"produkty"> | number
    nazwa?: StringNullableWithAggregatesFilter<"produkty"> | string | null
    opis?: StringNullableWithAggregatesFilter<"produkty"> | string | null
    producent_id?: IntWithAggregatesFilter<"produkty"> | number
    cena?: DecimalNullableWithAggregatesFilter<"produkty"> | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntWithAggregatesFilter<"produkty"> | number
    data_dodania?: DateTimeNullableWithAggregatesFilter<"produkty"> | Date | string | null
  }

  export type kategorieproduktowWhereInput = {
    AND?: kategorieproduktowWhereInput | kategorieproduktowWhereInput[]
    OR?: kategorieproduktowWhereInput[]
    NOT?: kategorieproduktowWhereInput | kategorieproduktowWhereInput[]
    id?: IntFilter<"kategorieproduktow"> | number
    nazwa?: StringFilter<"kategorieproduktow"> | string
    produkty?: ProduktyListRelationFilter
  }

  export type kategorieproduktowOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    produkty?: produktyOrderByRelationAggregateInput
  }

  export type kategorieproduktowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: kategorieproduktowWhereInput | kategorieproduktowWhereInput[]
    OR?: kategorieproduktowWhereInput[]
    NOT?: kategorieproduktowWhereInput | kategorieproduktowWhereInput[]
    produkty?: ProduktyListRelationFilter
  }, "id" | "nazwa">

  export type kategorieproduktowOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: kategorieproduktowCountOrderByAggregateInput
    _avg?: kategorieproduktowAvgOrderByAggregateInput
    _max?: kategorieproduktowMaxOrderByAggregateInput
    _min?: kategorieproduktowMinOrderByAggregateInput
    _sum?: kategorieproduktowSumOrderByAggregateInput
  }

  export type kategorieproduktowScalarWhereWithAggregatesInput = {
    AND?: kategorieproduktowScalarWhereWithAggregatesInput | kategorieproduktowScalarWhereWithAggregatesInput[]
    OR?: kategorieproduktowScalarWhereWithAggregatesInput[]
    NOT?: kategorieproduktowScalarWhereWithAggregatesInput | kategorieproduktowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kategorieproduktow"> | number
    nazwa?: StringWithAggregatesFilter<"kategorieproduktow"> | string
  }

  export type zamowieniaWhereInput = {
    AND?: zamowieniaWhereInput | zamowieniaWhereInput[]
    OR?: zamowieniaWhereInput[]
    NOT?: zamowieniaWhereInput | zamowieniaWhereInput[]
    id?: IntFilter<"zamowienia"> | number
    uzytkownik_id?: IntFilter<"zamowienia"> | number
    produkt_id?: IntFilter<"zamowienia"> | number
    ilosc?: IntNullableFilter<"zamowienia"> | number | null
    data_zamowienia?: DateTimeNullableFilter<"zamowienia"> | Date | string | null
    status_id?: IntFilter<"zamowienia"> | number
    uzytkownik?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    produkt?: XOR<ProduktyScalarRelationFilter, produktyWhereInput>
    status?: XOR<StatusyzamowienScalarRelationFilter, statusyzamowienWhereInput>
  }

  export type zamowieniaOrderByWithRelationInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrderInput | SortOrder
    data_zamowienia?: SortOrderInput | SortOrder
    status_id?: SortOrder
    uzytkownik?: uzytkownicyOrderByWithRelationInput
    produkt?: produktyOrderByWithRelationInput
    status?: statusyzamowienOrderByWithRelationInput
  }

  export type zamowieniaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: zamowieniaWhereInput | zamowieniaWhereInput[]
    OR?: zamowieniaWhereInput[]
    NOT?: zamowieniaWhereInput | zamowieniaWhereInput[]
    uzytkownik_id?: IntFilter<"zamowienia"> | number
    produkt_id?: IntFilter<"zamowienia"> | number
    ilosc?: IntNullableFilter<"zamowienia"> | number | null
    data_zamowienia?: DateTimeNullableFilter<"zamowienia"> | Date | string | null
    status_id?: IntFilter<"zamowienia"> | number
    uzytkownik?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    produkt?: XOR<ProduktyScalarRelationFilter, produktyWhereInput>
    status?: XOR<StatusyzamowienScalarRelationFilter, statusyzamowienWhereInput>
  }, "id">

  export type zamowieniaOrderByWithAggregationInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrderInput | SortOrder
    data_zamowienia?: SortOrderInput | SortOrder
    status_id?: SortOrder
    _count?: zamowieniaCountOrderByAggregateInput
    _avg?: zamowieniaAvgOrderByAggregateInput
    _max?: zamowieniaMaxOrderByAggregateInput
    _min?: zamowieniaMinOrderByAggregateInput
    _sum?: zamowieniaSumOrderByAggregateInput
  }

  export type zamowieniaScalarWhereWithAggregatesInput = {
    AND?: zamowieniaScalarWhereWithAggregatesInput | zamowieniaScalarWhereWithAggregatesInput[]
    OR?: zamowieniaScalarWhereWithAggregatesInput[]
    NOT?: zamowieniaScalarWhereWithAggregatesInput | zamowieniaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zamowienia"> | number
    uzytkownik_id?: IntWithAggregatesFilter<"zamowienia"> | number
    produkt_id?: IntWithAggregatesFilter<"zamowienia"> | number
    ilosc?: IntNullableWithAggregatesFilter<"zamowienia"> | number | null
    data_zamowienia?: DateTimeNullableWithAggregatesFilter<"zamowienia"> | Date | string | null
    status_id?: IntWithAggregatesFilter<"zamowienia"> | number
  }

  export type statusyzamowienWhereInput = {
    AND?: statusyzamowienWhereInput | statusyzamowienWhereInput[]
    OR?: statusyzamowienWhereInput[]
    NOT?: statusyzamowienWhereInput | statusyzamowienWhereInput[]
    id?: IntFilter<"statusyzamowien"> | number
    nazwa?: StringFilter<"statusyzamowien"> | string
    zamowienia?: ZamowieniaListRelationFilter
  }

  export type statusyzamowienOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    zamowienia?: zamowieniaOrderByRelationAggregateInput
  }

  export type statusyzamowienWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: statusyzamowienWhereInput | statusyzamowienWhereInput[]
    OR?: statusyzamowienWhereInput[]
    NOT?: statusyzamowienWhereInput | statusyzamowienWhereInput[]
    zamowienia?: ZamowieniaListRelationFilter
  }, "id" | "nazwa">

  export type statusyzamowienOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: statusyzamowienCountOrderByAggregateInput
    _avg?: statusyzamowienAvgOrderByAggregateInput
    _max?: statusyzamowienMaxOrderByAggregateInput
    _min?: statusyzamowienMinOrderByAggregateInput
    _sum?: statusyzamowienSumOrderByAggregateInput
  }

  export type statusyzamowienScalarWhereWithAggregatesInput = {
    AND?: statusyzamowienScalarWhereWithAggregatesInput | statusyzamowienScalarWhereWithAggregatesInput[]
    OR?: statusyzamowienScalarWhereWithAggregatesInput[]
    NOT?: statusyzamowienScalarWhereWithAggregatesInput | statusyzamowienScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"statusyzamowien"> | number
    nazwa?: StringWithAggregatesFilter<"statusyzamowien"> | string
  }

  export type zleceniaWhereInput = {
    AND?: zleceniaWhereInput | zleceniaWhereInput[]
    OR?: zleceniaWhereInput[]
    NOT?: zleceniaWhereInput | zleceniaWhereInput[]
    id?: IntFilter<"zlecenia"> | number
    tytul?: StringNullableFilter<"zlecenia"> | string | null
    opis?: StringNullableFilter<"zlecenia"> | string | null
    zleceniodawca_id?: IntFilter<"zlecenia"> | number
    wykonawca_id?: IntFilter<"zlecenia"> | number
    data_utworzenia?: DateTimeNullableFilter<"zlecenia"> | Date | string | null
    status_id?: IntFilter<"zlecenia"> | number
    typ_id?: IntFilter<"zlecenia"> | number
    zleceniodawca?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    wykonawca?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    status?: XOR<StatusyzlecenScalarRelationFilter, statusyzlecenWhereInput>
    typ?: XOR<TypyzlecenScalarRelationFilter, typyzlecenWhereInput>
  }

  export type zleceniaOrderByWithRelationInput = {
    id?: SortOrder
    tytul?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    data_utworzenia?: SortOrderInput | SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
    zleceniodawca?: uzytkownicyOrderByWithRelationInput
    wykonawca?: uzytkownicyOrderByWithRelationInput
    status?: statusyzlecenOrderByWithRelationInput
    typ?: typyzlecenOrderByWithRelationInput
  }

  export type zleceniaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: zleceniaWhereInput | zleceniaWhereInput[]
    OR?: zleceniaWhereInput[]
    NOT?: zleceniaWhereInput | zleceniaWhereInput[]
    tytul?: StringNullableFilter<"zlecenia"> | string | null
    opis?: StringNullableFilter<"zlecenia"> | string | null
    zleceniodawca_id?: IntFilter<"zlecenia"> | number
    wykonawca_id?: IntFilter<"zlecenia"> | number
    data_utworzenia?: DateTimeNullableFilter<"zlecenia"> | Date | string | null
    status_id?: IntFilter<"zlecenia"> | number
    typ_id?: IntFilter<"zlecenia"> | number
    zleceniodawca?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    wykonawca?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    status?: XOR<StatusyzlecenScalarRelationFilter, statusyzlecenWhereInput>
    typ?: XOR<TypyzlecenScalarRelationFilter, typyzlecenWhereInput>
  }, "id">

  export type zleceniaOrderByWithAggregationInput = {
    id?: SortOrder
    tytul?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    data_utworzenia?: SortOrderInput | SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
    _count?: zleceniaCountOrderByAggregateInput
    _avg?: zleceniaAvgOrderByAggregateInput
    _max?: zleceniaMaxOrderByAggregateInput
    _min?: zleceniaMinOrderByAggregateInput
    _sum?: zleceniaSumOrderByAggregateInput
  }

  export type zleceniaScalarWhereWithAggregatesInput = {
    AND?: zleceniaScalarWhereWithAggregatesInput | zleceniaScalarWhereWithAggregatesInput[]
    OR?: zleceniaScalarWhereWithAggregatesInput[]
    NOT?: zleceniaScalarWhereWithAggregatesInput | zleceniaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zlecenia"> | number
    tytul?: StringNullableWithAggregatesFilter<"zlecenia"> | string | null
    opis?: StringNullableWithAggregatesFilter<"zlecenia"> | string | null
    zleceniodawca_id?: IntWithAggregatesFilter<"zlecenia"> | number
    wykonawca_id?: IntWithAggregatesFilter<"zlecenia"> | number
    data_utworzenia?: DateTimeNullableWithAggregatesFilter<"zlecenia"> | Date | string | null
    status_id?: IntWithAggregatesFilter<"zlecenia"> | number
    typ_id?: IntWithAggregatesFilter<"zlecenia"> | number
  }

  export type statusyzlecenWhereInput = {
    AND?: statusyzlecenWhereInput | statusyzlecenWhereInput[]
    OR?: statusyzlecenWhereInput[]
    NOT?: statusyzlecenWhereInput | statusyzlecenWhereInput[]
    id?: IntFilter<"statusyzlecen"> | number
    nazwa?: StringFilter<"statusyzlecen"> | string
    zlecenia?: ZleceniaListRelationFilter
  }

  export type statusyzlecenOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    zlecenia?: zleceniaOrderByRelationAggregateInput
  }

  export type statusyzlecenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: statusyzlecenWhereInput | statusyzlecenWhereInput[]
    OR?: statusyzlecenWhereInput[]
    NOT?: statusyzlecenWhereInput | statusyzlecenWhereInput[]
    zlecenia?: ZleceniaListRelationFilter
  }, "id" | "nazwa">

  export type statusyzlecenOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: statusyzlecenCountOrderByAggregateInput
    _avg?: statusyzlecenAvgOrderByAggregateInput
    _max?: statusyzlecenMaxOrderByAggregateInput
    _min?: statusyzlecenMinOrderByAggregateInput
    _sum?: statusyzlecenSumOrderByAggregateInput
  }

  export type statusyzlecenScalarWhereWithAggregatesInput = {
    AND?: statusyzlecenScalarWhereWithAggregatesInput | statusyzlecenScalarWhereWithAggregatesInput[]
    OR?: statusyzlecenScalarWhereWithAggregatesInput[]
    NOT?: statusyzlecenScalarWhereWithAggregatesInput | statusyzlecenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"statusyzlecen"> | number
    nazwa?: StringWithAggregatesFilter<"statusyzlecen"> | string
  }

  export type typyzlecenWhereInput = {
    AND?: typyzlecenWhereInput | typyzlecenWhereInput[]
    OR?: typyzlecenWhereInput[]
    NOT?: typyzlecenWhereInput | typyzlecenWhereInput[]
    id?: IntFilter<"typyzlecen"> | number
    nazwa?: StringFilter<"typyzlecen"> | string
    zlecenia?: ZleceniaListRelationFilter
  }

  export type typyzlecenOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    zlecenia?: zleceniaOrderByRelationAggregateInput
  }

  export type typyzlecenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: typyzlecenWhereInput | typyzlecenWhereInput[]
    OR?: typyzlecenWhereInput[]
    NOT?: typyzlecenWhereInput | typyzlecenWhereInput[]
    zlecenia?: ZleceniaListRelationFilter
  }, "id" | "nazwa">

  export type typyzlecenOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: typyzlecenCountOrderByAggregateInput
    _avg?: typyzlecenAvgOrderByAggregateInput
    _max?: typyzlecenMaxOrderByAggregateInput
    _min?: typyzlecenMinOrderByAggregateInput
    _sum?: typyzlecenSumOrderByAggregateInput
  }

  export type typyzlecenScalarWhereWithAggregatesInput = {
    AND?: typyzlecenScalarWhereWithAggregatesInput | typyzlecenScalarWhereWithAggregatesInput[]
    OR?: typyzlecenScalarWhereWithAggregatesInput[]
    NOT?: typyzlecenScalarWhereWithAggregatesInput | typyzlecenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"typyzlecen"> | number
    nazwa?: StringWithAggregatesFilter<"typyzlecen"> | string
  }

  export type projektyWhereInput = {
    AND?: projektyWhereInput | projektyWhereInput[]
    OR?: projektyWhereInput[]
    NOT?: projektyWhereInput | projektyWhereInput[]
    id?: IntFilter<"projekty"> | number
    nazwa?: StringNullableFilter<"projekty"> | string | null
    opis?: StringNullableFilter<"projekty"> | string | null
    autor_id?: IntFilter<"projekty"> | number
    data_utworzenia?: DateTimeNullableFilter<"projekty"> | Date | string | null
    status_id?: IntFilter<"projekty"> | number
    autor?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    status?: XOR<StatusyprojektowScalarRelationFilter, statusyprojektowWhereInput>
  }

  export type projektyOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    autor_id?: SortOrder
    data_utworzenia?: SortOrderInput | SortOrder
    status_id?: SortOrder
    autor?: uzytkownicyOrderByWithRelationInput
    status?: statusyprojektowOrderByWithRelationInput
  }

  export type projektyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: projektyWhereInput | projektyWhereInput[]
    OR?: projektyWhereInput[]
    NOT?: projektyWhereInput | projektyWhereInput[]
    nazwa?: StringNullableFilter<"projekty"> | string | null
    opis?: StringNullableFilter<"projekty"> | string | null
    autor_id?: IntFilter<"projekty"> | number
    data_utworzenia?: DateTimeNullableFilter<"projekty"> | Date | string | null
    status_id?: IntFilter<"projekty"> | number
    autor?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    status?: XOR<StatusyprojektowScalarRelationFilter, statusyprojektowWhereInput>
  }, "id">

  export type projektyOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    autor_id?: SortOrder
    data_utworzenia?: SortOrderInput | SortOrder
    status_id?: SortOrder
    _count?: projektyCountOrderByAggregateInput
    _avg?: projektyAvgOrderByAggregateInput
    _max?: projektyMaxOrderByAggregateInput
    _min?: projektyMinOrderByAggregateInput
    _sum?: projektySumOrderByAggregateInput
  }

  export type projektyScalarWhereWithAggregatesInput = {
    AND?: projektyScalarWhereWithAggregatesInput | projektyScalarWhereWithAggregatesInput[]
    OR?: projektyScalarWhereWithAggregatesInput[]
    NOT?: projektyScalarWhereWithAggregatesInput | projektyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projekty"> | number
    nazwa?: StringNullableWithAggregatesFilter<"projekty"> | string | null
    opis?: StringNullableWithAggregatesFilter<"projekty"> | string | null
    autor_id?: IntWithAggregatesFilter<"projekty"> | number
    data_utworzenia?: DateTimeNullableWithAggregatesFilter<"projekty"> | Date | string | null
    status_id?: IntWithAggregatesFilter<"projekty"> | number
  }

  export type statusyprojektowWhereInput = {
    AND?: statusyprojektowWhereInput | statusyprojektowWhereInput[]
    OR?: statusyprojektowWhereInput[]
    NOT?: statusyprojektowWhereInput | statusyprojektowWhereInput[]
    id?: IntFilter<"statusyprojektow"> | number
    nazwa?: StringFilter<"statusyprojektow"> | string
    projekty?: ProjektyListRelationFilter
  }

  export type statusyprojektowOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    projekty?: projektyOrderByRelationAggregateInput
  }

  export type statusyprojektowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: statusyprojektowWhereInput | statusyprojektowWhereInput[]
    OR?: statusyprojektowWhereInput[]
    NOT?: statusyprojektowWhereInput | statusyprojektowWhereInput[]
    projekty?: ProjektyListRelationFilter
  }, "id" | "nazwa">

  export type statusyprojektowOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: statusyprojektowCountOrderByAggregateInput
    _avg?: statusyprojektowAvgOrderByAggregateInput
    _max?: statusyprojektowMaxOrderByAggregateInput
    _min?: statusyprojektowMinOrderByAggregateInput
    _sum?: statusyprojektowSumOrderByAggregateInput
  }

  export type statusyprojektowScalarWhereWithAggregatesInput = {
    AND?: statusyprojektowScalarWhereWithAggregatesInput | statusyprojektowScalarWhereWithAggregatesInput[]
    OR?: statusyprojektowScalarWhereWithAggregatesInput[]
    NOT?: statusyprojektowScalarWhereWithAggregatesInput | statusyprojektowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"statusyprojektow"> | number
    nazwa?: StringWithAggregatesFilter<"statusyprojektow"> | string
  }

  export type producentkatalogWhereInput = {
    AND?: producentkatalogWhereInput | producentkatalogWhereInput[]
    OR?: producentkatalogWhereInput[]
    NOT?: producentkatalogWhereInput | producentkatalogWhereInput[]
    id?: IntFilter<"producentkatalog"> | number
    producent_id?: IntFilter<"producentkatalog"> | number
    opis?: StringNullableFilter<"producentkatalog"> | string | null
    strona_www?: StringNullableFilter<"producentkatalog"> | string | null
    kategoria_id?: IntFilter<"producentkatalog"> | number
    producent?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    kategoria?: XOR<KategorieproducentowScalarRelationFilter, kategorieproducentowWhereInput>
  }

  export type producentkatalogOrderByWithRelationInput = {
    id?: SortOrder
    producent_id?: SortOrder
    opis?: SortOrderInput | SortOrder
    strona_www?: SortOrderInput | SortOrder
    kategoria_id?: SortOrder
    producent?: uzytkownicyOrderByWithRelationInput
    kategoria?: kategorieproducentowOrderByWithRelationInput
  }

  export type producentkatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: producentkatalogWhereInput | producentkatalogWhereInput[]
    OR?: producentkatalogWhereInput[]
    NOT?: producentkatalogWhereInput | producentkatalogWhereInput[]
    producent_id?: IntFilter<"producentkatalog"> | number
    opis?: StringNullableFilter<"producentkatalog"> | string | null
    strona_www?: StringNullableFilter<"producentkatalog"> | string | null
    kategoria_id?: IntFilter<"producentkatalog"> | number
    producent?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
    kategoria?: XOR<KategorieproducentowScalarRelationFilter, kategorieproducentowWhereInput>
  }, "id">

  export type producentkatalogOrderByWithAggregationInput = {
    id?: SortOrder
    producent_id?: SortOrder
    opis?: SortOrderInput | SortOrder
    strona_www?: SortOrderInput | SortOrder
    kategoria_id?: SortOrder
    _count?: producentkatalogCountOrderByAggregateInput
    _avg?: producentkatalogAvgOrderByAggregateInput
    _max?: producentkatalogMaxOrderByAggregateInput
    _min?: producentkatalogMinOrderByAggregateInput
    _sum?: producentkatalogSumOrderByAggregateInput
  }

  export type producentkatalogScalarWhereWithAggregatesInput = {
    AND?: producentkatalogScalarWhereWithAggregatesInput | producentkatalogScalarWhereWithAggregatesInput[]
    OR?: producentkatalogScalarWhereWithAggregatesInput[]
    NOT?: producentkatalogScalarWhereWithAggregatesInput | producentkatalogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"producentkatalog"> | number
    producent_id?: IntWithAggregatesFilter<"producentkatalog"> | number
    opis?: StringNullableWithAggregatesFilter<"producentkatalog"> | string | null
    strona_www?: StringNullableWithAggregatesFilter<"producentkatalog"> | string | null
    kategoria_id?: IntWithAggregatesFilter<"producentkatalog"> | number
  }

  export type kategorieproducentowWhereInput = {
    AND?: kategorieproducentowWhereInput | kategorieproducentowWhereInput[]
    OR?: kategorieproducentowWhereInput[]
    NOT?: kategorieproducentowWhereInput | kategorieproducentowWhereInput[]
    id?: IntFilter<"kategorieproducentow"> | number
    nazwa?: StringFilter<"kategorieproducentow"> | string
    producentkatalog?: ProducentkatalogListRelationFilter
  }

  export type kategorieproducentowOrderByWithRelationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    producentkatalog?: producentkatalogOrderByRelationAggregateInput
  }

  export type kategorieproducentowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nazwa?: string
    AND?: kategorieproducentowWhereInput | kategorieproducentowWhereInput[]
    OR?: kategorieproducentowWhereInput[]
    NOT?: kategorieproducentowWhereInput | kategorieproducentowWhereInput[]
    producentkatalog?: ProducentkatalogListRelationFilter
  }, "id" | "nazwa">

  export type kategorieproducentowOrderByWithAggregationInput = {
    id?: SortOrder
    nazwa?: SortOrder
    _count?: kategorieproducentowCountOrderByAggregateInput
    _avg?: kategorieproducentowAvgOrderByAggregateInput
    _max?: kategorieproducentowMaxOrderByAggregateInput
    _min?: kategorieproducentowMinOrderByAggregateInput
    _sum?: kategorieproducentowSumOrderByAggregateInput
  }

  export type kategorieproducentowScalarWhereWithAggregatesInput = {
    AND?: kategorieproducentowScalarWhereWithAggregatesInput | kategorieproducentowScalarWhereWithAggregatesInput[]
    OR?: kategorieproducentowScalarWhereWithAggregatesInput[]
    NOT?: kategorieproducentowScalarWhereWithAggregatesInput | kategorieproducentowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kategorieproducentow"> | number
    nazwa?: StringWithAggregatesFilter<"kategorieproducentow"> | string
  }

  export type podwykonawcyWhereInput = {
    AND?: podwykonawcyWhereInput | podwykonawcyWhereInput[]
    OR?: podwykonawcyWhereInput[]
    NOT?: podwykonawcyWhereInput | podwykonawcyWhereInput[]
    id?: IntFilter<"podwykonawcy"> | number
    uzytkownik_id?: IntFilter<"podwykonawcy"> | number
    specjalizacja?: StringNullableFilter<"podwykonawcy"> | string | null
    opis?: StringNullableFilter<"podwykonawcy"> | string | null
    kontakt?: StringNullableFilter<"podwykonawcy"> | string | null
    uzytkownik?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
  }

  export type podwykonawcyOrderByWithRelationInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    kontakt?: SortOrderInput | SortOrder
    uzytkownik?: uzytkownicyOrderByWithRelationInput
  }

  export type podwykonawcyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uzytkownik_id?: number
    AND?: podwykonawcyWhereInput | podwykonawcyWhereInput[]
    OR?: podwykonawcyWhereInput[]
    NOT?: podwykonawcyWhereInput | podwykonawcyWhereInput[]
    specjalizacja?: StringNullableFilter<"podwykonawcy"> | string | null
    opis?: StringNullableFilter<"podwykonawcy"> | string | null
    kontakt?: StringNullableFilter<"podwykonawcy"> | string | null
    uzytkownik?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
  }, "id" | "idx_podwykonawcy_uzytkownik_id">

  export type podwykonawcyOrderByWithAggregationInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    kontakt?: SortOrderInput | SortOrder
    _count?: podwykonawcyCountOrderByAggregateInput
    _avg?: podwykonawcyAvgOrderByAggregateInput
    _max?: podwykonawcyMaxOrderByAggregateInput
    _min?: podwykonawcyMinOrderByAggregateInput
    _sum?: podwykonawcySumOrderByAggregateInput
  }

  export type podwykonawcyScalarWhereWithAggregatesInput = {
    AND?: podwykonawcyScalarWhereWithAggregatesInput | podwykonawcyScalarWhereWithAggregatesInput[]
    OR?: podwykonawcyScalarWhereWithAggregatesInput[]
    NOT?: podwykonawcyScalarWhereWithAggregatesInput | podwykonawcyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"podwykonawcy"> | number
    uzytkownik_id?: IntWithAggregatesFilter<"podwykonawcy"> | number
    specjalizacja?: StringNullableWithAggregatesFilter<"podwykonawcy"> | string | null
    opis?: StringNullableWithAggregatesFilter<"podwykonawcy"> | string | null
    kontakt?: StringNullableWithAggregatesFilter<"podwykonawcy"> | string | null
  }

  export type freelancerzyWhereInput = {
    AND?: freelancerzyWhereInput | freelancerzyWhereInput[]
    OR?: freelancerzyWhereInput[]
    NOT?: freelancerzyWhereInput | freelancerzyWhereInput[]
    id?: IntFilter<"freelancerzy"> | number
    uzytkownik_id?: IntFilter<"freelancerzy"> | number
    specjalizacja?: StringNullableFilter<"freelancerzy"> | string | null
    opis?: StringNullableFilter<"freelancerzy"> | string | null
    kontakt?: StringNullableFilter<"freelancerzy"> | string | null
    uzytkownik?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
  }

  export type freelancerzyOrderByWithRelationInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    kontakt?: SortOrderInput | SortOrder
    uzytkownik?: uzytkownicyOrderByWithRelationInput
  }

  export type freelancerzyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uzytkownik_id?: number
    AND?: freelancerzyWhereInput | freelancerzyWhereInput[]
    OR?: freelancerzyWhereInput[]
    NOT?: freelancerzyWhereInput | freelancerzyWhereInput[]
    specjalizacja?: StringNullableFilter<"freelancerzy"> | string | null
    opis?: StringNullableFilter<"freelancerzy"> | string | null
    kontakt?: StringNullableFilter<"freelancerzy"> | string | null
    uzytkownik?: XOR<UzytkownicyScalarRelationFilter, uzytkownicyWhereInput>
  }, "id" | "idx_freelancerzy_uzytkownik_id">

  export type freelancerzyOrderByWithAggregationInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrderInput | SortOrder
    opis?: SortOrderInput | SortOrder
    kontakt?: SortOrderInput | SortOrder
    _count?: freelancerzyCountOrderByAggregateInput
    _avg?: freelancerzyAvgOrderByAggregateInput
    _max?: freelancerzyMaxOrderByAggregateInput
    _min?: freelancerzyMinOrderByAggregateInput
    _sum?: freelancerzySumOrderByAggregateInput
  }

  export type freelancerzyScalarWhereWithAggregatesInput = {
    AND?: freelancerzyScalarWhereWithAggregatesInput | freelancerzyScalarWhereWithAggregatesInput[]
    OR?: freelancerzyScalarWhereWithAggregatesInput[]
    NOT?: freelancerzyScalarWhereWithAggregatesInput | freelancerzyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"freelancerzy"> | number
    uzytkownik_id?: IntWithAggregatesFilter<"freelancerzy"> | number
    specjalizacja?: StringNullableWithAggregatesFilter<"freelancerzy"> | string | null
    opis?: StringNullableWithAggregatesFilter<"freelancerzy"> | string | null
    kontakt?: StringNullableWithAggregatesFilter<"freelancerzy"> | string | null
  }

  export type uzytkownicyCreateInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUpdateInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyCreateManyInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
  }

  export type uzytkownicyUpdateManyMutationInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uzytkownicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleCreateInput = {
    nazwa: string
    uzytkownicy?: uzytkownicyCreateNestedManyWithoutRolaInput
  }

  export type roleUncheckedCreateInput = {
    id?: number
    nazwa: string
    uzytkownicy?: uzytkownicyUncheckedCreateNestedManyWithoutRolaInput
  }

  export type roleUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    uzytkownicy?: uzytkownicyUpdateManyWithoutRolaNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    uzytkownicy?: uzytkownicyUncheckedUpdateManyWithoutRolaNestedInput
  }

  export type roleCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type roleUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type artykulyCreateInput = {
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    autor: uzytkownicyCreateNestedOneWithoutArtykulyInput
    kategoria: kategorieartykulowCreateNestedOneWithoutArtykulyInput
  }

  export type artykulyUncheckedCreateInput = {
    id?: number
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    autor_id: number
    kategoria_id: number
  }

  export type artykulyUpdateInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: uzytkownicyUpdateOneRequiredWithoutArtykulyNestedInput
    kategoria?: kategorieartykulowUpdateOneRequiredWithoutArtykulyNestedInput
  }

  export type artykulyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type artykulyCreateManyInput = {
    id?: number
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    autor_id: number
    kategoria_id: number
  }

  export type artykulyUpdateManyMutationInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type artykulyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type kategorieartykulowCreateInput = {
    nazwa: string
    artykuly?: artykulyCreateNestedManyWithoutKategoriaInput
  }

  export type kategorieartykulowUncheckedCreateInput = {
    id?: number
    nazwa: string
    artykuly?: artykulyUncheckedCreateNestedManyWithoutKategoriaInput
  }

  export type kategorieartykulowUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    artykuly?: artykulyUpdateManyWithoutKategoriaNestedInput
  }

  export type kategorieartykulowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    artykuly?: artykulyUncheckedUpdateManyWithoutKategoriaNestedInput
  }

  export type kategorieartykulowCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type kategorieartykulowUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type kategorieartykulowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type produktyCreateInput = {
    nazwa?: string | null
    opis?: string | null
    cena?: Decimal | DecimalJsLike | number | string | null
    data_dodania?: Date | string | null
    producent: uzytkownicyCreateNestedOneWithoutProduktyInput
    kategoria: kategorieproduktowCreateNestedOneWithoutProduktyInput
    zamowienia?: zamowieniaCreateNestedManyWithoutProduktInput
  }

  export type produktyUncheckedCreateInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    producent_id: number
    cena?: Decimal | DecimalJsLike | number | string | null
    kategoria_id: number
    data_dodania?: Date | string | null
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutProduktInput
  }

  export type produktyUpdateInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producent?: uzytkownicyUpdateOneRequiredWithoutProduktyNestedInput
    kategoria?: kategorieproduktowUpdateOneRequiredWithoutProduktyNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutProduktNestedInput
  }

  export type produktyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    producent_id?: IntFieldUpdateOperationsInput | number
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutProduktNestedInput
  }

  export type produktyCreateManyInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    producent_id: number
    cena?: Decimal | DecimalJsLike | number | string | null
    kategoria_id: number
    data_dodania?: Date | string | null
  }

  export type produktyUpdateManyMutationInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type produktyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    producent_id?: IntFieldUpdateOperationsInput | number
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type kategorieproduktowCreateInput = {
    nazwa: string
    produkty?: produktyCreateNestedManyWithoutKategoriaInput
  }

  export type kategorieproduktowUncheckedCreateInput = {
    id?: number
    nazwa: string
    produkty?: produktyUncheckedCreateNestedManyWithoutKategoriaInput
  }

  export type kategorieproduktowUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    produkty?: produktyUpdateManyWithoutKategoriaNestedInput
  }

  export type kategorieproduktowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    produkty?: produktyUncheckedUpdateManyWithoutKategoriaNestedInput
  }

  export type kategorieproduktowCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type kategorieproduktowUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type kategorieproduktowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type zamowieniaCreateInput = {
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    uzytkownik: uzytkownicyCreateNestedOneWithoutZamowieniaInput
    produkt: produktyCreateNestedOneWithoutZamowieniaInput
    status: statusyzamowienCreateNestedOneWithoutZamowieniaInput
  }

  export type zamowieniaUncheckedCreateInput = {
    id?: number
    uzytkownik_id: number
    produkt_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    status_id: number
  }

  export type zamowieniaUpdateInput = {
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uzytkownik?: uzytkownicyUpdateOneRequiredWithoutZamowieniaNestedInput
    produkt?: produktyUpdateOneRequiredWithoutZamowieniaNestedInput
    status?: statusyzamowienUpdateOneRequiredWithoutZamowieniaNestedInput
  }

  export type zamowieniaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    produkt_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type zamowieniaCreateManyInput = {
    id?: number
    uzytkownik_id: number
    produkt_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    status_id: number
  }

  export type zamowieniaUpdateManyMutationInput = {
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zamowieniaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    produkt_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type statusyzamowienCreateInput = {
    nazwa: string
    zamowienia?: zamowieniaCreateNestedManyWithoutStatusInput
  }

  export type statusyzamowienUncheckedCreateInput = {
    id?: number
    nazwa: string
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutStatusInput
  }

  export type statusyzamowienUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    zamowienia?: zamowieniaUpdateManyWithoutStatusNestedInput
  }

  export type statusyzamowienUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type statusyzamowienCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type statusyzamowienUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type statusyzamowienUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type zleceniaCreateInput = {
    tytul?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    zleceniodawca: uzytkownicyCreateNestedOneWithoutZlecenia_zleceniodawcaInput
    wykonawca: uzytkownicyCreateNestedOneWithoutZlecenia_wykonawcaInput
    status: statusyzlecenCreateNestedOneWithoutZleceniaInput
    typ: typyzlecenCreateNestedOneWithoutZleceniaInput
  }

  export type zleceniaUncheckedCreateInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
    typ_id: number
  }

  export type zleceniaUpdateInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zleceniodawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_zleceniodawcaNestedInput
    wykonawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_wykonawcaNestedInput
    status?: statusyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
    typ?: typyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
  }

  export type zleceniaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaCreateManyInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
    typ_id: number
  }

  export type zleceniaUpdateManyMutationInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zleceniaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type statusyzlecenCreateInput = {
    nazwa: string
    zlecenia?: zleceniaCreateNestedManyWithoutStatusInput
  }

  export type statusyzlecenUncheckedCreateInput = {
    id?: number
    nazwa: string
    zlecenia?: zleceniaUncheckedCreateNestedManyWithoutStatusInput
  }

  export type statusyzlecenUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    zlecenia?: zleceniaUpdateManyWithoutStatusNestedInput
  }

  export type statusyzlecenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    zlecenia?: zleceniaUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type statusyzlecenCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type statusyzlecenUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type statusyzlecenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type typyzlecenCreateInput = {
    nazwa: string
    zlecenia?: zleceniaCreateNestedManyWithoutTypInput
  }

  export type typyzlecenUncheckedCreateInput = {
    id?: number
    nazwa: string
    zlecenia?: zleceniaUncheckedCreateNestedManyWithoutTypInput
  }

  export type typyzlecenUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    zlecenia?: zleceniaUpdateManyWithoutTypNestedInput
  }

  export type typyzlecenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    zlecenia?: zleceniaUncheckedUpdateManyWithoutTypNestedInput
  }

  export type typyzlecenCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type typyzlecenUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type typyzlecenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type projektyCreateInput = {
    nazwa?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    autor: uzytkownicyCreateNestedOneWithoutProjektyInput
    status: statusyprojektowCreateNestedOneWithoutProjektyInput
  }

  export type projektyUncheckedCreateInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    autor_id: number
    data_utworzenia?: Date | string | null
    status_id: number
  }

  export type projektyUpdateInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: uzytkownicyUpdateOneRequiredWithoutProjektyNestedInput
    status?: statusyprojektowUpdateOneRequiredWithoutProjektyNestedInput
  }

  export type projektyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type projektyCreateManyInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    autor_id: number
    data_utworzenia?: Date | string | null
    status_id: number
  }

  export type projektyUpdateManyMutationInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projektyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type statusyprojektowCreateInput = {
    nazwa: string
    projekty?: projektyCreateNestedManyWithoutStatusInput
  }

  export type statusyprojektowUncheckedCreateInput = {
    id?: number
    nazwa: string
    projekty?: projektyUncheckedCreateNestedManyWithoutStatusInput
  }

  export type statusyprojektowUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    projekty?: projektyUpdateManyWithoutStatusNestedInput
  }

  export type statusyprojektowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    projekty?: projektyUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type statusyprojektowCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type statusyprojektowUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type statusyprojektowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type producentkatalogCreateInput = {
    opis?: string | null
    strona_www?: string | null
    producent: uzytkownicyCreateNestedOneWithoutProducent_katalogInput
    kategoria: kategorieproducentowCreateNestedOneWithoutProducentkatalogInput
  }

  export type producentkatalogUncheckedCreateInput = {
    id?: number
    producent_id: number
    opis?: string | null
    strona_www?: string | null
    kategoria_id: number
  }

  export type producentkatalogUpdateInput = {
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    producent?: uzytkownicyUpdateOneRequiredWithoutProducent_katalogNestedInput
    kategoria?: kategorieproducentowUpdateOneRequiredWithoutProducentkatalogNestedInput
  }

  export type producentkatalogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    producent_id?: IntFieldUpdateOperationsInput | number
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type producentkatalogCreateManyInput = {
    id?: number
    producent_id: number
    opis?: string | null
    strona_www?: string | null
    kategoria_id: number
  }

  export type producentkatalogUpdateManyMutationInput = {
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type producentkatalogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    producent_id?: IntFieldUpdateOperationsInput | number
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type kategorieproducentowCreateInput = {
    nazwa: string
    producentkatalog?: producentkatalogCreateNestedManyWithoutKategoriaInput
  }

  export type kategorieproducentowUncheckedCreateInput = {
    id?: number
    nazwa: string
    producentkatalog?: producentkatalogUncheckedCreateNestedManyWithoutKategoriaInput
  }

  export type kategorieproducentowUpdateInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
    producentkatalog?: producentkatalogUpdateManyWithoutKategoriaNestedInput
  }

  export type kategorieproducentowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
    producentkatalog?: producentkatalogUncheckedUpdateManyWithoutKategoriaNestedInput
  }

  export type kategorieproducentowCreateManyInput = {
    id?: number
    nazwa: string
  }

  export type kategorieproducentowUpdateManyMutationInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type kategorieproducentowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type podwykonawcyCreateInput = {
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
    uzytkownik: uzytkownicyCreateNestedOneWithoutPodwykonawcyInput
  }

  export type podwykonawcyUncheckedCreateInput = {
    id?: number
    uzytkownik_id: number
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type podwykonawcyUpdateInput = {
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
    uzytkownik?: uzytkownicyUpdateOneRequiredWithoutPodwykonawcyNestedInput
  }

  export type podwykonawcyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type podwykonawcyCreateManyInput = {
    id?: number
    uzytkownik_id: number
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type podwykonawcyUpdateManyMutationInput = {
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type podwykonawcyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type freelancerzyCreateInput = {
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
    uzytkownik: uzytkownicyCreateNestedOneWithoutFreelancerzyInput
  }

  export type freelancerzyUncheckedCreateInput = {
    id?: number
    uzytkownik_id: number
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type freelancerzyUpdateInput = {
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
    uzytkownik?: uzytkownicyUpdateOneRequiredWithoutFreelancerzyNestedInput
  }

  export type freelancerzyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type freelancerzyCreateManyInput = {
    id?: number
    uzytkownik_id: number
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type freelancerzyUpdateManyMutationInput = {
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type freelancerzyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type ArtykulyListRelationFilter = {
    every?: artykulyWhereInput
    some?: artykulyWhereInput
    none?: artykulyWhereInput
  }

  export type ProduktyListRelationFilter = {
    every?: produktyWhereInput
    some?: produktyWhereInput
    none?: produktyWhereInput
  }

  export type ZamowieniaListRelationFilter = {
    every?: zamowieniaWhereInput
    some?: zamowieniaWhereInput
    none?: zamowieniaWhereInput
  }

  export type ZleceniaListRelationFilter = {
    every?: zleceniaWhereInput
    some?: zleceniaWhereInput
    none?: zleceniaWhereInput
  }

  export type ProjektyListRelationFilter = {
    every?: projektyWhereInput
    some?: projektyWhereInput
    none?: projektyWhereInput
  }

  export type ProducentkatalogListRelationFilter = {
    every?: producentkatalogWhereInput
    some?: producentkatalogWhereInput
    none?: producentkatalogWhereInput
  }

  export type PodwykonawcyNullableScalarRelationFilter = {
    is?: podwykonawcyWhereInput | null
    isNot?: podwykonawcyWhereInput | null
  }

  export type FreelancerzyNullableScalarRelationFilter = {
    is?: freelancerzyWhereInput | null
    isNot?: freelancerzyWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type artykulyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type produktyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type zamowieniaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type zleceniaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projektyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type producentkatalogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type uzytkownicyCountOrderByAggregateInput = {
    id?: SortOrder
    imie?: SortOrder
    nazwisko?: SortOrder
    email?: SortOrder
    haslo?: SortOrder
    rola_id?: SortOrder
    data_rejestracji?: SortOrder
  }

  export type uzytkownicyAvgOrderByAggregateInput = {
    id?: SortOrder
    rola_id?: SortOrder
  }

  export type uzytkownicyMaxOrderByAggregateInput = {
    id?: SortOrder
    imie?: SortOrder
    nazwisko?: SortOrder
    email?: SortOrder
    haslo?: SortOrder
    rola_id?: SortOrder
    data_rejestracji?: SortOrder
  }

  export type uzytkownicyMinOrderByAggregateInput = {
    id?: SortOrder
    imie?: SortOrder
    nazwisko?: SortOrder
    email?: SortOrder
    haslo?: SortOrder
    rola_id?: SortOrder
    data_rejestracji?: SortOrder
  }

  export type uzytkownicySumOrderByAggregateInput = {
    id?: SortOrder
    rola_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UzytkownicyListRelationFilter = {
    every?: uzytkownicyWhereInput
    some?: uzytkownicyWhereInput
    none?: uzytkownicyWhereInput
  }

  export type uzytkownicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UzytkownicyScalarRelationFilter = {
    is?: uzytkownicyWhereInput
    isNot?: uzytkownicyWhereInput
  }

  export type KategorieartykulowScalarRelationFilter = {
    is?: kategorieartykulowWhereInput
    isNot?: kategorieartykulowWhereInput
  }

  export type artykulyCountOrderByAggregateInput = {
    id?: SortOrder
    tytul?: SortOrder
    tresc?: SortOrder
    data_publikacji?: SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type artykulyAvgOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type artykulyMaxOrderByAggregateInput = {
    id?: SortOrder
    tytul?: SortOrder
    tresc?: SortOrder
    data_publikacji?: SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type artykulyMinOrderByAggregateInput = {
    id?: SortOrder
    tytul?: SortOrder
    tresc?: SortOrder
    data_publikacji?: SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type artykulySumOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type kategorieartykulowCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieartykulowAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kategorieartykulowMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieartykulowMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieartykulowSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type KategorieproduktowScalarRelationFilter = {
    is?: kategorieproduktowWhereInput
    isNot?: kategorieproduktowWhereInput
  }

  export type produktyCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
    opis?: SortOrder
    producent_id?: SortOrder
    cena?: SortOrder
    kategoria_id?: SortOrder
    data_dodania?: SortOrder
  }

  export type produktyAvgOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    cena?: SortOrder
    kategoria_id?: SortOrder
  }

  export type produktyMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
    opis?: SortOrder
    producent_id?: SortOrder
    cena?: SortOrder
    kategoria_id?: SortOrder
    data_dodania?: SortOrder
  }

  export type produktyMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
    opis?: SortOrder
    producent_id?: SortOrder
    cena?: SortOrder
    kategoria_id?: SortOrder
    data_dodania?: SortOrder
  }

  export type produktySumOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    cena?: SortOrder
    kategoria_id?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type kategorieproduktowCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieproduktowAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kategorieproduktowMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieproduktowMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieproduktowSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProduktyScalarRelationFilter = {
    is?: produktyWhereInput
    isNot?: produktyWhereInput
  }

  export type StatusyzamowienScalarRelationFilter = {
    is?: statusyzamowienWhereInput
    isNot?: statusyzamowienWhereInput
  }

  export type zamowieniaCountOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrder
    data_zamowienia?: SortOrder
    status_id?: SortOrder
  }

  export type zamowieniaAvgOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrder
    status_id?: SortOrder
  }

  export type zamowieniaMaxOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrder
    data_zamowienia?: SortOrder
    status_id?: SortOrder
  }

  export type zamowieniaMinOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrder
    data_zamowienia?: SortOrder
    status_id?: SortOrder
  }

  export type zamowieniaSumOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    produkt_id?: SortOrder
    ilosc?: SortOrder
    status_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type statusyzamowienCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyzamowienAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type statusyzamowienMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyzamowienMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyzamowienSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusyzlecenScalarRelationFilter = {
    is?: statusyzlecenWhereInput
    isNot?: statusyzlecenWhereInput
  }

  export type TypyzlecenScalarRelationFilter = {
    is?: typyzlecenWhereInput
    isNot?: typyzlecenWhereInput
  }

  export type zleceniaCountOrderByAggregateInput = {
    id?: SortOrder
    tytul?: SortOrder
    opis?: SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    data_utworzenia?: SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
  }

  export type zleceniaAvgOrderByAggregateInput = {
    id?: SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
  }

  export type zleceniaMaxOrderByAggregateInput = {
    id?: SortOrder
    tytul?: SortOrder
    opis?: SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    data_utworzenia?: SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
  }

  export type zleceniaMinOrderByAggregateInput = {
    id?: SortOrder
    tytul?: SortOrder
    opis?: SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    data_utworzenia?: SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
  }

  export type zleceniaSumOrderByAggregateInput = {
    id?: SortOrder
    zleceniodawca_id?: SortOrder
    wykonawca_id?: SortOrder
    status_id?: SortOrder
    typ_id?: SortOrder
  }

  export type statusyzlecenCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyzlecenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type statusyzlecenMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyzlecenMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyzlecenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type typyzlecenCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type typyzlecenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type typyzlecenMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type typyzlecenMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type typyzlecenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusyprojektowScalarRelationFilter = {
    is?: statusyprojektowWhereInput
    isNot?: statusyprojektowWhereInput
  }

  export type projektyCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
    opis?: SortOrder
    autor_id?: SortOrder
    data_utworzenia?: SortOrder
    status_id?: SortOrder
  }

  export type projektyAvgOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    status_id?: SortOrder
  }

  export type projektyMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
    opis?: SortOrder
    autor_id?: SortOrder
    data_utworzenia?: SortOrder
    status_id?: SortOrder
  }

  export type projektyMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
    opis?: SortOrder
    autor_id?: SortOrder
    data_utworzenia?: SortOrder
    status_id?: SortOrder
  }

  export type projektySumOrderByAggregateInput = {
    id?: SortOrder
    autor_id?: SortOrder
    status_id?: SortOrder
  }

  export type statusyprojektowCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyprojektowAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type statusyprojektowMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyprojektowMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type statusyprojektowSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KategorieproducentowScalarRelationFilter = {
    is?: kategorieproducentowWhereInput
    isNot?: kategorieproducentowWhereInput
  }

  export type producentkatalogCountOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    opis?: SortOrder
    strona_www?: SortOrder
    kategoria_id?: SortOrder
  }

  export type producentkatalogAvgOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type producentkatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    opis?: SortOrder
    strona_www?: SortOrder
    kategoria_id?: SortOrder
  }

  export type producentkatalogMinOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    opis?: SortOrder
    strona_www?: SortOrder
    kategoria_id?: SortOrder
  }

  export type producentkatalogSumOrderByAggregateInput = {
    id?: SortOrder
    producent_id?: SortOrder
    kategoria_id?: SortOrder
  }

  export type kategorieproducentowCountOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieproducentowAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kategorieproducentowMaxOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieproducentowMinOrderByAggregateInput = {
    id?: SortOrder
    nazwa?: SortOrder
  }

  export type kategorieproducentowSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type podwykonawcyCountOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrder
    opis?: SortOrder
    kontakt?: SortOrder
  }

  export type podwykonawcyAvgOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
  }

  export type podwykonawcyMaxOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrder
    opis?: SortOrder
    kontakt?: SortOrder
  }

  export type podwykonawcyMinOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrder
    opis?: SortOrder
    kontakt?: SortOrder
  }

  export type podwykonawcySumOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
  }

  export type freelancerzyCountOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrder
    opis?: SortOrder
    kontakt?: SortOrder
  }

  export type freelancerzyAvgOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
  }

  export type freelancerzyMaxOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrder
    opis?: SortOrder
    kontakt?: SortOrder
  }

  export type freelancerzyMinOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
    specjalizacja?: SortOrder
    opis?: SortOrder
    kontakt?: SortOrder
  }

  export type freelancerzySumOrderByAggregateInput = {
    id?: SortOrder
    uzytkownik_id?: SortOrder
  }

  export type roleCreateNestedOneWithoutUzytkownicyInput = {
    create?: XOR<roleCreateWithoutUzytkownicyInput, roleUncheckedCreateWithoutUzytkownicyInput>
    connectOrCreate?: roleCreateOrConnectWithoutUzytkownicyInput
    connect?: roleWhereUniqueInput
  }

  export type artykulyCreateNestedManyWithoutAutorInput = {
    create?: XOR<artykulyCreateWithoutAutorInput, artykulyUncheckedCreateWithoutAutorInput> | artykulyCreateWithoutAutorInput[] | artykulyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutAutorInput | artykulyCreateOrConnectWithoutAutorInput[]
    createMany?: artykulyCreateManyAutorInputEnvelope
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
  }

  export type produktyCreateNestedManyWithoutProducentInput = {
    create?: XOR<produktyCreateWithoutProducentInput, produktyUncheckedCreateWithoutProducentInput> | produktyCreateWithoutProducentInput[] | produktyUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutProducentInput | produktyCreateOrConnectWithoutProducentInput[]
    createMany?: produktyCreateManyProducentInputEnvelope
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
  }

  export type zamowieniaCreateNestedManyWithoutUzytkownikInput = {
    create?: XOR<zamowieniaCreateWithoutUzytkownikInput, zamowieniaUncheckedCreateWithoutUzytkownikInput> | zamowieniaCreateWithoutUzytkownikInput[] | zamowieniaUncheckedCreateWithoutUzytkownikInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutUzytkownikInput | zamowieniaCreateOrConnectWithoutUzytkownikInput[]
    createMany?: zamowieniaCreateManyUzytkownikInputEnvelope
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
  }

  export type zleceniaCreateNestedManyWithoutZleceniodawcaInput = {
    create?: XOR<zleceniaCreateWithoutZleceniodawcaInput, zleceniaUncheckedCreateWithoutZleceniodawcaInput> | zleceniaCreateWithoutZleceniodawcaInput[] | zleceniaUncheckedCreateWithoutZleceniodawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutZleceniodawcaInput | zleceniaCreateOrConnectWithoutZleceniodawcaInput[]
    createMany?: zleceniaCreateManyZleceniodawcaInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type zleceniaCreateNestedManyWithoutWykonawcaInput = {
    create?: XOR<zleceniaCreateWithoutWykonawcaInput, zleceniaUncheckedCreateWithoutWykonawcaInput> | zleceniaCreateWithoutWykonawcaInput[] | zleceniaUncheckedCreateWithoutWykonawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutWykonawcaInput | zleceniaCreateOrConnectWithoutWykonawcaInput[]
    createMany?: zleceniaCreateManyWykonawcaInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type projektyCreateNestedManyWithoutAutorInput = {
    create?: XOR<projektyCreateWithoutAutorInput, projektyUncheckedCreateWithoutAutorInput> | projektyCreateWithoutAutorInput[] | projektyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutAutorInput | projektyCreateOrConnectWithoutAutorInput[]
    createMany?: projektyCreateManyAutorInputEnvelope
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
  }

  export type producentkatalogCreateNestedManyWithoutProducentInput = {
    create?: XOR<producentkatalogCreateWithoutProducentInput, producentkatalogUncheckedCreateWithoutProducentInput> | producentkatalogCreateWithoutProducentInput[] | producentkatalogUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutProducentInput | producentkatalogCreateOrConnectWithoutProducentInput[]
    createMany?: producentkatalogCreateManyProducentInputEnvelope
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
  }

  export type podwykonawcyCreateNestedOneWithoutUzytkownikInput = {
    create?: XOR<podwykonawcyCreateWithoutUzytkownikInput, podwykonawcyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: podwykonawcyCreateOrConnectWithoutUzytkownikInput
    connect?: podwykonawcyWhereUniqueInput
  }

  export type freelancerzyCreateNestedOneWithoutUzytkownikInput = {
    create?: XOR<freelancerzyCreateWithoutUzytkownikInput, freelancerzyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: freelancerzyCreateOrConnectWithoutUzytkownikInput
    connect?: freelancerzyWhereUniqueInput
  }

  export type artykulyUncheckedCreateNestedManyWithoutAutorInput = {
    create?: XOR<artykulyCreateWithoutAutorInput, artykulyUncheckedCreateWithoutAutorInput> | artykulyCreateWithoutAutorInput[] | artykulyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutAutorInput | artykulyCreateOrConnectWithoutAutorInput[]
    createMany?: artykulyCreateManyAutorInputEnvelope
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
  }

  export type produktyUncheckedCreateNestedManyWithoutProducentInput = {
    create?: XOR<produktyCreateWithoutProducentInput, produktyUncheckedCreateWithoutProducentInput> | produktyCreateWithoutProducentInput[] | produktyUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutProducentInput | produktyCreateOrConnectWithoutProducentInput[]
    createMany?: produktyCreateManyProducentInputEnvelope
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
  }

  export type zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput = {
    create?: XOR<zamowieniaCreateWithoutUzytkownikInput, zamowieniaUncheckedCreateWithoutUzytkownikInput> | zamowieniaCreateWithoutUzytkownikInput[] | zamowieniaUncheckedCreateWithoutUzytkownikInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutUzytkownikInput | zamowieniaCreateOrConnectWithoutUzytkownikInput[]
    createMany?: zamowieniaCreateManyUzytkownikInputEnvelope
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
  }

  export type zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput = {
    create?: XOR<zleceniaCreateWithoutZleceniodawcaInput, zleceniaUncheckedCreateWithoutZleceniodawcaInput> | zleceniaCreateWithoutZleceniodawcaInput[] | zleceniaUncheckedCreateWithoutZleceniodawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutZleceniodawcaInput | zleceniaCreateOrConnectWithoutZleceniodawcaInput[]
    createMany?: zleceniaCreateManyZleceniodawcaInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput = {
    create?: XOR<zleceniaCreateWithoutWykonawcaInput, zleceniaUncheckedCreateWithoutWykonawcaInput> | zleceniaCreateWithoutWykonawcaInput[] | zleceniaUncheckedCreateWithoutWykonawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutWykonawcaInput | zleceniaCreateOrConnectWithoutWykonawcaInput[]
    createMany?: zleceniaCreateManyWykonawcaInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type projektyUncheckedCreateNestedManyWithoutAutorInput = {
    create?: XOR<projektyCreateWithoutAutorInput, projektyUncheckedCreateWithoutAutorInput> | projektyCreateWithoutAutorInput[] | projektyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutAutorInput | projektyCreateOrConnectWithoutAutorInput[]
    createMany?: projektyCreateManyAutorInputEnvelope
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
  }

  export type producentkatalogUncheckedCreateNestedManyWithoutProducentInput = {
    create?: XOR<producentkatalogCreateWithoutProducentInput, producentkatalogUncheckedCreateWithoutProducentInput> | producentkatalogCreateWithoutProducentInput[] | producentkatalogUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutProducentInput | producentkatalogCreateOrConnectWithoutProducentInput[]
    createMany?: producentkatalogCreateManyProducentInputEnvelope
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
  }

  export type podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput = {
    create?: XOR<podwykonawcyCreateWithoutUzytkownikInput, podwykonawcyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: podwykonawcyCreateOrConnectWithoutUzytkownikInput
    connect?: podwykonawcyWhereUniqueInput
  }

  export type freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput = {
    create?: XOR<freelancerzyCreateWithoutUzytkownikInput, freelancerzyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: freelancerzyCreateOrConnectWithoutUzytkownikInput
    connect?: freelancerzyWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type roleUpdateOneRequiredWithoutUzytkownicyNestedInput = {
    create?: XOR<roleCreateWithoutUzytkownicyInput, roleUncheckedCreateWithoutUzytkownicyInput>
    connectOrCreate?: roleCreateOrConnectWithoutUzytkownicyInput
    upsert?: roleUpsertWithoutUzytkownicyInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUzytkownicyInput, roleUpdateWithoutUzytkownicyInput>, roleUncheckedUpdateWithoutUzytkownicyInput>
  }

  export type artykulyUpdateManyWithoutAutorNestedInput = {
    create?: XOR<artykulyCreateWithoutAutorInput, artykulyUncheckedCreateWithoutAutorInput> | artykulyCreateWithoutAutorInput[] | artykulyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutAutorInput | artykulyCreateOrConnectWithoutAutorInput[]
    upsert?: artykulyUpsertWithWhereUniqueWithoutAutorInput | artykulyUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: artykulyCreateManyAutorInputEnvelope
    set?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    disconnect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    delete?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    update?: artykulyUpdateWithWhereUniqueWithoutAutorInput | artykulyUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: artykulyUpdateManyWithWhereWithoutAutorInput | artykulyUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: artykulyScalarWhereInput | artykulyScalarWhereInput[]
  }

  export type produktyUpdateManyWithoutProducentNestedInput = {
    create?: XOR<produktyCreateWithoutProducentInput, produktyUncheckedCreateWithoutProducentInput> | produktyCreateWithoutProducentInput[] | produktyUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutProducentInput | produktyCreateOrConnectWithoutProducentInput[]
    upsert?: produktyUpsertWithWhereUniqueWithoutProducentInput | produktyUpsertWithWhereUniqueWithoutProducentInput[]
    createMany?: produktyCreateManyProducentInputEnvelope
    set?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    disconnect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    delete?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    update?: produktyUpdateWithWhereUniqueWithoutProducentInput | produktyUpdateWithWhereUniqueWithoutProducentInput[]
    updateMany?: produktyUpdateManyWithWhereWithoutProducentInput | produktyUpdateManyWithWhereWithoutProducentInput[]
    deleteMany?: produktyScalarWhereInput | produktyScalarWhereInput[]
  }

  export type zamowieniaUpdateManyWithoutUzytkownikNestedInput = {
    create?: XOR<zamowieniaCreateWithoutUzytkownikInput, zamowieniaUncheckedCreateWithoutUzytkownikInput> | zamowieniaCreateWithoutUzytkownikInput[] | zamowieniaUncheckedCreateWithoutUzytkownikInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutUzytkownikInput | zamowieniaCreateOrConnectWithoutUzytkownikInput[]
    upsert?: zamowieniaUpsertWithWhereUniqueWithoutUzytkownikInput | zamowieniaUpsertWithWhereUniqueWithoutUzytkownikInput[]
    createMany?: zamowieniaCreateManyUzytkownikInputEnvelope
    set?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    disconnect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    delete?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    update?: zamowieniaUpdateWithWhereUniqueWithoutUzytkownikInput | zamowieniaUpdateWithWhereUniqueWithoutUzytkownikInput[]
    updateMany?: zamowieniaUpdateManyWithWhereWithoutUzytkownikInput | zamowieniaUpdateManyWithWhereWithoutUzytkownikInput[]
    deleteMany?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
  }

  export type zleceniaUpdateManyWithoutZleceniodawcaNestedInput = {
    create?: XOR<zleceniaCreateWithoutZleceniodawcaInput, zleceniaUncheckedCreateWithoutZleceniodawcaInput> | zleceniaCreateWithoutZleceniodawcaInput[] | zleceniaUncheckedCreateWithoutZleceniodawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutZleceniodawcaInput | zleceniaCreateOrConnectWithoutZleceniodawcaInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutZleceniodawcaInput | zleceniaUpsertWithWhereUniqueWithoutZleceniodawcaInput[]
    createMany?: zleceniaCreateManyZleceniodawcaInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutZleceniodawcaInput | zleceniaUpdateWithWhereUniqueWithoutZleceniodawcaInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutZleceniodawcaInput | zleceniaUpdateManyWithWhereWithoutZleceniodawcaInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type zleceniaUpdateManyWithoutWykonawcaNestedInput = {
    create?: XOR<zleceniaCreateWithoutWykonawcaInput, zleceniaUncheckedCreateWithoutWykonawcaInput> | zleceniaCreateWithoutWykonawcaInput[] | zleceniaUncheckedCreateWithoutWykonawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutWykonawcaInput | zleceniaCreateOrConnectWithoutWykonawcaInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutWykonawcaInput | zleceniaUpsertWithWhereUniqueWithoutWykonawcaInput[]
    createMany?: zleceniaCreateManyWykonawcaInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutWykonawcaInput | zleceniaUpdateWithWhereUniqueWithoutWykonawcaInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutWykonawcaInput | zleceniaUpdateManyWithWhereWithoutWykonawcaInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type projektyUpdateManyWithoutAutorNestedInput = {
    create?: XOR<projektyCreateWithoutAutorInput, projektyUncheckedCreateWithoutAutorInput> | projektyCreateWithoutAutorInput[] | projektyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutAutorInput | projektyCreateOrConnectWithoutAutorInput[]
    upsert?: projektyUpsertWithWhereUniqueWithoutAutorInput | projektyUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: projektyCreateManyAutorInputEnvelope
    set?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    disconnect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    delete?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    update?: projektyUpdateWithWhereUniqueWithoutAutorInput | projektyUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: projektyUpdateManyWithWhereWithoutAutorInput | projektyUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: projektyScalarWhereInput | projektyScalarWhereInput[]
  }

  export type producentkatalogUpdateManyWithoutProducentNestedInput = {
    create?: XOR<producentkatalogCreateWithoutProducentInput, producentkatalogUncheckedCreateWithoutProducentInput> | producentkatalogCreateWithoutProducentInput[] | producentkatalogUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutProducentInput | producentkatalogCreateOrConnectWithoutProducentInput[]
    upsert?: producentkatalogUpsertWithWhereUniqueWithoutProducentInput | producentkatalogUpsertWithWhereUniqueWithoutProducentInput[]
    createMany?: producentkatalogCreateManyProducentInputEnvelope
    set?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    disconnect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    delete?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    update?: producentkatalogUpdateWithWhereUniqueWithoutProducentInput | producentkatalogUpdateWithWhereUniqueWithoutProducentInput[]
    updateMany?: producentkatalogUpdateManyWithWhereWithoutProducentInput | producentkatalogUpdateManyWithWhereWithoutProducentInput[]
    deleteMany?: producentkatalogScalarWhereInput | producentkatalogScalarWhereInput[]
  }

  export type podwykonawcyUpdateOneWithoutUzytkownikNestedInput = {
    create?: XOR<podwykonawcyCreateWithoutUzytkownikInput, podwykonawcyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: podwykonawcyCreateOrConnectWithoutUzytkownikInput
    upsert?: podwykonawcyUpsertWithoutUzytkownikInput
    disconnect?: podwykonawcyWhereInput | boolean
    delete?: podwykonawcyWhereInput | boolean
    connect?: podwykonawcyWhereUniqueInput
    update?: XOR<XOR<podwykonawcyUpdateToOneWithWhereWithoutUzytkownikInput, podwykonawcyUpdateWithoutUzytkownikInput>, podwykonawcyUncheckedUpdateWithoutUzytkownikInput>
  }

  export type freelancerzyUpdateOneWithoutUzytkownikNestedInput = {
    create?: XOR<freelancerzyCreateWithoutUzytkownikInput, freelancerzyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: freelancerzyCreateOrConnectWithoutUzytkownikInput
    upsert?: freelancerzyUpsertWithoutUzytkownikInput
    disconnect?: freelancerzyWhereInput | boolean
    delete?: freelancerzyWhereInput | boolean
    connect?: freelancerzyWhereUniqueInput
    update?: XOR<XOR<freelancerzyUpdateToOneWithWhereWithoutUzytkownikInput, freelancerzyUpdateWithoutUzytkownikInput>, freelancerzyUncheckedUpdateWithoutUzytkownikInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type artykulyUncheckedUpdateManyWithoutAutorNestedInput = {
    create?: XOR<artykulyCreateWithoutAutorInput, artykulyUncheckedCreateWithoutAutorInput> | artykulyCreateWithoutAutorInput[] | artykulyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutAutorInput | artykulyCreateOrConnectWithoutAutorInput[]
    upsert?: artykulyUpsertWithWhereUniqueWithoutAutorInput | artykulyUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: artykulyCreateManyAutorInputEnvelope
    set?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    disconnect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    delete?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    update?: artykulyUpdateWithWhereUniqueWithoutAutorInput | artykulyUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: artykulyUpdateManyWithWhereWithoutAutorInput | artykulyUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: artykulyScalarWhereInput | artykulyScalarWhereInput[]
  }

  export type produktyUncheckedUpdateManyWithoutProducentNestedInput = {
    create?: XOR<produktyCreateWithoutProducentInput, produktyUncheckedCreateWithoutProducentInput> | produktyCreateWithoutProducentInput[] | produktyUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutProducentInput | produktyCreateOrConnectWithoutProducentInput[]
    upsert?: produktyUpsertWithWhereUniqueWithoutProducentInput | produktyUpsertWithWhereUniqueWithoutProducentInput[]
    createMany?: produktyCreateManyProducentInputEnvelope
    set?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    disconnect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    delete?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    update?: produktyUpdateWithWhereUniqueWithoutProducentInput | produktyUpdateWithWhereUniqueWithoutProducentInput[]
    updateMany?: produktyUpdateManyWithWhereWithoutProducentInput | produktyUpdateManyWithWhereWithoutProducentInput[]
    deleteMany?: produktyScalarWhereInput | produktyScalarWhereInput[]
  }

  export type zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput = {
    create?: XOR<zamowieniaCreateWithoutUzytkownikInput, zamowieniaUncheckedCreateWithoutUzytkownikInput> | zamowieniaCreateWithoutUzytkownikInput[] | zamowieniaUncheckedCreateWithoutUzytkownikInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutUzytkownikInput | zamowieniaCreateOrConnectWithoutUzytkownikInput[]
    upsert?: zamowieniaUpsertWithWhereUniqueWithoutUzytkownikInput | zamowieniaUpsertWithWhereUniqueWithoutUzytkownikInput[]
    createMany?: zamowieniaCreateManyUzytkownikInputEnvelope
    set?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    disconnect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    delete?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    update?: zamowieniaUpdateWithWhereUniqueWithoutUzytkownikInput | zamowieniaUpdateWithWhereUniqueWithoutUzytkownikInput[]
    updateMany?: zamowieniaUpdateManyWithWhereWithoutUzytkownikInput | zamowieniaUpdateManyWithWhereWithoutUzytkownikInput[]
    deleteMany?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
  }

  export type zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput = {
    create?: XOR<zleceniaCreateWithoutZleceniodawcaInput, zleceniaUncheckedCreateWithoutZleceniodawcaInput> | zleceniaCreateWithoutZleceniodawcaInput[] | zleceniaUncheckedCreateWithoutZleceniodawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutZleceniodawcaInput | zleceniaCreateOrConnectWithoutZleceniodawcaInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutZleceniodawcaInput | zleceniaUpsertWithWhereUniqueWithoutZleceniodawcaInput[]
    createMany?: zleceniaCreateManyZleceniodawcaInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutZleceniodawcaInput | zleceniaUpdateWithWhereUniqueWithoutZleceniodawcaInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutZleceniodawcaInput | zleceniaUpdateManyWithWhereWithoutZleceniodawcaInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput = {
    create?: XOR<zleceniaCreateWithoutWykonawcaInput, zleceniaUncheckedCreateWithoutWykonawcaInput> | zleceniaCreateWithoutWykonawcaInput[] | zleceniaUncheckedCreateWithoutWykonawcaInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutWykonawcaInput | zleceniaCreateOrConnectWithoutWykonawcaInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutWykonawcaInput | zleceniaUpsertWithWhereUniqueWithoutWykonawcaInput[]
    createMany?: zleceniaCreateManyWykonawcaInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutWykonawcaInput | zleceniaUpdateWithWhereUniqueWithoutWykonawcaInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutWykonawcaInput | zleceniaUpdateManyWithWhereWithoutWykonawcaInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type projektyUncheckedUpdateManyWithoutAutorNestedInput = {
    create?: XOR<projektyCreateWithoutAutorInput, projektyUncheckedCreateWithoutAutorInput> | projektyCreateWithoutAutorInput[] | projektyUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutAutorInput | projektyCreateOrConnectWithoutAutorInput[]
    upsert?: projektyUpsertWithWhereUniqueWithoutAutorInput | projektyUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: projektyCreateManyAutorInputEnvelope
    set?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    disconnect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    delete?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    update?: projektyUpdateWithWhereUniqueWithoutAutorInput | projektyUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: projektyUpdateManyWithWhereWithoutAutorInput | projektyUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: projektyScalarWhereInput | projektyScalarWhereInput[]
  }

  export type producentkatalogUncheckedUpdateManyWithoutProducentNestedInput = {
    create?: XOR<producentkatalogCreateWithoutProducentInput, producentkatalogUncheckedCreateWithoutProducentInput> | producentkatalogCreateWithoutProducentInput[] | producentkatalogUncheckedCreateWithoutProducentInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutProducentInput | producentkatalogCreateOrConnectWithoutProducentInput[]
    upsert?: producentkatalogUpsertWithWhereUniqueWithoutProducentInput | producentkatalogUpsertWithWhereUniqueWithoutProducentInput[]
    createMany?: producentkatalogCreateManyProducentInputEnvelope
    set?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    disconnect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    delete?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    update?: producentkatalogUpdateWithWhereUniqueWithoutProducentInput | producentkatalogUpdateWithWhereUniqueWithoutProducentInput[]
    updateMany?: producentkatalogUpdateManyWithWhereWithoutProducentInput | producentkatalogUpdateManyWithWhereWithoutProducentInput[]
    deleteMany?: producentkatalogScalarWhereInput | producentkatalogScalarWhereInput[]
  }

  export type podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput = {
    create?: XOR<podwykonawcyCreateWithoutUzytkownikInput, podwykonawcyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: podwykonawcyCreateOrConnectWithoutUzytkownikInput
    upsert?: podwykonawcyUpsertWithoutUzytkownikInput
    disconnect?: podwykonawcyWhereInput | boolean
    delete?: podwykonawcyWhereInput | boolean
    connect?: podwykonawcyWhereUniqueInput
    update?: XOR<XOR<podwykonawcyUpdateToOneWithWhereWithoutUzytkownikInput, podwykonawcyUpdateWithoutUzytkownikInput>, podwykonawcyUncheckedUpdateWithoutUzytkownikInput>
  }

  export type freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput = {
    create?: XOR<freelancerzyCreateWithoutUzytkownikInput, freelancerzyUncheckedCreateWithoutUzytkownikInput>
    connectOrCreate?: freelancerzyCreateOrConnectWithoutUzytkownikInput
    upsert?: freelancerzyUpsertWithoutUzytkownikInput
    disconnect?: freelancerzyWhereInput | boolean
    delete?: freelancerzyWhereInput | boolean
    connect?: freelancerzyWhereUniqueInput
    update?: XOR<XOR<freelancerzyUpdateToOneWithWhereWithoutUzytkownikInput, freelancerzyUpdateWithoutUzytkownikInput>, freelancerzyUncheckedUpdateWithoutUzytkownikInput>
  }

  export type uzytkownicyCreateNestedManyWithoutRolaInput = {
    create?: XOR<uzytkownicyCreateWithoutRolaInput, uzytkownicyUncheckedCreateWithoutRolaInput> | uzytkownicyCreateWithoutRolaInput[] | uzytkownicyUncheckedCreateWithoutRolaInput[]
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutRolaInput | uzytkownicyCreateOrConnectWithoutRolaInput[]
    createMany?: uzytkownicyCreateManyRolaInputEnvelope
    connect?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
  }

  export type uzytkownicyUncheckedCreateNestedManyWithoutRolaInput = {
    create?: XOR<uzytkownicyCreateWithoutRolaInput, uzytkownicyUncheckedCreateWithoutRolaInput> | uzytkownicyCreateWithoutRolaInput[] | uzytkownicyUncheckedCreateWithoutRolaInput[]
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutRolaInput | uzytkownicyCreateOrConnectWithoutRolaInput[]
    createMany?: uzytkownicyCreateManyRolaInputEnvelope
    connect?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
  }

  export type uzytkownicyUpdateManyWithoutRolaNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutRolaInput, uzytkownicyUncheckedCreateWithoutRolaInput> | uzytkownicyCreateWithoutRolaInput[] | uzytkownicyUncheckedCreateWithoutRolaInput[]
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutRolaInput | uzytkownicyCreateOrConnectWithoutRolaInput[]
    upsert?: uzytkownicyUpsertWithWhereUniqueWithoutRolaInput | uzytkownicyUpsertWithWhereUniqueWithoutRolaInput[]
    createMany?: uzytkownicyCreateManyRolaInputEnvelope
    set?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    disconnect?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    delete?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    connect?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    update?: uzytkownicyUpdateWithWhereUniqueWithoutRolaInput | uzytkownicyUpdateWithWhereUniqueWithoutRolaInput[]
    updateMany?: uzytkownicyUpdateManyWithWhereWithoutRolaInput | uzytkownicyUpdateManyWithWhereWithoutRolaInput[]
    deleteMany?: uzytkownicyScalarWhereInput | uzytkownicyScalarWhereInput[]
  }

  export type uzytkownicyUncheckedUpdateManyWithoutRolaNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutRolaInput, uzytkownicyUncheckedCreateWithoutRolaInput> | uzytkownicyCreateWithoutRolaInput[] | uzytkownicyUncheckedCreateWithoutRolaInput[]
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutRolaInput | uzytkownicyCreateOrConnectWithoutRolaInput[]
    upsert?: uzytkownicyUpsertWithWhereUniqueWithoutRolaInput | uzytkownicyUpsertWithWhereUniqueWithoutRolaInput[]
    createMany?: uzytkownicyCreateManyRolaInputEnvelope
    set?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    disconnect?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    delete?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    connect?: uzytkownicyWhereUniqueInput | uzytkownicyWhereUniqueInput[]
    update?: uzytkownicyUpdateWithWhereUniqueWithoutRolaInput | uzytkownicyUpdateWithWhereUniqueWithoutRolaInput[]
    updateMany?: uzytkownicyUpdateManyWithWhereWithoutRolaInput | uzytkownicyUpdateManyWithWhereWithoutRolaInput[]
    deleteMany?: uzytkownicyScalarWhereInput | uzytkownicyScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutArtykulyInput = {
    create?: XOR<uzytkownicyCreateWithoutArtykulyInput, uzytkownicyUncheckedCreateWithoutArtykulyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutArtykulyInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type kategorieartykulowCreateNestedOneWithoutArtykulyInput = {
    create?: XOR<kategorieartykulowCreateWithoutArtykulyInput, kategorieartykulowUncheckedCreateWithoutArtykulyInput>
    connectOrCreate?: kategorieartykulowCreateOrConnectWithoutArtykulyInput
    connect?: kategorieartykulowWhereUniqueInput
  }

  export type uzytkownicyUpdateOneRequiredWithoutArtykulyNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutArtykulyInput, uzytkownicyUncheckedCreateWithoutArtykulyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutArtykulyInput
    upsert?: uzytkownicyUpsertWithoutArtykulyInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutArtykulyInput, uzytkownicyUpdateWithoutArtykulyInput>, uzytkownicyUncheckedUpdateWithoutArtykulyInput>
  }

  export type kategorieartykulowUpdateOneRequiredWithoutArtykulyNestedInput = {
    create?: XOR<kategorieartykulowCreateWithoutArtykulyInput, kategorieartykulowUncheckedCreateWithoutArtykulyInput>
    connectOrCreate?: kategorieartykulowCreateOrConnectWithoutArtykulyInput
    upsert?: kategorieartykulowUpsertWithoutArtykulyInput
    connect?: kategorieartykulowWhereUniqueInput
    update?: XOR<XOR<kategorieartykulowUpdateToOneWithWhereWithoutArtykulyInput, kategorieartykulowUpdateWithoutArtykulyInput>, kategorieartykulowUncheckedUpdateWithoutArtykulyInput>
  }

  export type artykulyCreateNestedManyWithoutKategoriaInput = {
    create?: XOR<artykulyCreateWithoutKategoriaInput, artykulyUncheckedCreateWithoutKategoriaInput> | artykulyCreateWithoutKategoriaInput[] | artykulyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutKategoriaInput | artykulyCreateOrConnectWithoutKategoriaInput[]
    createMany?: artykulyCreateManyKategoriaInputEnvelope
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
  }

  export type artykulyUncheckedCreateNestedManyWithoutKategoriaInput = {
    create?: XOR<artykulyCreateWithoutKategoriaInput, artykulyUncheckedCreateWithoutKategoriaInput> | artykulyCreateWithoutKategoriaInput[] | artykulyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutKategoriaInput | artykulyCreateOrConnectWithoutKategoriaInput[]
    createMany?: artykulyCreateManyKategoriaInputEnvelope
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
  }

  export type artykulyUpdateManyWithoutKategoriaNestedInput = {
    create?: XOR<artykulyCreateWithoutKategoriaInput, artykulyUncheckedCreateWithoutKategoriaInput> | artykulyCreateWithoutKategoriaInput[] | artykulyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutKategoriaInput | artykulyCreateOrConnectWithoutKategoriaInput[]
    upsert?: artykulyUpsertWithWhereUniqueWithoutKategoriaInput | artykulyUpsertWithWhereUniqueWithoutKategoriaInput[]
    createMany?: artykulyCreateManyKategoriaInputEnvelope
    set?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    disconnect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    delete?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    update?: artykulyUpdateWithWhereUniqueWithoutKategoriaInput | artykulyUpdateWithWhereUniqueWithoutKategoriaInput[]
    updateMany?: artykulyUpdateManyWithWhereWithoutKategoriaInput | artykulyUpdateManyWithWhereWithoutKategoriaInput[]
    deleteMany?: artykulyScalarWhereInput | artykulyScalarWhereInput[]
  }

  export type artykulyUncheckedUpdateManyWithoutKategoriaNestedInput = {
    create?: XOR<artykulyCreateWithoutKategoriaInput, artykulyUncheckedCreateWithoutKategoriaInput> | artykulyCreateWithoutKategoriaInput[] | artykulyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: artykulyCreateOrConnectWithoutKategoriaInput | artykulyCreateOrConnectWithoutKategoriaInput[]
    upsert?: artykulyUpsertWithWhereUniqueWithoutKategoriaInput | artykulyUpsertWithWhereUniqueWithoutKategoriaInput[]
    createMany?: artykulyCreateManyKategoriaInputEnvelope
    set?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    disconnect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    delete?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    connect?: artykulyWhereUniqueInput | artykulyWhereUniqueInput[]
    update?: artykulyUpdateWithWhereUniqueWithoutKategoriaInput | artykulyUpdateWithWhereUniqueWithoutKategoriaInput[]
    updateMany?: artykulyUpdateManyWithWhereWithoutKategoriaInput | artykulyUpdateManyWithWhereWithoutKategoriaInput[]
    deleteMany?: artykulyScalarWhereInput | artykulyScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutProduktyInput = {
    create?: XOR<uzytkownicyCreateWithoutProduktyInput, uzytkownicyUncheckedCreateWithoutProduktyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutProduktyInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type kategorieproduktowCreateNestedOneWithoutProduktyInput = {
    create?: XOR<kategorieproduktowCreateWithoutProduktyInput, kategorieproduktowUncheckedCreateWithoutProduktyInput>
    connectOrCreate?: kategorieproduktowCreateOrConnectWithoutProduktyInput
    connect?: kategorieproduktowWhereUniqueInput
  }

  export type zamowieniaCreateNestedManyWithoutProduktInput = {
    create?: XOR<zamowieniaCreateWithoutProduktInput, zamowieniaUncheckedCreateWithoutProduktInput> | zamowieniaCreateWithoutProduktInput[] | zamowieniaUncheckedCreateWithoutProduktInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutProduktInput | zamowieniaCreateOrConnectWithoutProduktInput[]
    createMany?: zamowieniaCreateManyProduktInputEnvelope
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
  }

  export type zamowieniaUncheckedCreateNestedManyWithoutProduktInput = {
    create?: XOR<zamowieniaCreateWithoutProduktInput, zamowieniaUncheckedCreateWithoutProduktInput> | zamowieniaCreateWithoutProduktInput[] | zamowieniaUncheckedCreateWithoutProduktInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutProduktInput | zamowieniaCreateOrConnectWithoutProduktInput[]
    createMany?: zamowieniaCreateManyProduktInputEnvelope
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type uzytkownicyUpdateOneRequiredWithoutProduktyNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutProduktyInput, uzytkownicyUncheckedCreateWithoutProduktyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutProduktyInput
    upsert?: uzytkownicyUpsertWithoutProduktyInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutProduktyInput, uzytkownicyUpdateWithoutProduktyInput>, uzytkownicyUncheckedUpdateWithoutProduktyInput>
  }

  export type kategorieproduktowUpdateOneRequiredWithoutProduktyNestedInput = {
    create?: XOR<kategorieproduktowCreateWithoutProduktyInput, kategorieproduktowUncheckedCreateWithoutProduktyInput>
    connectOrCreate?: kategorieproduktowCreateOrConnectWithoutProduktyInput
    upsert?: kategorieproduktowUpsertWithoutProduktyInput
    connect?: kategorieproduktowWhereUniqueInput
    update?: XOR<XOR<kategorieproduktowUpdateToOneWithWhereWithoutProduktyInput, kategorieproduktowUpdateWithoutProduktyInput>, kategorieproduktowUncheckedUpdateWithoutProduktyInput>
  }

  export type zamowieniaUpdateManyWithoutProduktNestedInput = {
    create?: XOR<zamowieniaCreateWithoutProduktInput, zamowieniaUncheckedCreateWithoutProduktInput> | zamowieniaCreateWithoutProduktInput[] | zamowieniaUncheckedCreateWithoutProduktInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutProduktInput | zamowieniaCreateOrConnectWithoutProduktInput[]
    upsert?: zamowieniaUpsertWithWhereUniqueWithoutProduktInput | zamowieniaUpsertWithWhereUniqueWithoutProduktInput[]
    createMany?: zamowieniaCreateManyProduktInputEnvelope
    set?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    disconnect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    delete?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    update?: zamowieniaUpdateWithWhereUniqueWithoutProduktInput | zamowieniaUpdateWithWhereUniqueWithoutProduktInput[]
    updateMany?: zamowieniaUpdateManyWithWhereWithoutProduktInput | zamowieniaUpdateManyWithWhereWithoutProduktInput[]
    deleteMany?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
  }

  export type zamowieniaUncheckedUpdateManyWithoutProduktNestedInput = {
    create?: XOR<zamowieniaCreateWithoutProduktInput, zamowieniaUncheckedCreateWithoutProduktInput> | zamowieniaCreateWithoutProduktInput[] | zamowieniaUncheckedCreateWithoutProduktInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutProduktInput | zamowieniaCreateOrConnectWithoutProduktInput[]
    upsert?: zamowieniaUpsertWithWhereUniqueWithoutProduktInput | zamowieniaUpsertWithWhereUniqueWithoutProduktInput[]
    createMany?: zamowieniaCreateManyProduktInputEnvelope
    set?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    disconnect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    delete?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    update?: zamowieniaUpdateWithWhereUniqueWithoutProduktInput | zamowieniaUpdateWithWhereUniqueWithoutProduktInput[]
    updateMany?: zamowieniaUpdateManyWithWhereWithoutProduktInput | zamowieniaUpdateManyWithWhereWithoutProduktInput[]
    deleteMany?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
  }

  export type produktyCreateNestedManyWithoutKategoriaInput = {
    create?: XOR<produktyCreateWithoutKategoriaInput, produktyUncheckedCreateWithoutKategoriaInput> | produktyCreateWithoutKategoriaInput[] | produktyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutKategoriaInput | produktyCreateOrConnectWithoutKategoriaInput[]
    createMany?: produktyCreateManyKategoriaInputEnvelope
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
  }

  export type produktyUncheckedCreateNestedManyWithoutKategoriaInput = {
    create?: XOR<produktyCreateWithoutKategoriaInput, produktyUncheckedCreateWithoutKategoriaInput> | produktyCreateWithoutKategoriaInput[] | produktyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutKategoriaInput | produktyCreateOrConnectWithoutKategoriaInput[]
    createMany?: produktyCreateManyKategoriaInputEnvelope
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
  }

  export type produktyUpdateManyWithoutKategoriaNestedInput = {
    create?: XOR<produktyCreateWithoutKategoriaInput, produktyUncheckedCreateWithoutKategoriaInput> | produktyCreateWithoutKategoriaInput[] | produktyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutKategoriaInput | produktyCreateOrConnectWithoutKategoriaInput[]
    upsert?: produktyUpsertWithWhereUniqueWithoutKategoriaInput | produktyUpsertWithWhereUniqueWithoutKategoriaInput[]
    createMany?: produktyCreateManyKategoriaInputEnvelope
    set?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    disconnect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    delete?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    update?: produktyUpdateWithWhereUniqueWithoutKategoriaInput | produktyUpdateWithWhereUniqueWithoutKategoriaInput[]
    updateMany?: produktyUpdateManyWithWhereWithoutKategoriaInput | produktyUpdateManyWithWhereWithoutKategoriaInput[]
    deleteMany?: produktyScalarWhereInput | produktyScalarWhereInput[]
  }

  export type produktyUncheckedUpdateManyWithoutKategoriaNestedInput = {
    create?: XOR<produktyCreateWithoutKategoriaInput, produktyUncheckedCreateWithoutKategoriaInput> | produktyCreateWithoutKategoriaInput[] | produktyUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: produktyCreateOrConnectWithoutKategoriaInput | produktyCreateOrConnectWithoutKategoriaInput[]
    upsert?: produktyUpsertWithWhereUniqueWithoutKategoriaInput | produktyUpsertWithWhereUniqueWithoutKategoriaInput[]
    createMany?: produktyCreateManyKategoriaInputEnvelope
    set?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    disconnect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    delete?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    connect?: produktyWhereUniqueInput | produktyWhereUniqueInput[]
    update?: produktyUpdateWithWhereUniqueWithoutKategoriaInput | produktyUpdateWithWhereUniqueWithoutKategoriaInput[]
    updateMany?: produktyUpdateManyWithWhereWithoutKategoriaInput | produktyUpdateManyWithWhereWithoutKategoriaInput[]
    deleteMany?: produktyScalarWhereInput | produktyScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutZamowieniaInput = {
    create?: XOR<uzytkownicyCreateWithoutZamowieniaInput, uzytkownicyUncheckedCreateWithoutZamowieniaInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutZamowieniaInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type produktyCreateNestedOneWithoutZamowieniaInput = {
    create?: XOR<produktyCreateWithoutZamowieniaInput, produktyUncheckedCreateWithoutZamowieniaInput>
    connectOrCreate?: produktyCreateOrConnectWithoutZamowieniaInput
    connect?: produktyWhereUniqueInput
  }

  export type statusyzamowienCreateNestedOneWithoutZamowieniaInput = {
    create?: XOR<statusyzamowienCreateWithoutZamowieniaInput, statusyzamowienUncheckedCreateWithoutZamowieniaInput>
    connectOrCreate?: statusyzamowienCreateOrConnectWithoutZamowieniaInput
    connect?: statusyzamowienWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type uzytkownicyUpdateOneRequiredWithoutZamowieniaNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutZamowieniaInput, uzytkownicyUncheckedCreateWithoutZamowieniaInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutZamowieniaInput
    upsert?: uzytkownicyUpsertWithoutZamowieniaInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutZamowieniaInput, uzytkownicyUpdateWithoutZamowieniaInput>, uzytkownicyUncheckedUpdateWithoutZamowieniaInput>
  }

  export type produktyUpdateOneRequiredWithoutZamowieniaNestedInput = {
    create?: XOR<produktyCreateWithoutZamowieniaInput, produktyUncheckedCreateWithoutZamowieniaInput>
    connectOrCreate?: produktyCreateOrConnectWithoutZamowieniaInput
    upsert?: produktyUpsertWithoutZamowieniaInput
    connect?: produktyWhereUniqueInput
    update?: XOR<XOR<produktyUpdateToOneWithWhereWithoutZamowieniaInput, produktyUpdateWithoutZamowieniaInput>, produktyUncheckedUpdateWithoutZamowieniaInput>
  }

  export type statusyzamowienUpdateOneRequiredWithoutZamowieniaNestedInput = {
    create?: XOR<statusyzamowienCreateWithoutZamowieniaInput, statusyzamowienUncheckedCreateWithoutZamowieniaInput>
    connectOrCreate?: statusyzamowienCreateOrConnectWithoutZamowieniaInput
    upsert?: statusyzamowienUpsertWithoutZamowieniaInput
    connect?: statusyzamowienWhereUniqueInput
    update?: XOR<XOR<statusyzamowienUpdateToOneWithWhereWithoutZamowieniaInput, statusyzamowienUpdateWithoutZamowieniaInput>, statusyzamowienUncheckedUpdateWithoutZamowieniaInput>
  }

  export type zamowieniaCreateNestedManyWithoutStatusInput = {
    create?: XOR<zamowieniaCreateWithoutStatusInput, zamowieniaUncheckedCreateWithoutStatusInput> | zamowieniaCreateWithoutStatusInput[] | zamowieniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutStatusInput | zamowieniaCreateOrConnectWithoutStatusInput[]
    createMany?: zamowieniaCreateManyStatusInputEnvelope
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
  }

  export type zamowieniaUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<zamowieniaCreateWithoutStatusInput, zamowieniaUncheckedCreateWithoutStatusInput> | zamowieniaCreateWithoutStatusInput[] | zamowieniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutStatusInput | zamowieniaCreateOrConnectWithoutStatusInput[]
    createMany?: zamowieniaCreateManyStatusInputEnvelope
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
  }

  export type zamowieniaUpdateManyWithoutStatusNestedInput = {
    create?: XOR<zamowieniaCreateWithoutStatusInput, zamowieniaUncheckedCreateWithoutStatusInput> | zamowieniaCreateWithoutStatusInput[] | zamowieniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutStatusInput | zamowieniaCreateOrConnectWithoutStatusInput[]
    upsert?: zamowieniaUpsertWithWhereUniqueWithoutStatusInput | zamowieniaUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: zamowieniaCreateManyStatusInputEnvelope
    set?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    disconnect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    delete?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    update?: zamowieniaUpdateWithWhereUniqueWithoutStatusInput | zamowieniaUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: zamowieniaUpdateManyWithWhereWithoutStatusInput | zamowieniaUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
  }

  export type zamowieniaUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<zamowieniaCreateWithoutStatusInput, zamowieniaUncheckedCreateWithoutStatusInput> | zamowieniaCreateWithoutStatusInput[] | zamowieniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zamowieniaCreateOrConnectWithoutStatusInput | zamowieniaCreateOrConnectWithoutStatusInput[]
    upsert?: zamowieniaUpsertWithWhereUniqueWithoutStatusInput | zamowieniaUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: zamowieniaCreateManyStatusInputEnvelope
    set?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    disconnect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    delete?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    connect?: zamowieniaWhereUniqueInput | zamowieniaWhereUniqueInput[]
    update?: zamowieniaUpdateWithWhereUniqueWithoutStatusInput | zamowieniaUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: zamowieniaUpdateManyWithWhereWithoutStatusInput | zamowieniaUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutZlecenia_zleceniodawcaInput = {
    create?: XOR<uzytkownicyCreateWithoutZlecenia_zleceniodawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_zleceniodawcaInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutZlecenia_zleceniodawcaInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type uzytkownicyCreateNestedOneWithoutZlecenia_wykonawcaInput = {
    create?: XOR<uzytkownicyCreateWithoutZlecenia_wykonawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_wykonawcaInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutZlecenia_wykonawcaInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type statusyzlecenCreateNestedOneWithoutZleceniaInput = {
    create?: XOR<statusyzlecenCreateWithoutZleceniaInput, statusyzlecenUncheckedCreateWithoutZleceniaInput>
    connectOrCreate?: statusyzlecenCreateOrConnectWithoutZleceniaInput
    connect?: statusyzlecenWhereUniqueInput
  }

  export type typyzlecenCreateNestedOneWithoutZleceniaInput = {
    create?: XOR<typyzlecenCreateWithoutZleceniaInput, typyzlecenUncheckedCreateWithoutZleceniaInput>
    connectOrCreate?: typyzlecenCreateOrConnectWithoutZleceniaInput
    connect?: typyzlecenWhereUniqueInput
  }

  export type uzytkownicyUpdateOneRequiredWithoutZlecenia_zleceniodawcaNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutZlecenia_zleceniodawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_zleceniodawcaInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutZlecenia_zleceniodawcaInput
    upsert?: uzytkownicyUpsertWithoutZlecenia_zleceniodawcaInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutZlecenia_zleceniodawcaInput, uzytkownicyUpdateWithoutZlecenia_zleceniodawcaInput>, uzytkownicyUncheckedUpdateWithoutZlecenia_zleceniodawcaInput>
  }

  export type uzytkownicyUpdateOneRequiredWithoutZlecenia_wykonawcaNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutZlecenia_wykonawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_wykonawcaInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutZlecenia_wykonawcaInput
    upsert?: uzytkownicyUpsertWithoutZlecenia_wykonawcaInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutZlecenia_wykonawcaInput, uzytkownicyUpdateWithoutZlecenia_wykonawcaInput>, uzytkownicyUncheckedUpdateWithoutZlecenia_wykonawcaInput>
  }

  export type statusyzlecenUpdateOneRequiredWithoutZleceniaNestedInput = {
    create?: XOR<statusyzlecenCreateWithoutZleceniaInput, statusyzlecenUncheckedCreateWithoutZleceniaInput>
    connectOrCreate?: statusyzlecenCreateOrConnectWithoutZleceniaInput
    upsert?: statusyzlecenUpsertWithoutZleceniaInput
    connect?: statusyzlecenWhereUniqueInput
    update?: XOR<XOR<statusyzlecenUpdateToOneWithWhereWithoutZleceniaInput, statusyzlecenUpdateWithoutZleceniaInput>, statusyzlecenUncheckedUpdateWithoutZleceniaInput>
  }

  export type typyzlecenUpdateOneRequiredWithoutZleceniaNestedInput = {
    create?: XOR<typyzlecenCreateWithoutZleceniaInput, typyzlecenUncheckedCreateWithoutZleceniaInput>
    connectOrCreate?: typyzlecenCreateOrConnectWithoutZleceniaInput
    upsert?: typyzlecenUpsertWithoutZleceniaInput
    connect?: typyzlecenWhereUniqueInput
    update?: XOR<XOR<typyzlecenUpdateToOneWithWhereWithoutZleceniaInput, typyzlecenUpdateWithoutZleceniaInput>, typyzlecenUncheckedUpdateWithoutZleceniaInput>
  }

  export type zleceniaCreateNestedManyWithoutStatusInput = {
    create?: XOR<zleceniaCreateWithoutStatusInput, zleceniaUncheckedCreateWithoutStatusInput> | zleceniaCreateWithoutStatusInput[] | zleceniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutStatusInput | zleceniaCreateOrConnectWithoutStatusInput[]
    createMany?: zleceniaCreateManyStatusInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type zleceniaUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<zleceniaCreateWithoutStatusInput, zleceniaUncheckedCreateWithoutStatusInput> | zleceniaCreateWithoutStatusInput[] | zleceniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutStatusInput | zleceniaCreateOrConnectWithoutStatusInput[]
    createMany?: zleceniaCreateManyStatusInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type zleceniaUpdateManyWithoutStatusNestedInput = {
    create?: XOR<zleceniaCreateWithoutStatusInput, zleceniaUncheckedCreateWithoutStatusInput> | zleceniaCreateWithoutStatusInput[] | zleceniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutStatusInput | zleceniaCreateOrConnectWithoutStatusInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutStatusInput | zleceniaUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: zleceniaCreateManyStatusInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutStatusInput | zleceniaUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutStatusInput | zleceniaUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type zleceniaUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<zleceniaCreateWithoutStatusInput, zleceniaUncheckedCreateWithoutStatusInput> | zleceniaCreateWithoutStatusInput[] | zleceniaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutStatusInput | zleceniaCreateOrConnectWithoutStatusInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutStatusInput | zleceniaUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: zleceniaCreateManyStatusInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutStatusInput | zleceniaUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutStatusInput | zleceniaUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type zleceniaCreateNestedManyWithoutTypInput = {
    create?: XOR<zleceniaCreateWithoutTypInput, zleceniaUncheckedCreateWithoutTypInput> | zleceniaCreateWithoutTypInput[] | zleceniaUncheckedCreateWithoutTypInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutTypInput | zleceniaCreateOrConnectWithoutTypInput[]
    createMany?: zleceniaCreateManyTypInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type zleceniaUncheckedCreateNestedManyWithoutTypInput = {
    create?: XOR<zleceniaCreateWithoutTypInput, zleceniaUncheckedCreateWithoutTypInput> | zleceniaCreateWithoutTypInput[] | zleceniaUncheckedCreateWithoutTypInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutTypInput | zleceniaCreateOrConnectWithoutTypInput[]
    createMany?: zleceniaCreateManyTypInputEnvelope
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
  }

  export type zleceniaUpdateManyWithoutTypNestedInput = {
    create?: XOR<zleceniaCreateWithoutTypInput, zleceniaUncheckedCreateWithoutTypInput> | zleceniaCreateWithoutTypInput[] | zleceniaUncheckedCreateWithoutTypInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutTypInput | zleceniaCreateOrConnectWithoutTypInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutTypInput | zleceniaUpsertWithWhereUniqueWithoutTypInput[]
    createMany?: zleceniaCreateManyTypInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutTypInput | zleceniaUpdateWithWhereUniqueWithoutTypInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutTypInput | zleceniaUpdateManyWithWhereWithoutTypInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type zleceniaUncheckedUpdateManyWithoutTypNestedInput = {
    create?: XOR<zleceniaCreateWithoutTypInput, zleceniaUncheckedCreateWithoutTypInput> | zleceniaCreateWithoutTypInput[] | zleceniaUncheckedCreateWithoutTypInput[]
    connectOrCreate?: zleceniaCreateOrConnectWithoutTypInput | zleceniaCreateOrConnectWithoutTypInput[]
    upsert?: zleceniaUpsertWithWhereUniqueWithoutTypInput | zleceniaUpsertWithWhereUniqueWithoutTypInput[]
    createMany?: zleceniaCreateManyTypInputEnvelope
    set?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    disconnect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    delete?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    connect?: zleceniaWhereUniqueInput | zleceniaWhereUniqueInput[]
    update?: zleceniaUpdateWithWhereUniqueWithoutTypInput | zleceniaUpdateWithWhereUniqueWithoutTypInput[]
    updateMany?: zleceniaUpdateManyWithWhereWithoutTypInput | zleceniaUpdateManyWithWhereWithoutTypInput[]
    deleteMany?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutProjektyInput = {
    create?: XOR<uzytkownicyCreateWithoutProjektyInput, uzytkownicyUncheckedCreateWithoutProjektyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutProjektyInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type statusyprojektowCreateNestedOneWithoutProjektyInput = {
    create?: XOR<statusyprojektowCreateWithoutProjektyInput, statusyprojektowUncheckedCreateWithoutProjektyInput>
    connectOrCreate?: statusyprojektowCreateOrConnectWithoutProjektyInput
    connect?: statusyprojektowWhereUniqueInput
  }

  export type uzytkownicyUpdateOneRequiredWithoutProjektyNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutProjektyInput, uzytkownicyUncheckedCreateWithoutProjektyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutProjektyInput
    upsert?: uzytkownicyUpsertWithoutProjektyInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutProjektyInput, uzytkownicyUpdateWithoutProjektyInput>, uzytkownicyUncheckedUpdateWithoutProjektyInput>
  }

  export type statusyprojektowUpdateOneRequiredWithoutProjektyNestedInput = {
    create?: XOR<statusyprojektowCreateWithoutProjektyInput, statusyprojektowUncheckedCreateWithoutProjektyInput>
    connectOrCreate?: statusyprojektowCreateOrConnectWithoutProjektyInput
    upsert?: statusyprojektowUpsertWithoutProjektyInput
    connect?: statusyprojektowWhereUniqueInput
    update?: XOR<XOR<statusyprojektowUpdateToOneWithWhereWithoutProjektyInput, statusyprojektowUpdateWithoutProjektyInput>, statusyprojektowUncheckedUpdateWithoutProjektyInput>
  }

  export type projektyCreateNestedManyWithoutStatusInput = {
    create?: XOR<projektyCreateWithoutStatusInput, projektyUncheckedCreateWithoutStatusInput> | projektyCreateWithoutStatusInput[] | projektyUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutStatusInput | projektyCreateOrConnectWithoutStatusInput[]
    createMany?: projektyCreateManyStatusInputEnvelope
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
  }

  export type projektyUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<projektyCreateWithoutStatusInput, projektyUncheckedCreateWithoutStatusInput> | projektyCreateWithoutStatusInput[] | projektyUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutStatusInput | projektyCreateOrConnectWithoutStatusInput[]
    createMany?: projektyCreateManyStatusInputEnvelope
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
  }

  export type projektyUpdateManyWithoutStatusNestedInput = {
    create?: XOR<projektyCreateWithoutStatusInput, projektyUncheckedCreateWithoutStatusInput> | projektyCreateWithoutStatusInput[] | projektyUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutStatusInput | projektyCreateOrConnectWithoutStatusInput[]
    upsert?: projektyUpsertWithWhereUniqueWithoutStatusInput | projektyUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: projektyCreateManyStatusInputEnvelope
    set?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    disconnect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    delete?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    update?: projektyUpdateWithWhereUniqueWithoutStatusInput | projektyUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: projektyUpdateManyWithWhereWithoutStatusInput | projektyUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: projektyScalarWhereInput | projektyScalarWhereInput[]
  }

  export type projektyUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<projektyCreateWithoutStatusInput, projektyUncheckedCreateWithoutStatusInput> | projektyCreateWithoutStatusInput[] | projektyUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: projektyCreateOrConnectWithoutStatusInput | projektyCreateOrConnectWithoutStatusInput[]
    upsert?: projektyUpsertWithWhereUniqueWithoutStatusInput | projektyUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: projektyCreateManyStatusInputEnvelope
    set?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    disconnect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    delete?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    connect?: projektyWhereUniqueInput | projektyWhereUniqueInput[]
    update?: projektyUpdateWithWhereUniqueWithoutStatusInput | projektyUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: projektyUpdateManyWithWhereWithoutStatusInput | projektyUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: projektyScalarWhereInput | projektyScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutProducent_katalogInput = {
    create?: XOR<uzytkownicyCreateWithoutProducent_katalogInput, uzytkownicyUncheckedCreateWithoutProducent_katalogInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutProducent_katalogInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type kategorieproducentowCreateNestedOneWithoutProducentkatalogInput = {
    create?: XOR<kategorieproducentowCreateWithoutProducentkatalogInput, kategorieproducentowUncheckedCreateWithoutProducentkatalogInput>
    connectOrCreate?: kategorieproducentowCreateOrConnectWithoutProducentkatalogInput
    connect?: kategorieproducentowWhereUniqueInput
  }

  export type uzytkownicyUpdateOneRequiredWithoutProducent_katalogNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutProducent_katalogInput, uzytkownicyUncheckedCreateWithoutProducent_katalogInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutProducent_katalogInput
    upsert?: uzytkownicyUpsertWithoutProducent_katalogInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutProducent_katalogInput, uzytkownicyUpdateWithoutProducent_katalogInput>, uzytkownicyUncheckedUpdateWithoutProducent_katalogInput>
  }

  export type kategorieproducentowUpdateOneRequiredWithoutProducentkatalogNestedInput = {
    create?: XOR<kategorieproducentowCreateWithoutProducentkatalogInput, kategorieproducentowUncheckedCreateWithoutProducentkatalogInput>
    connectOrCreate?: kategorieproducentowCreateOrConnectWithoutProducentkatalogInput
    upsert?: kategorieproducentowUpsertWithoutProducentkatalogInput
    connect?: kategorieproducentowWhereUniqueInput
    update?: XOR<XOR<kategorieproducentowUpdateToOneWithWhereWithoutProducentkatalogInput, kategorieproducentowUpdateWithoutProducentkatalogInput>, kategorieproducentowUncheckedUpdateWithoutProducentkatalogInput>
  }

  export type producentkatalogCreateNestedManyWithoutKategoriaInput = {
    create?: XOR<producentkatalogCreateWithoutKategoriaInput, producentkatalogUncheckedCreateWithoutKategoriaInput> | producentkatalogCreateWithoutKategoriaInput[] | producentkatalogUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutKategoriaInput | producentkatalogCreateOrConnectWithoutKategoriaInput[]
    createMany?: producentkatalogCreateManyKategoriaInputEnvelope
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
  }

  export type producentkatalogUncheckedCreateNestedManyWithoutKategoriaInput = {
    create?: XOR<producentkatalogCreateWithoutKategoriaInput, producentkatalogUncheckedCreateWithoutKategoriaInput> | producentkatalogCreateWithoutKategoriaInput[] | producentkatalogUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutKategoriaInput | producentkatalogCreateOrConnectWithoutKategoriaInput[]
    createMany?: producentkatalogCreateManyKategoriaInputEnvelope
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
  }

  export type producentkatalogUpdateManyWithoutKategoriaNestedInput = {
    create?: XOR<producentkatalogCreateWithoutKategoriaInput, producentkatalogUncheckedCreateWithoutKategoriaInput> | producentkatalogCreateWithoutKategoriaInput[] | producentkatalogUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutKategoriaInput | producentkatalogCreateOrConnectWithoutKategoriaInput[]
    upsert?: producentkatalogUpsertWithWhereUniqueWithoutKategoriaInput | producentkatalogUpsertWithWhereUniqueWithoutKategoriaInput[]
    createMany?: producentkatalogCreateManyKategoriaInputEnvelope
    set?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    disconnect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    delete?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    update?: producentkatalogUpdateWithWhereUniqueWithoutKategoriaInput | producentkatalogUpdateWithWhereUniqueWithoutKategoriaInput[]
    updateMany?: producentkatalogUpdateManyWithWhereWithoutKategoriaInput | producentkatalogUpdateManyWithWhereWithoutKategoriaInput[]
    deleteMany?: producentkatalogScalarWhereInput | producentkatalogScalarWhereInput[]
  }

  export type producentkatalogUncheckedUpdateManyWithoutKategoriaNestedInput = {
    create?: XOR<producentkatalogCreateWithoutKategoriaInput, producentkatalogUncheckedCreateWithoutKategoriaInput> | producentkatalogCreateWithoutKategoriaInput[] | producentkatalogUncheckedCreateWithoutKategoriaInput[]
    connectOrCreate?: producentkatalogCreateOrConnectWithoutKategoriaInput | producentkatalogCreateOrConnectWithoutKategoriaInput[]
    upsert?: producentkatalogUpsertWithWhereUniqueWithoutKategoriaInput | producentkatalogUpsertWithWhereUniqueWithoutKategoriaInput[]
    createMany?: producentkatalogCreateManyKategoriaInputEnvelope
    set?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    disconnect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    delete?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    connect?: producentkatalogWhereUniqueInput | producentkatalogWhereUniqueInput[]
    update?: producentkatalogUpdateWithWhereUniqueWithoutKategoriaInput | producentkatalogUpdateWithWhereUniqueWithoutKategoriaInput[]
    updateMany?: producentkatalogUpdateManyWithWhereWithoutKategoriaInput | producentkatalogUpdateManyWithWhereWithoutKategoriaInput[]
    deleteMany?: producentkatalogScalarWhereInput | producentkatalogScalarWhereInput[]
  }

  export type uzytkownicyCreateNestedOneWithoutPodwykonawcyInput = {
    create?: XOR<uzytkownicyCreateWithoutPodwykonawcyInput, uzytkownicyUncheckedCreateWithoutPodwykonawcyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutPodwykonawcyInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type uzytkownicyUpdateOneRequiredWithoutPodwykonawcyNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutPodwykonawcyInput, uzytkownicyUncheckedCreateWithoutPodwykonawcyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutPodwykonawcyInput
    upsert?: uzytkownicyUpsertWithoutPodwykonawcyInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutPodwykonawcyInput, uzytkownicyUpdateWithoutPodwykonawcyInput>, uzytkownicyUncheckedUpdateWithoutPodwykonawcyInput>
  }

  export type uzytkownicyCreateNestedOneWithoutFreelancerzyInput = {
    create?: XOR<uzytkownicyCreateWithoutFreelancerzyInput, uzytkownicyUncheckedCreateWithoutFreelancerzyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutFreelancerzyInput
    connect?: uzytkownicyWhereUniqueInput
  }

  export type uzytkownicyUpdateOneRequiredWithoutFreelancerzyNestedInput = {
    create?: XOR<uzytkownicyCreateWithoutFreelancerzyInput, uzytkownicyUncheckedCreateWithoutFreelancerzyInput>
    connectOrCreate?: uzytkownicyCreateOrConnectWithoutFreelancerzyInput
    upsert?: uzytkownicyUpsertWithoutFreelancerzyInput
    connect?: uzytkownicyWhereUniqueInput
    update?: XOR<XOR<uzytkownicyUpdateToOneWithWhereWithoutFreelancerzyInput, uzytkownicyUpdateWithoutFreelancerzyInput>, uzytkownicyUncheckedUpdateWithoutFreelancerzyInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type roleCreateWithoutUzytkownicyInput = {
    nazwa: string
  }

  export type roleUncheckedCreateWithoutUzytkownicyInput = {
    id?: number
    nazwa: string
  }

  export type roleCreateOrConnectWithoutUzytkownicyInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUzytkownicyInput, roleUncheckedCreateWithoutUzytkownicyInput>
  }

  export type artykulyCreateWithoutAutorInput = {
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    kategoria: kategorieartykulowCreateNestedOneWithoutArtykulyInput
  }

  export type artykulyUncheckedCreateWithoutAutorInput = {
    id?: number
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    kategoria_id: number
  }

  export type artykulyCreateOrConnectWithoutAutorInput = {
    where: artykulyWhereUniqueInput
    create: XOR<artykulyCreateWithoutAutorInput, artykulyUncheckedCreateWithoutAutorInput>
  }

  export type artykulyCreateManyAutorInputEnvelope = {
    data: artykulyCreateManyAutorInput | artykulyCreateManyAutorInput[]
    skipDuplicates?: boolean
  }

  export type produktyCreateWithoutProducentInput = {
    nazwa?: string | null
    opis?: string | null
    cena?: Decimal | DecimalJsLike | number | string | null
    data_dodania?: Date | string | null
    kategoria: kategorieproduktowCreateNestedOneWithoutProduktyInput
    zamowienia?: zamowieniaCreateNestedManyWithoutProduktInput
  }

  export type produktyUncheckedCreateWithoutProducentInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    cena?: Decimal | DecimalJsLike | number | string | null
    kategoria_id: number
    data_dodania?: Date | string | null
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutProduktInput
  }

  export type produktyCreateOrConnectWithoutProducentInput = {
    where: produktyWhereUniqueInput
    create: XOR<produktyCreateWithoutProducentInput, produktyUncheckedCreateWithoutProducentInput>
  }

  export type produktyCreateManyProducentInputEnvelope = {
    data: produktyCreateManyProducentInput | produktyCreateManyProducentInput[]
    skipDuplicates?: boolean
  }

  export type zamowieniaCreateWithoutUzytkownikInput = {
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    produkt: produktyCreateNestedOneWithoutZamowieniaInput
    status: statusyzamowienCreateNestedOneWithoutZamowieniaInput
  }

  export type zamowieniaUncheckedCreateWithoutUzytkownikInput = {
    id?: number
    produkt_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    status_id: number
  }

  export type zamowieniaCreateOrConnectWithoutUzytkownikInput = {
    where: zamowieniaWhereUniqueInput
    create: XOR<zamowieniaCreateWithoutUzytkownikInput, zamowieniaUncheckedCreateWithoutUzytkownikInput>
  }

  export type zamowieniaCreateManyUzytkownikInputEnvelope = {
    data: zamowieniaCreateManyUzytkownikInput | zamowieniaCreateManyUzytkownikInput[]
    skipDuplicates?: boolean
  }

  export type zleceniaCreateWithoutZleceniodawcaInput = {
    tytul?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    wykonawca: uzytkownicyCreateNestedOneWithoutZlecenia_wykonawcaInput
    status: statusyzlecenCreateNestedOneWithoutZleceniaInput
    typ: typyzlecenCreateNestedOneWithoutZleceniaInput
  }

  export type zleceniaUncheckedCreateWithoutZleceniodawcaInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
    typ_id: number
  }

  export type zleceniaCreateOrConnectWithoutZleceniodawcaInput = {
    where: zleceniaWhereUniqueInput
    create: XOR<zleceniaCreateWithoutZleceniodawcaInput, zleceniaUncheckedCreateWithoutZleceniodawcaInput>
  }

  export type zleceniaCreateManyZleceniodawcaInputEnvelope = {
    data: zleceniaCreateManyZleceniodawcaInput | zleceniaCreateManyZleceniodawcaInput[]
    skipDuplicates?: boolean
  }

  export type zleceniaCreateWithoutWykonawcaInput = {
    tytul?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    zleceniodawca: uzytkownicyCreateNestedOneWithoutZlecenia_zleceniodawcaInput
    status: statusyzlecenCreateNestedOneWithoutZleceniaInput
    typ: typyzlecenCreateNestedOneWithoutZleceniaInput
  }

  export type zleceniaUncheckedCreateWithoutWykonawcaInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
    typ_id: number
  }

  export type zleceniaCreateOrConnectWithoutWykonawcaInput = {
    where: zleceniaWhereUniqueInput
    create: XOR<zleceniaCreateWithoutWykonawcaInput, zleceniaUncheckedCreateWithoutWykonawcaInput>
  }

  export type zleceniaCreateManyWykonawcaInputEnvelope = {
    data: zleceniaCreateManyWykonawcaInput | zleceniaCreateManyWykonawcaInput[]
    skipDuplicates?: boolean
  }

  export type projektyCreateWithoutAutorInput = {
    nazwa?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    status: statusyprojektowCreateNestedOneWithoutProjektyInput
  }

  export type projektyUncheckedCreateWithoutAutorInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    status_id: number
  }

  export type projektyCreateOrConnectWithoutAutorInput = {
    where: projektyWhereUniqueInput
    create: XOR<projektyCreateWithoutAutorInput, projektyUncheckedCreateWithoutAutorInput>
  }

  export type projektyCreateManyAutorInputEnvelope = {
    data: projektyCreateManyAutorInput | projektyCreateManyAutorInput[]
    skipDuplicates?: boolean
  }

  export type producentkatalogCreateWithoutProducentInput = {
    opis?: string | null
    strona_www?: string | null
    kategoria: kategorieproducentowCreateNestedOneWithoutProducentkatalogInput
  }

  export type producentkatalogUncheckedCreateWithoutProducentInput = {
    id?: number
    opis?: string | null
    strona_www?: string | null
    kategoria_id: number
  }

  export type producentkatalogCreateOrConnectWithoutProducentInput = {
    where: producentkatalogWhereUniqueInput
    create: XOR<producentkatalogCreateWithoutProducentInput, producentkatalogUncheckedCreateWithoutProducentInput>
  }

  export type producentkatalogCreateManyProducentInputEnvelope = {
    data: producentkatalogCreateManyProducentInput | producentkatalogCreateManyProducentInput[]
    skipDuplicates?: boolean
  }

  export type podwykonawcyCreateWithoutUzytkownikInput = {
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type podwykonawcyUncheckedCreateWithoutUzytkownikInput = {
    id?: number
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type podwykonawcyCreateOrConnectWithoutUzytkownikInput = {
    where: podwykonawcyWhereUniqueInput
    create: XOR<podwykonawcyCreateWithoutUzytkownikInput, podwykonawcyUncheckedCreateWithoutUzytkownikInput>
  }

  export type freelancerzyCreateWithoutUzytkownikInput = {
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type freelancerzyUncheckedCreateWithoutUzytkownikInput = {
    id?: number
    specjalizacja?: string | null
    opis?: string | null
    kontakt?: string | null
  }

  export type freelancerzyCreateOrConnectWithoutUzytkownikInput = {
    where: freelancerzyWhereUniqueInput
    create: XOR<freelancerzyCreateWithoutUzytkownikInput, freelancerzyUncheckedCreateWithoutUzytkownikInput>
  }

  export type roleUpsertWithoutUzytkownicyInput = {
    update: XOR<roleUpdateWithoutUzytkownicyInput, roleUncheckedUpdateWithoutUzytkownicyInput>
    create: XOR<roleCreateWithoutUzytkownicyInput, roleUncheckedCreateWithoutUzytkownicyInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUzytkownicyInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUzytkownicyInput, roleUncheckedUpdateWithoutUzytkownicyInput>
  }

  export type roleUpdateWithoutUzytkownicyInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateWithoutUzytkownicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type artykulyUpsertWithWhereUniqueWithoutAutorInput = {
    where: artykulyWhereUniqueInput
    update: XOR<artykulyUpdateWithoutAutorInput, artykulyUncheckedUpdateWithoutAutorInput>
    create: XOR<artykulyCreateWithoutAutorInput, artykulyUncheckedCreateWithoutAutorInput>
  }

  export type artykulyUpdateWithWhereUniqueWithoutAutorInput = {
    where: artykulyWhereUniqueInput
    data: XOR<artykulyUpdateWithoutAutorInput, artykulyUncheckedUpdateWithoutAutorInput>
  }

  export type artykulyUpdateManyWithWhereWithoutAutorInput = {
    where: artykulyScalarWhereInput
    data: XOR<artykulyUpdateManyMutationInput, artykulyUncheckedUpdateManyWithoutAutorInput>
  }

  export type artykulyScalarWhereInput = {
    AND?: artykulyScalarWhereInput | artykulyScalarWhereInput[]
    OR?: artykulyScalarWhereInput[]
    NOT?: artykulyScalarWhereInput | artykulyScalarWhereInput[]
    id?: IntFilter<"artykuly"> | number
    tytul?: StringNullableFilter<"artykuly"> | string | null
    tresc?: StringNullableFilter<"artykuly"> | string | null
    data_publikacji?: DateTimeNullableFilter<"artykuly"> | Date | string | null
    autor_id?: IntFilter<"artykuly"> | number
    kategoria_id?: IntFilter<"artykuly"> | number
  }

  export type produktyUpsertWithWhereUniqueWithoutProducentInput = {
    where: produktyWhereUniqueInput
    update: XOR<produktyUpdateWithoutProducentInput, produktyUncheckedUpdateWithoutProducentInput>
    create: XOR<produktyCreateWithoutProducentInput, produktyUncheckedCreateWithoutProducentInput>
  }

  export type produktyUpdateWithWhereUniqueWithoutProducentInput = {
    where: produktyWhereUniqueInput
    data: XOR<produktyUpdateWithoutProducentInput, produktyUncheckedUpdateWithoutProducentInput>
  }

  export type produktyUpdateManyWithWhereWithoutProducentInput = {
    where: produktyScalarWhereInput
    data: XOR<produktyUpdateManyMutationInput, produktyUncheckedUpdateManyWithoutProducentInput>
  }

  export type produktyScalarWhereInput = {
    AND?: produktyScalarWhereInput | produktyScalarWhereInput[]
    OR?: produktyScalarWhereInput[]
    NOT?: produktyScalarWhereInput | produktyScalarWhereInput[]
    id?: IntFilter<"produkty"> | number
    nazwa?: StringNullableFilter<"produkty"> | string | null
    opis?: StringNullableFilter<"produkty"> | string | null
    producent_id?: IntFilter<"produkty"> | number
    cena?: DecimalNullableFilter<"produkty"> | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFilter<"produkty"> | number
    data_dodania?: DateTimeNullableFilter<"produkty"> | Date | string | null
  }

  export type zamowieniaUpsertWithWhereUniqueWithoutUzytkownikInput = {
    where: zamowieniaWhereUniqueInput
    update: XOR<zamowieniaUpdateWithoutUzytkownikInput, zamowieniaUncheckedUpdateWithoutUzytkownikInput>
    create: XOR<zamowieniaCreateWithoutUzytkownikInput, zamowieniaUncheckedCreateWithoutUzytkownikInput>
  }

  export type zamowieniaUpdateWithWhereUniqueWithoutUzytkownikInput = {
    where: zamowieniaWhereUniqueInput
    data: XOR<zamowieniaUpdateWithoutUzytkownikInput, zamowieniaUncheckedUpdateWithoutUzytkownikInput>
  }

  export type zamowieniaUpdateManyWithWhereWithoutUzytkownikInput = {
    where: zamowieniaScalarWhereInput
    data: XOR<zamowieniaUpdateManyMutationInput, zamowieniaUncheckedUpdateManyWithoutUzytkownikInput>
  }

  export type zamowieniaScalarWhereInput = {
    AND?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
    OR?: zamowieniaScalarWhereInput[]
    NOT?: zamowieniaScalarWhereInput | zamowieniaScalarWhereInput[]
    id?: IntFilter<"zamowienia"> | number
    uzytkownik_id?: IntFilter<"zamowienia"> | number
    produkt_id?: IntFilter<"zamowienia"> | number
    ilosc?: IntNullableFilter<"zamowienia"> | number | null
    data_zamowienia?: DateTimeNullableFilter<"zamowienia"> | Date | string | null
    status_id?: IntFilter<"zamowienia"> | number
  }

  export type zleceniaUpsertWithWhereUniqueWithoutZleceniodawcaInput = {
    where: zleceniaWhereUniqueInput
    update: XOR<zleceniaUpdateWithoutZleceniodawcaInput, zleceniaUncheckedUpdateWithoutZleceniodawcaInput>
    create: XOR<zleceniaCreateWithoutZleceniodawcaInput, zleceniaUncheckedCreateWithoutZleceniodawcaInput>
  }

  export type zleceniaUpdateWithWhereUniqueWithoutZleceniodawcaInput = {
    where: zleceniaWhereUniqueInput
    data: XOR<zleceniaUpdateWithoutZleceniodawcaInput, zleceniaUncheckedUpdateWithoutZleceniodawcaInput>
  }

  export type zleceniaUpdateManyWithWhereWithoutZleceniodawcaInput = {
    where: zleceniaScalarWhereInput
    data: XOR<zleceniaUpdateManyMutationInput, zleceniaUncheckedUpdateManyWithoutZleceniodawcaInput>
  }

  export type zleceniaScalarWhereInput = {
    AND?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
    OR?: zleceniaScalarWhereInput[]
    NOT?: zleceniaScalarWhereInput | zleceniaScalarWhereInput[]
    id?: IntFilter<"zlecenia"> | number
    tytul?: StringNullableFilter<"zlecenia"> | string | null
    opis?: StringNullableFilter<"zlecenia"> | string | null
    zleceniodawca_id?: IntFilter<"zlecenia"> | number
    wykonawca_id?: IntFilter<"zlecenia"> | number
    data_utworzenia?: DateTimeNullableFilter<"zlecenia"> | Date | string | null
    status_id?: IntFilter<"zlecenia"> | number
    typ_id?: IntFilter<"zlecenia"> | number
  }

  export type zleceniaUpsertWithWhereUniqueWithoutWykonawcaInput = {
    where: zleceniaWhereUniqueInput
    update: XOR<zleceniaUpdateWithoutWykonawcaInput, zleceniaUncheckedUpdateWithoutWykonawcaInput>
    create: XOR<zleceniaCreateWithoutWykonawcaInput, zleceniaUncheckedCreateWithoutWykonawcaInput>
  }

  export type zleceniaUpdateWithWhereUniqueWithoutWykonawcaInput = {
    where: zleceniaWhereUniqueInput
    data: XOR<zleceniaUpdateWithoutWykonawcaInput, zleceniaUncheckedUpdateWithoutWykonawcaInput>
  }

  export type zleceniaUpdateManyWithWhereWithoutWykonawcaInput = {
    where: zleceniaScalarWhereInput
    data: XOR<zleceniaUpdateManyMutationInput, zleceniaUncheckedUpdateManyWithoutWykonawcaInput>
  }

  export type projektyUpsertWithWhereUniqueWithoutAutorInput = {
    where: projektyWhereUniqueInput
    update: XOR<projektyUpdateWithoutAutorInput, projektyUncheckedUpdateWithoutAutorInput>
    create: XOR<projektyCreateWithoutAutorInput, projektyUncheckedCreateWithoutAutorInput>
  }

  export type projektyUpdateWithWhereUniqueWithoutAutorInput = {
    where: projektyWhereUniqueInput
    data: XOR<projektyUpdateWithoutAutorInput, projektyUncheckedUpdateWithoutAutorInput>
  }

  export type projektyUpdateManyWithWhereWithoutAutorInput = {
    where: projektyScalarWhereInput
    data: XOR<projektyUpdateManyMutationInput, projektyUncheckedUpdateManyWithoutAutorInput>
  }

  export type projektyScalarWhereInput = {
    AND?: projektyScalarWhereInput | projektyScalarWhereInput[]
    OR?: projektyScalarWhereInput[]
    NOT?: projektyScalarWhereInput | projektyScalarWhereInput[]
    id?: IntFilter<"projekty"> | number
    nazwa?: StringNullableFilter<"projekty"> | string | null
    opis?: StringNullableFilter<"projekty"> | string | null
    autor_id?: IntFilter<"projekty"> | number
    data_utworzenia?: DateTimeNullableFilter<"projekty"> | Date | string | null
    status_id?: IntFilter<"projekty"> | number
  }

  export type producentkatalogUpsertWithWhereUniqueWithoutProducentInput = {
    where: producentkatalogWhereUniqueInput
    update: XOR<producentkatalogUpdateWithoutProducentInput, producentkatalogUncheckedUpdateWithoutProducentInput>
    create: XOR<producentkatalogCreateWithoutProducentInput, producentkatalogUncheckedCreateWithoutProducentInput>
  }

  export type producentkatalogUpdateWithWhereUniqueWithoutProducentInput = {
    where: producentkatalogWhereUniqueInput
    data: XOR<producentkatalogUpdateWithoutProducentInput, producentkatalogUncheckedUpdateWithoutProducentInput>
  }

  export type producentkatalogUpdateManyWithWhereWithoutProducentInput = {
    where: producentkatalogScalarWhereInput
    data: XOR<producentkatalogUpdateManyMutationInput, producentkatalogUncheckedUpdateManyWithoutProducentInput>
  }

  export type producentkatalogScalarWhereInput = {
    AND?: producentkatalogScalarWhereInput | producentkatalogScalarWhereInput[]
    OR?: producentkatalogScalarWhereInput[]
    NOT?: producentkatalogScalarWhereInput | producentkatalogScalarWhereInput[]
    id?: IntFilter<"producentkatalog"> | number
    producent_id?: IntFilter<"producentkatalog"> | number
    opis?: StringNullableFilter<"producentkatalog"> | string | null
    strona_www?: StringNullableFilter<"producentkatalog"> | string | null
    kategoria_id?: IntFilter<"producentkatalog"> | number
  }

  export type podwykonawcyUpsertWithoutUzytkownikInput = {
    update: XOR<podwykonawcyUpdateWithoutUzytkownikInput, podwykonawcyUncheckedUpdateWithoutUzytkownikInput>
    create: XOR<podwykonawcyCreateWithoutUzytkownikInput, podwykonawcyUncheckedCreateWithoutUzytkownikInput>
    where?: podwykonawcyWhereInput
  }

  export type podwykonawcyUpdateToOneWithWhereWithoutUzytkownikInput = {
    where?: podwykonawcyWhereInput
    data: XOR<podwykonawcyUpdateWithoutUzytkownikInput, podwykonawcyUncheckedUpdateWithoutUzytkownikInput>
  }

  export type podwykonawcyUpdateWithoutUzytkownikInput = {
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type podwykonawcyUncheckedUpdateWithoutUzytkownikInput = {
    id?: IntFieldUpdateOperationsInput | number
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type freelancerzyUpsertWithoutUzytkownikInput = {
    update: XOR<freelancerzyUpdateWithoutUzytkownikInput, freelancerzyUncheckedUpdateWithoutUzytkownikInput>
    create: XOR<freelancerzyCreateWithoutUzytkownikInput, freelancerzyUncheckedCreateWithoutUzytkownikInput>
    where?: freelancerzyWhereInput
  }

  export type freelancerzyUpdateToOneWithWhereWithoutUzytkownikInput = {
    where?: freelancerzyWhereInput
    data: XOR<freelancerzyUpdateWithoutUzytkownikInput, freelancerzyUncheckedUpdateWithoutUzytkownikInput>
  }

  export type freelancerzyUpdateWithoutUzytkownikInput = {
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type freelancerzyUncheckedUpdateWithoutUzytkownikInput = {
    id?: IntFieldUpdateOperationsInput | number
    specjalizacja?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    kontakt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type uzytkownicyCreateWithoutRolaInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutRolaInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutRolaInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutRolaInput, uzytkownicyUncheckedCreateWithoutRolaInput>
  }

  export type uzytkownicyCreateManyRolaInputEnvelope = {
    data: uzytkownicyCreateManyRolaInput | uzytkownicyCreateManyRolaInput[]
    skipDuplicates?: boolean
  }

  export type uzytkownicyUpsertWithWhereUniqueWithoutRolaInput = {
    where: uzytkownicyWhereUniqueInput
    update: XOR<uzytkownicyUpdateWithoutRolaInput, uzytkownicyUncheckedUpdateWithoutRolaInput>
    create: XOR<uzytkownicyCreateWithoutRolaInput, uzytkownicyUncheckedCreateWithoutRolaInput>
  }

  export type uzytkownicyUpdateWithWhereUniqueWithoutRolaInput = {
    where: uzytkownicyWhereUniqueInput
    data: XOR<uzytkownicyUpdateWithoutRolaInput, uzytkownicyUncheckedUpdateWithoutRolaInput>
  }

  export type uzytkownicyUpdateManyWithWhereWithoutRolaInput = {
    where: uzytkownicyScalarWhereInput
    data: XOR<uzytkownicyUpdateManyMutationInput, uzytkownicyUncheckedUpdateManyWithoutRolaInput>
  }

  export type uzytkownicyScalarWhereInput = {
    AND?: uzytkownicyScalarWhereInput | uzytkownicyScalarWhereInput[]
    OR?: uzytkownicyScalarWhereInput[]
    NOT?: uzytkownicyScalarWhereInput | uzytkownicyScalarWhereInput[]
    id?: IntFilter<"uzytkownicy"> | number
    imie?: StringNullableFilter<"uzytkownicy"> | string | null
    nazwisko?: StringNullableFilter<"uzytkownicy"> | string | null
    email?: StringFilter<"uzytkownicy"> | string
    haslo?: StringFilter<"uzytkownicy"> | string
    rola_id?: IntFilter<"uzytkownicy"> | number
    data_rejestracji?: DateTimeNullableFilter<"uzytkownicy"> | Date | string | null
  }

  export type uzytkownicyCreateWithoutArtykulyInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutArtykulyInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutArtykulyInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutArtykulyInput, uzytkownicyUncheckedCreateWithoutArtykulyInput>
  }

  export type kategorieartykulowCreateWithoutArtykulyInput = {
    nazwa: string
  }

  export type kategorieartykulowUncheckedCreateWithoutArtykulyInput = {
    id?: number
    nazwa: string
  }

  export type kategorieartykulowCreateOrConnectWithoutArtykulyInput = {
    where: kategorieartykulowWhereUniqueInput
    create: XOR<kategorieartykulowCreateWithoutArtykulyInput, kategorieartykulowUncheckedCreateWithoutArtykulyInput>
  }

  export type uzytkownicyUpsertWithoutArtykulyInput = {
    update: XOR<uzytkownicyUpdateWithoutArtykulyInput, uzytkownicyUncheckedUpdateWithoutArtykulyInput>
    create: XOR<uzytkownicyCreateWithoutArtykulyInput, uzytkownicyUncheckedCreateWithoutArtykulyInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutArtykulyInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutArtykulyInput, uzytkownicyUncheckedUpdateWithoutArtykulyInput>
  }

  export type uzytkownicyUpdateWithoutArtykulyInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutArtykulyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type kategorieartykulowUpsertWithoutArtykulyInput = {
    update: XOR<kategorieartykulowUpdateWithoutArtykulyInput, kategorieartykulowUncheckedUpdateWithoutArtykulyInput>
    create: XOR<kategorieartykulowCreateWithoutArtykulyInput, kategorieartykulowUncheckedCreateWithoutArtykulyInput>
    where?: kategorieartykulowWhereInput
  }

  export type kategorieartykulowUpdateToOneWithWhereWithoutArtykulyInput = {
    where?: kategorieartykulowWhereInput
    data: XOR<kategorieartykulowUpdateWithoutArtykulyInput, kategorieartykulowUncheckedUpdateWithoutArtykulyInput>
  }

  export type kategorieartykulowUpdateWithoutArtykulyInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type kategorieartykulowUncheckedUpdateWithoutArtykulyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type artykulyCreateWithoutKategoriaInput = {
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    autor: uzytkownicyCreateNestedOneWithoutArtykulyInput
  }

  export type artykulyUncheckedCreateWithoutKategoriaInput = {
    id?: number
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    autor_id: number
  }

  export type artykulyCreateOrConnectWithoutKategoriaInput = {
    where: artykulyWhereUniqueInput
    create: XOR<artykulyCreateWithoutKategoriaInput, artykulyUncheckedCreateWithoutKategoriaInput>
  }

  export type artykulyCreateManyKategoriaInputEnvelope = {
    data: artykulyCreateManyKategoriaInput | artykulyCreateManyKategoriaInput[]
    skipDuplicates?: boolean
  }

  export type artykulyUpsertWithWhereUniqueWithoutKategoriaInput = {
    where: artykulyWhereUniqueInput
    update: XOR<artykulyUpdateWithoutKategoriaInput, artykulyUncheckedUpdateWithoutKategoriaInput>
    create: XOR<artykulyCreateWithoutKategoriaInput, artykulyUncheckedCreateWithoutKategoriaInput>
  }

  export type artykulyUpdateWithWhereUniqueWithoutKategoriaInput = {
    where: artykulyWhereUniqueInput
    data: XOR<artykulyUpdateWithoutKategoriaInput, artykulyUncheckedUpdateWithoutKategoriaInput>
  }

  export type artykulyUpdateManyWithWhereWithoutKategoriaInput = {
    where: artykulyScalarWhereInput
    data: XOR<artykulyUpdateManyMutationInput, artykulyUncheckedUpdateManyWithoutKategoriaInput>
  }

  export type uzytkownicyCreateWithoutProduktyInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutProduktyInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutProduktyInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutProduktyInput, uzytkownicyUncheckedCreateWithoutProduktyInput>
  }

  export type kategorieproduktowCreateWithoutProduktyInput = {
    nazwa: string
  }

  export type kategorieproduktowUncheckedCreateWithoutProduktyInput = {
    id?: number
    nazwa: string
  }

  export type kategorieproduktowCreateOrConnectWithoutProduktyInput = {
    where: kategorieproduktowWhereUniqueInput
    create: XOR<kategorieproduktowCreateWithoutProduktyInput, kategorieproduktowUncheckedCreateWithoutProduktyInput>
  }

  export type zamowieniaCreateWithoutProduktInput = {
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    uzytkownik: uzytkownicyCreateNestedOneWithoutZamowieniaInput
    status: statusyzamowienCreateNestedOneWithoutZamowieniaInput
  }

  export type zamowieniaUncheckedCreateWithoutProduktInput = {
    id?: number
    uzytkownik_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    status_id: number
  }

  export type zamowieniaCreateOrConnectWithoutProduktInput = {
    where: zamowieniaWhereUniqueInput
    create: XOR<zamowieniaCreateWithoutProduktInput, zamowieniaUncheckedCreateWithoutProduktInput>
  }

  export type zamowieniaCreateManyProduktInputEnvelope = {
    data: zamowieniaCreateManyProduktInput | zamowieniaCreateManyProduktInput[]
    skipDuplicates?: boolean
  }

  export type uzytkownicyUpsertWithoutProduktyInput = {
    update: XOR<uzytkownicyUpdateWithoutProduktyInput, uzytkownicyUncheckedUpdateWithoutProduktyInput>
    create: XOR<uzytkownicyCreateWithoutProduktyInput, uzytkownicyUncheckedCreateWithoutProduktyInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutProduktyInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutProduktyInput, uzytkownicyUncheckedUpdateWithoutProduktyInput>
  }

  export type uzytkownicyUpdateWithoutProduktyInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutProduktyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type kategorieproduktowUpsertWithoutProduktyInput = {
    update: XOR<kategorieproduktowUpdateWithoutProduktyInput, kategorieproduktowUncheckedUpdateWithoutProduktyInput>
    create: XOR<kategorieproduktowCreateWithoutProduktyInput, kategorieproduktowUncheckedCreateWithoutProduktyInput>
    where?: kategorieproduktowWhereInput
  }

  export type kategorieproduktowUpdateToOneWithWhereWithoutProduktyInput = {
    where?: kategorieproduktowWhereInput
    data: XOR<kategorieproduktowUpdateWithoutProduktyInput, kategorieproduktowUncheckedUpdateWithoutProduktyInput>
  }

  export type kategorieproduktowUpdateWithoutProduktyInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type kategorieproduktowUncheckedUpdateWithoutProduktyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type zamowieniaUpsertWithWhereUniqueWithoutProduktInput = {
    where: zamowieniaWhereUniqueInput
    update: XOR<zamowieniaUpdateWithoutProduktInput, zamowieniaUncheckedUpdateWithoutProduktInput>
    create: XOR<zamowieniaCreateWithoutProduktInput, zamowieniaUncheckedCreateWithoutProduktInput>
  }

  export type zamowieniaUpdateWithWhereUniqueWithoutProduktInput = {
    where: zamowieniaWhereUniqueInput
    data: XOR<zamowieniaUpdateWithoutProduktInput, zamowieniaUncheckedUpdateWithoutProduktInput>
  }

  export type zamowieniaUpdateManyWithWhereWithoutProduktInput = {
    where: zamowieniaScalarWhereInput
    data: XOR<zamowieniaUpdateManyMutationInput, zamowieniaUncheckedUpdateManyWithoutProduktInput>
  }

  export type produktyCreateWithoutKategoriaInput = {
    nazwa?: string | null
    opis?: string | null
    cena?: Decimal | DecimalJsLike | number | string | null
    data_dodania?: Date | string | null
    producent: uzytkownicyCreateNestedOneWithoutProduktyInput
    zamowienia?: zamowieniaCreateNestedManyWithoutProduktInput
  }

  export type produktyUncheckedCreateWithoutKategoriaInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    producent_id: number
    cena?: Decimal | DecimalJsLike | number | string | null
    data_dodania?: Date | string | null
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutProduktInput
  }

  export type produktyCreateOrConnectWithoutKategoriaInput = {
    where: produktyWhereUniqueInput
    create: XOR<produktyCreateWithoutKategoriaInput, produktyUncheckedCreateWithoutKategoriaInput>
  }

  export type produktyCreateManyKategoriaInputEnvelope = {
    data: produktyCreateManyKategoriaInput | produktyCreateManyKategoriaInput[]
    skipDuplicates?: boolean
  }

  export type produktyUpsertWithWhereUniqueWithoutKategoriaInput = {
    where: produktyWhereUniqueInput
    update: XOR<produktyUpdateWithoutKategoriaInput, produktyUncheckedUpdateWithoutKategoriaInput>
    create: XOR<produktyCreateWithoutKategoriaInput, produktyUncheckedCreateWithoutKategoriaInput>
  }

  export type produktyUpdateWithWhereUniqueWithoutKategoriaInput = {
    where: produktyWhereUniqueInput
    data: XOR<produktyUpdateWithoutKategoriaInput, produktyUncheckedUpdateWithoutKategoriaInput>
  }

  export type produktyUpdateManyWithWhereWithoutKategoriaInput = {
    where: produktyScalarWhereInput
    data: XOR<produktyUpdateManyMutationInput, produktyUncheckedUpdateManyWithoutKategoriaInput>
  }

  export type uzytkownicyCreateWithoutZamowieniaInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutZamowieniaInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutZamowieniaInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutZamowieniaInput, uzytkownicyUncheckedCreateWithoutZamowieniaInput>
  }

  export type produktyCreateWithoutZamowieniaInput = {
    nazwa?: string | null
    opis?: string | null
    cena?: Decimal | DecimalJsLike | number | string | null
    data_dodania?: Date | string | null
    producent: uzytkownicyCreateNestedOneWithoutProduktyInput
    kategoria: kategorieproduktowCreateNestedOneWithoutProduktyInput
  }

  export type produktyUncheckedCreateWithoutZamowieniaInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    producent_id: number
    cena?: Decimal | DecimalJsLike | number | string | null
    kategoria_id: number
    data_dodania?: Date | string | null
  }

  export type produktyCreateOrConnectWithoutZamowieniaInput = {
    where: produktyWhereUniqueInput
    create: XOR<produktyCreateWithoutZamowieniaInput, produktyUncheckedCreateWithoutZamowieniaInput>
  }

  export type statusyzamowienCreateWithoutZamowieniaInput = {
    nazwa: string
  }

  export type statusyzamowienUncheckedCreateWithoutZamowieniaInput = {
    id?: number
    nazwa: string
  }

  export type statusyzamowienCreateOrConnectWithoutZamowieniaInput = {
    where: statusyzamowienWhereUniqueInput
    create: XOR<statusyzamowienCreateWithoutZamowieniaInput, statusyzamowienUncheckedCreateWithoutZamowieniaInput>
  }

  export type uzytkownicyUpsertWithoutZamowieniaInput = {
    update: XOR<uzytkownicyUpdateWithoutZamowieniaInput, uzytkownicyUncheckedUpdateWithoutZamowieniaInput>
    create: XOR<uzytkownicyCreateWithoutZamowieniaInput, uzytkownicyUncheckedCreateWithoutZamowieniaInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutZamowieniaInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutZamowieniaInput, uzytkownicyUncheckedUpdateWithoutZamowieniaInput>
  }

  export type uzytkownicyUpdateWithoutZamowieniaInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutZamowieniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type produktyUpsertWithoutZamowieniaInput = {
    update: XOR<produktyUpdateWithoutZamowieniaInput, produktyUncheckedUpdateWithoutZamowieniaInput>
    create: XOR<produktyCreateWithoutZamowieniaInput, produktyUncheckedCreateWithoutZamowieniaInput>
    where?: produktyWhereInput
  }

  export type produktyUpdateToOneWithWhereWithoutZamowieniaInput = {
    where?: produktyWhereInput
    data: XOR<produktyUpdateWithoutZamowieniaInput, produktyUncheckedUpdateWithoutZamowieniaInput>
  }

  export type produktyUpdateWithoutZamowieniaInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producent?: uzytkownicyUpdateOneRequiredWithoutProduktyNestedInput
    kategoria?: kategorieproduktowUpdateOneRequiredWithoutProduktyNestedInput
  }

  export type produktyUncheckedUpdateWithoutZamowieniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    producent_id?: IntFieldUpdateOperationsInput | number
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type statusyzamowienUpsertWithoutZamowieniaInput = {
    update: XOR<statusyzamowienUpdateWithoutZamowieniaInput, statusyzamowienUncheckedUpdateWithoutZamowieniaInput>
    create: XOR<statusyzamowienCreateWithoutZamowieniaInput, statusyzamowienUncheckedCreateWithoutZamowieniaInput>
    where?: statusyzamowienWhereInput
  }

  export type statusyzamowienUpdateToOneWithWhereWithoutZamowieniaInput = {
    where?: statusyzamowienWhereInput
    data: XOR<statusyzamowienUpdateWithoutZamowieniaInput, statusyzamowienUncheckedUpdateWithoutZamowieniaInput>
  }

  export type statusyzamowienUpdateWithoutZamowieniaInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type statusyzamowienUncheckedUpdateWithoutZamowieniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type zamowieniaCreateWithoutStatusInput = {
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    uzytkownik: uzytkownicyCreateNestedOneWithoutZamowieniaInput
    produkt: produktyCreateNestedOneWithoutZamowieniaInput
  }

  export type zamowieniaUncheckedCreateWithoutStatusInput = {
    id?: number
    uzytkownik_id: number
    produkt_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
  }

  export type zamowieniaCreateOrConnectWithoutStatusInput = {
    where: zamowieniaWhereUniqueInput
    create: XOR<zamowieniaCreateWithoutStatusInput, zamowieniaUncheckedCreateWithoutStatusInput>
  }

  export type zamowieniaCreateManyStatusInputEnvelope = {
    data: zamowieniaCreateManyStatusInput | zamowieniaCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type zamowieniaUpsertWithWhereUniqueWithoutStatusInput = {
    where: zamowieniaWhereUniqueInput
    update: XOR<zamowieniaUpdateWithoutStatusInput, zamowieniaUncheckedUpdateWithoutStatusInput>
    create: XOR<zamowieniaCreateWithoutStatusInput, zamowieniaUncheckedCreateWithoutStatusInput>
  }

  export type zamowieniaUpdateWithWhereUniqueWithoutStatusInput = {
    where: zamowieniaWhereUniqueInput
    data: XOR<zamowieniaUpdateWithoutStatusInput, zamowieniaUncheckedUpdateWithoutStatusInput>
  }

  export type zamowieniaUpdateManyWithWhereWithoutStatusInput = {
    where: zamowieniaScalarWhereInput
    data: XOR<zamowieniaUpdateManyMutationInput, zamowieniaUncheckedUpdateManyWithoutStatusInput>
  }

  export type uzytkownicyCreateWithoutZlecenia_zleceniodawcaInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutZlecenia_zleceniodawcaInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutZlecenia_zleceniodawcaInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutZlecenia_zleceniodawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_zleceniodawcaInput>
  }

  export type uzytkownicyCreateWithoutZlecenia_wykonawcaInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutZlecenia_wykonawcaInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutZlecenia_wykonawcaInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutZlecenia_wykonawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_wykonawcaInput>
  }

  export type statusyzlecenCreateWithoutZleceniaInput = {
    nazwa: string
  }

  export type statusyzlecenUncheckedCreateWithoutZleceniaInput = {
    id?: number
    nazwa: string
  }

  export type statusyzlecenCreateOrConnectWithoutZleceniaInput = {
    where: statusyzlecenWhereUniqueInput
    create: XOR<statusyzlecenCreateWithoutZleceniaInput, statusyzlecenUncheckedCreateWithoutZleceniaInput>
  }

  export type typyzlecenCreateWithoutZleceniaInput = {
    nazwa: string
  }

  export type typyzlecenUncheckedCreateWithoutZleceniaInput = {
    id?: number
    nazwa: string
  }

  export type typyzlecenCreateOrConnectWithoutZleceniaInput = {
    where: typyzlecenWhereUniqueInput
    create: XOR<typyzlecenCreateWithoutZleceniaInput, typyzlecenUncheckedCreateWithoutZleceniaInput>
  }

  export type uzytkownicyUpsertWithoutZlecenia_zleceniodawcaInput = {
    update: XOR<uzytkownicyUpdateWithoutZlecenia_zleceniodawcaInput, uzytkownicyUncheckedUpdateWithoutZlecenia_zleceniodawcaInput>
    create: XOR<uzytkownicyCreateWithoutZlecenia_zleceniodawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_zleceniodawcaInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutZlecenia_zleceniodawcaInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutZlecenia_zleceniodawcaInput, uzytkownicyUncheckedUpdateWithoutZlecenia_zleceniodawcaInput>
  }

  export type uzytkownicyUpdateWithoutZlecenia_zleceniodawcaInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutZlecenia_zleceniodawcaInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUpsertWithoutZlecenia_wykonawcaInput = {
    update: XOR<uzytkownicyUpdateWithoutZlecenia_wykonawcaInput, uzytkownicyUncheckedUpdateWithoutZlecenia_wykonawcaInput>
    create: XOR<uzytkownicyCreateWithoutZlecenia_wykonawcaInput, uzytkownicyUncheckedCreateWithoutZlecenia_wykonawcaInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutZlecenia_wykonawcaInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutZlecenia_wykonawcaInput, uzytkownicyUncheckedUpdateWithoutZlecenia_wykonawcaInput>
  }

  export type uzytkownicyUpdateWithoutZlecenia_wykonawcaInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutZlecenia_wykonawcaInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type statusyzlecenUpsertWithoutZleceniaInput = {
    update: XOR<statusyzlecenUpdateWithoutZleceniaInput, statusyzlecenUncheckedUpdateWithoutZleceniaInput>
    create: XOR<statusyzlecenCreateWithoutZleceniaInput, statusyzlecenUncheckedCreateWithoutZleceniaInput>
    where?: statusyzlecenWhereInput
  }

  export type statusyzlecenUpdateToOneWithWhereWithoutZleceniaInput = {
    where?: statusyzlecenWhereInput
    data: XOR<statusyzlecenUpdateWithoutZleceniaInput, statusyzlecenUncheckedUpdateWithoutZleceniaInput>
  }

  export type statusyzlecenUpdateWithoutZleceniaInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type statusyzlecenUncheckedUpdateWithoutZleceniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type typyzlecenUpsertWithoutZleceniaInput = {
    update: XOR<typyzlecenUpdateWithoutZleceniaInput, typyzlecenUncheckedUpdateWithoutZleceniaInput>
    create: XOR<typyzlecenCreateWithoutZleceniaInput, typyzlecenUncheckedCreateWithoutZleceniaInput>
    where?: typyzlecenWhereInput
  }

  export type typyzlecenUpdateToOneWithWhereWithoutZleceniaInput = {
    where?: typyzlecenWhereInput
    data: XOR<typyzlecenUpdateWithoutZleceniaInput, typyzlecenUncheckedUpdateWithoutZleceniaInput>
  }

  export type typyzlecenUpdateWithoutZleceniaInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type typyzlecenUncheckedUpdateWithoutZleceniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type zleceniaCreateWithoutStatusInput = {
    tytul?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    zleceniodawca: uzytkownicyCreateNestedOneWithoutZlecenia_zleceniodawcaInput
    wykonawca: uzytkownicyCreateNestedOneWithoutZlecenia_wykonawcaInput
    typ: typyzlecenCreateNestedOneWithoutZleceniaInput
  }

  export type zleceniaUncheckedCreateWithoutStatusInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    typ_id: number
  }

  export type zleceniaCreateOrConnectWithoutStatusInput = {
    where: zleceniaWhereUniqueInput
    create: XOR<zleceniaCreateWithoutStatusInput, zleceniaUncheckedCreateWithoutStatusInput>
  }

  export type zleceniaCreateManyStatusInputEnvelope = {
    data: zleceniaCreateManyStatusInput | zleceniaCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type zleceniaUpsertWithWhereUniqueWithoutStatusInput = {
    where: zleceniaWhereUniqueInput
    update: XOR<zleceniaUpdateWithoutStatusInput, zleceniaUncheckedUpdateWithoutStatusInput>
    create: XOR<zleceniaCreateWithoutStatusInput, zleceniaUncheckedCreateWithoutStatusInput>
  }

  export type zleceniaUpdateWithWhereUniqueWithoutStatusInput = {
    where: zleceniaWhereUniqueInput
    data: XOR<zleceniaUpdateWithoutStatusInput, zleceniaUncheckedUpdateWithoutStatusInput>
  }

  export type zleceniaUpdateManyWithWhereWithoutStatusInput = {
    where: zleceniaScalarWhereInput
    data: XOR<zleceniaUpdateManyMutationInput, zleceniaUncheckedUpdateManyWithoutStatusInput>
  }

  export type zleceniaCreateWithoutTypInput = {
    tytul?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    zleceniodawca: uzytkownicyCreateNestedOneWithoutZlecenia_zleceniodawcaInput
    wykonawca: uzytkownicyCreateNestedOneWithoutZlecenia_wykonawcaInput
    status: statusyzlecenCreateNestedOneWithoutZleceniaInput
  }

  export type zleceniaUncheckedCreateWithoutTypInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
  }

  export type zleceniaCreateOrConnectWithoutTypInput = {
    where: zleceniaWhereUniqueInput
    create: XOR<zleceniaCreateWithoutTypInput, zleceniaUncheckedCreateWithoutTypInput>
  }

  export type zleceniaCreateManyTypInputEnvelope = {
    data: zleceniaCreateManyTypInput | zleceniaCreateManyTypInput[]
    skipDuplicates?: boolean
  }

  export type zleceniaUpsertWithWhereUniqueWithoutTypInput = {
    where: zleceniaWhereUniqueInput
    update: XOR<zleceniaUpdateWithoutTypInput, zleceniaUncheckedUpdateWithoutTypInput>
    create: XOR<zleceniaCreateWithoutTypInput, zleceniaUncheckedCreateWithoutTypInput>
  }

  export type zleceniaUpdateWithWhereUniqueWithoutTypInput = {
    where: zleceniaWhereUniqueInput
    data: XOR<zleceniaUpdateWithoutTypInput, zleceniaUncheckedUpdateWithoutTypInput>
  }

  export type zleceniaUpdateManyWithWhereWithoutTypInput = {
    where: zleceniaScalarWhereInput
    data: XOR<zleceniaUpdateManyMutationInput, zleceniaUncheckedUpdateManyWithoutTypInput>
  }

  export type uzytkownicyCreateWithoutProjektyInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutProjektyInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutProjektyInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutProjektyInput, uzytkownicyUncheckedCreateWithoutProjektyInput>
  }

  export type statusyprojektowCreateWithoutProjektyInput = {
    nazwa: string
  }

  export type statusyprojektowUncheckedCreateWithoutProjektyInput = {
    id?: number
    nazwa: string
  }

  export type statusyprojektowCreateOrConnectWithoutProjektyInput = {
    where: statusyprojektowWhereUniqueInput
    create: XOR<statusyprojektowCreateWithoutProjektyInput, statusyprojektowUncheckedCreateWithoutProjektyInput>
  }

  export type uzytkownicyUpsertWithoutProjektyInput = {
    update: XOR<uzytkownicyUpdateWithoutProjektyInput, uzytkownicyUncheckedUpdateWithoutProjektyInput>
    create: XOR<uzytkownicyCreateWithoutProjektyInput, uzytkownicyUncheckedCreateWithoutProjektyInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutProjektyInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutProjektyInput, uzytkownicyUncheckedUpdateWithoutProjektyInput>
  }

  export type uzytkownicyUpdateWithoutProjektyInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutProjektyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type statusyprojektowUpsertWithoutProjektyInput = {
    update: XOR<statusyprojektowUpdateWithoutProjektyInput, statusyprojektowUncheckedUpdateWithoutProjektyInput>
    create: XOR<statusyprojektowCreateWithoutProjektyInput, statusyprojektowUncheckedCreateWithoutProjektyInput>
    where?: statusyprojektowWhereInput
  }

  export type statusyprojektowUpdateToOneWithWhereWithoutProjektyInput = {
    where?: statusyprojektowWhereInput
    data: XOR<statusyprojektowUpdateWithoutProjektyInput, statusyprojektowUncheckedUpdateWithoutProjektyInput>
  }

  export type statusyprojektowUpdateWithoutProjektyInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type statusyprojektowUncheckedUpdateWithoutProjektyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type projektyCreateWithoutStatusInput = {
    nazwa?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    autor: uzytkownicyCreateNestedOneWithoutProjektyInput
  }

  export type projektyUncheckedCreateWithoutStatusInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    autor_id: number
    data_utworzenia?: Date | string | null
  }

  export type projektyCreateOrConnectWithoutStatusInput = {
    where: projektyWhereUniqueInput
    create: XOR<projektyCreateWithoutStatusInput, projektyUncheckedCreateWithoutStatusInput>
  }

  export type projektyCreateManyStatusInputEnvelope = {
    data: projektyCreateManyStatusInput | projektyCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type projektyUpsertWithWhereUniqueWithoutStatusInput = {
    where: projektyWhereUniqueInput
    update: XOR<projektyUpdateWithoutStatusInput, projektyUncheckedUpdateWithoutStatusInput>
    create: XOR<projektyCreateWithoutStatusInput, projektyUncheckedCreateWithoutStatusInput>
  }

  export type projektyUpdateWithWhereUniqueWithoutStatusInput = {
    where: projektyWhereUniqueInput
    data: XOR<projektyUpdateWithoutStatusInput, projektyUncheckedUpdateWithoutStatusInput>
  }

  export type projektyUpdateManyWithWhereWithoutStatusInput = {
    where: projektyScalarWhereInput
    data: XOR<projektyUpdateManyMutationInput, projektyUncheckedUpdateManyWithoutStatusInput>
  }

  export type uzytkownicyCreateWithoutProducent_katalogInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutProducent_katalogInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutProducent_katalogInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutProducent_katalogInput, uzytkownicyUncheckedCreateWithoutProducent_katalogInput>
  }

  export type kategorieproducentowCreateWithoutProducentkatalogInput = {
    nazwa: string
  }

  export type kategorieproducentowUncheckedCreateWithoutProducentkatalogInput = {
    id?: number
    nazwa: string
  }

  export type kategorieproducentowCreateOrConnectWithoutProducentkatalogInput = {
    where: kategorieproducentowWhereUniqueInput
    create: XOR<kategorieproducentowCreateWithoutProducentkatalogInput, kategorieproducentowUncheckedCreateWithoutProducentkatalogInput>
  }

  export type uzytkownicyUpsertWithoutProducent_katalogInput = {
    update: XOR<uzytkownicyUpdateWithoutProducent_katalogInput, uzytkownicyUncheckedUpdateWithoutProducent_katalogInput>
    create: XOR<uzytkownicyCreateWithoutProducent_katalogInput, uzytkownicyUncheckedCreateWithoutProducent_katalogInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutProducent_katalogInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutProducent_katalogInput, uzytkownicyUncheckedUpdateWithoutProducent_katalogInput>
  }

  export type uzytkownicyUpdateWithoutProducent_katalogInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutProducent_katalogInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type kategorieproducentowUpsertWithoutProducentkatalogInput = {
    update: XOR<kategorieproducentowUpdateWithoutProducentkatalogInput, kategorieproducentowUncheckedUpdateWithoutProducentkatalogInput>
    create: XOR<kategorieproducentowCreateWithoutProducentkatalogInput, kategorieproducentowUncheckedCreateWithoutProducentkatalogInput>
    where?: kategorieproducentowWhereInput
  }

  export type kategorieproducentowUpdateToOneWithWhereWithoutProducentkatalogInput = {
    where?: kategorieproducentowWhereInput
    data: XOR<kategorieproducentowUpdateWithoutProducentkatalogInput, kategorieproducentowUncheckedUpdateWithoutProducentkatalogInput>
  }

  export type kategorieproducentowUpdateWithoutProducentkatalogInput = {
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type kategorieproducentowUncheckedUpdateWithoutProducentkatalogInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: StringFieldUpdateOperationsInput | string
  }

  export type producentkatalogCreateWithoutKategoriaInput = {
    opis?: string | null
    strona_www?: string | null
    producent: uzytkownicyCreateNestedOneWithoutProducent_katalogInput
  }

  export type producentkatalogUncheckedCreateWithoutKategoriaInput = {
    id?: number
    producent_id: number
    opis?: string | null
    strona_www?: string | null
  }

  export type producentkatalogCreateOrConnectWithoutKategoriaInput = {
    where: producentkatalogWhereUniqueInput
    create: XOR<producentkatalogCreateWithoutKategoriaInput, producentkatalogUncheckedCreateWithoutKategoriaInput>
  }

  export type producentkatalogCreateManyKategoriaInputEnvelope = {
    data: producentkatalogCreateManyKategoriaInput | producentkatalogCreateManyKategoriaInput[]
    skipDuplicates?: boolean
  }

  export type producentkatalogUpsertWithWhereUniqueWithoutKategoriaInput = {
    where: producentkatalogWhereUniqueInput
    update: XOR<producentkatalogUpdateWithoutKategoriaInput, producentkatalogUncheckedUpdateWithoutKategoriaInput>
    create: XOR<producentkatalogCreateWithoutKategoriaInput, producentkatalogUncheckedCreateWithoutKategoriaInput>
  }

  export type producentkatalogUpdateWithWhereUniqueWithoutKategoriaInput = {
    where: producentkatalogWhereUniqueInput
    data: XOR<producentkatalogUpdateWithoutKategoriaInput, producentkatalogUncheckedUpdateWithoutKategoriaInput>
  }

  export type producentkatalogUpdateManyWithWhereWithoutKategoriaInput = {
    where: producentkatalogScalarWhereInput
    data: XOR<producentkatalogUpdateManyMutationInput, producentkatalogUncheckedUpdateManyWithoutKategoriaInput>
  }

  export type uzytkownicyCreateWithoutPodwykonawcyInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    freelancerzy?: freelancerzyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutPodwykonawcyInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    freelancerzy?: freelancerzyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutPodwykonawcyInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutPodwykonawcyInput, uzytkownicyUncheckedCreateWithoutPodwykonawcyInput>
  }

  export type uzytkownicyUpsertWithoutPodwykonawcyInput = {
    update: XOR<uzytkownicyUpdateWithoutPodwykonawcyInput, uzytkownicyUncheckedUpdateWithoutPodwykonawcyInput>
    create: XOR<uzytkownicyCreateWithoutPodwykonawcyInput, uzytkownicyUncheckedCreateWithoutPodwykonawcyInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutPodwykonawcyInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutPodwykonawcyInput, uzytkownicyUncheckedUpdateWithoutPodwykonawcyInput>
  }

  export type uzytkownicyUpdateWithoutPodwykonawcyInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutPodwykonawcyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyCreateWithoutFreelancerzyInput = {
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
    rola: roleCreateNestedOneWithoutUzytkownicyInput
    artykuly?: artykulyCreateNestedManyWithoutAutorInput
    produkty?: produktyCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyUncheckedCreateWithoutFreelancerzyInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    rola_id: number
    data_rejestracji?: Date | string | null
    artykuly?: artykulyUncheckedCreateNestedManyWithoutAutorInput
    produkty?: produktyUncheckedCreateNestedManyWithoutProducentInput
    zamowienia?: zamowieniaUncheckedCreateNestedManyWithoutUzytkownikInput
    zlecenia_zleceniodawca?: zleceniaUncheckedCreateNestedManyWithoutZleceniodawcaInput
    zlecenia_wykonawca?: zleceniaUncheckedCreateNestedManyWithoutWykonawcaInput
    projekty?: projektyUncheckedCreateNestedManyWithoutAutorInput
    producent_katalog?: producentkatalogUncheckedCreateNestedManyWithoutProducentInput
    podwykonawcy?: podwykonawcyUncheckedCreateNestedOneWithoutUzytkownikInput
  }

  export type uzytkownicyCreateOrConnectWithoutFreelancerzyInput = {
    where: uzytkownicyWhereUniqueInput
    create: XOR<uzytkownicyCreateWithoutFreelancerzyInput, uzytkownicyUncheckedCreateWithoutFreelancerzyInput>
  }

  export type uzytkownicyUpsertWithoutFreelancerzyInput = {
    update: XOR<uzytkownicyUpdateWithoutFreelancerzyInput, uzytkownicyUncheckedUpdateWithoutFreelancerzyInput>
    create: XOR<uzytkownicyCreateWithoutFreelancerzyInput, uzytkownicyUncheckedCreateWithoutFreelancerzyInput>
    where?: uzytkownicyWhereInput
  }

  export type uzytkownicyUpdateToOneWithWhereWithoutFreelancerzyInput = {
    where?: uzytkownicyWhereInput
    data: XOR<uzytkownicyUpdateWithoutFreelancerzyInput, uzytkownicyUncheckedUpdateWithoutFreelancerzyInput>
  }

  export type uzytkownicyUpdateWithoutFreelancerzyInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rola?: roleUpdateOneRequiredWithoutUzytkownicyNestedInput
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutFreelancerzyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    rola_id?: IntFieldUpdateOperationsInput | number
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type artykulyCreateManyAutorInput = {
    id?: number
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    kategoria_id: number
  }

  export type produktyCreateManyProducentInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    cena?: Decimal | DecimalJsLike | number | string | null
    kategoria_id: number
    data_dodania?: Date | string | null
  }

  export type zamowieniaCreateManyUzytkownikInput = {
    id?: number
    produkt_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    status_id: number
  }

  export type zleceniaCreateManyZleceniodawcaInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
    typ_id: number
  }

  export type zleceniaCreateManyWykonawcaInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
    typ_id: number
  }

  export type projektyCreateManyAutorInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    data_utworzenia?: Date | string | null
    status_id: number
  }

  export type producentkatalogCreateManyProducentInput = {
    id?: number
    opis?: string | null
    strona_www?: string | null
    kategoria_id: number
  }

  export type artykulyUpdateWithoutAutorInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategoria?: kategorieartykulowUpdateOneRequiredWithoutArtykulyNestedInput
  }

  export type artykulyUncheckedUpdateWithoutAutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type artykulyUncheckedUpdateManyWithoutAutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type produktyUpdateWithoutProducentInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kategoria?: kategorieproduktowUpdateOneRequiredWithoutProduktyNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutProduktNestedInput
  }

  export type produktyUncheckedUpdateWithoutProducentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutProduktNestedInput
  }

  export type produktyUncheckedUpdateManyWithoutProducentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zamowieniaUpdateWithoutUzytkownikInput = {
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    produkt?: produktyUpdateOneRequiredWithoutZamowieniaNestedInput
    status?: statusyzamowienUpdateOneRequiredWithoutZamowieniaNestedInput
  }

  export type zamowieniaUncheckedUpdateWithoutUzytkownikInput = {
    id?: IntFieldUpdateOperationsInput | number
    produkt_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type zamowieniaUncheckedUpdateManyWithoutUzytkownikInput = {
    id?: IntFieldUpdateOperationsInput | number
    produkt_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaUpdateWithoutZleceniodawcaInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wykonawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_wykonawcaNestedInput
    status?: statusyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
    typ?: typyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
  }

  export type zleceniaUncheckedUpdateWithoutZleceniodawcaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaUncheckedUpdateManyWithoutZleceniodawcaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaUpdateWithoutWykonawcaInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zleceniodawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_zleceniodawcaNestedInput
    status?: statusyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
    typ?: typyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
  }

  export type zleceniaUncheckedUpdateWithoutWykonawcaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaUncheckedUpdateManyWithoutWykonawcaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type projektyUpdateWithoutAutorInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: statusyprojektowUpdateOneRequiredWithoutProjektyNestedInput
  }

  export type projektyUncheckedUpdateWithoutAutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type projektyUncheckedUpdateManyWithoutAutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type producentkatalogUpdateWithoutProducentInput = {
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    kategoria?: kategorieproducentowUpdateOneRequiredWithoutProducentkatalogNestedInput
  }

  export type producentkatalogUncheckedUpdateWithoutProducentInput = {
    id?: IntFieldUpdateOperationsInput | number
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type producentkatalogUncheckedUpdateManyWithoutProducentInput = {
    id?: IntFieldUpdateOperationsInput | number
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    kategoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type uzytkownicyCreateManyRolaInput = {
    id?: number
    imie?: string | null
    nazwisko?: string | null
    email: string
    haslo: string
    data_rejestracji?: Date | string | null
  }

  export type uzytkownicyUpdateWithoutRolaInput = {
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUpdateManyWithoutAutorNestedInput
    produkty?: produktyUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateWithoutRolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    artykuly?: artykulyUncheckedUpdateManyWithoutAutorNestedInput
    produkty?: produktyUncheckedUpdateManyWithoutProducentNestedInput
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutUzytkownikNestedInput
    zlecenia_zleceniodawca?: zleceniaUncheckedUpdateManyWithoutZleceniodawcaNestedInput
    zlecenia_wykonawca?: zleceniaUncheckedUpdateManyWithoutWykonawcaNestedInput
    projekty?: projektyUncheckedUpdateManyWithoutAutorNestedInput
    producent_katalog?: producentkatalogUncheckedUpdateManyWithoutProducentNestedInput
    podwykonawcy?: podwykonawcyUncheckedUpdateOneWithoutUzytkownikNestedInput
    freelancerzy?: freelancerzyUncheckedUpdateOneWithoutUzytkownikNestedInput
  }

  export type uzytkownicyUncheckedUpdateManyWithoutRolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    imie?: NullableStringFieldUpdateOperationsInput | string | null
    nazwisko?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    haslo?: StringFieldUpdateOperationsInput | string
    data_rejestracji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type artykulyCreateManyKategoriaInput = {
    id?: number
    tytul?: string | null
    tresc?: string | null
    data_publikacji?: Date | string | null
    autor_id: number
  }

  export type artykulyUpdateWithoutKategoriaInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: uzytkownicyUpdateOneRequiredWithoutArtykulyNestedInput
  }

  export type artykulyUncheckedUpdateWithoutKategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
  }

  export type artykulyUncheckedUpdateManyWithoutKategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    tresc?: NullableStringFieldUpdateOperationsInput | string | null
    data_publikacji?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
  }

  export type zamowieniaCreateManyProduktInput = {
    id?: number
    uzytkownik_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
    status_id: number
  }

  export type zamowieniaUpdateWithoutProduktInput = {
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uzytkownik?: uzytkownicyUpdateOneRequiredWithoutZamowieniaNestedInput
    status?: statusyzamowienUpdateOneRequiredWithoutZamowieniaNestedInput
  }

  export type zamowieniaUncheckedUpdateWithoutProduktInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type zamowieniaUncheckedUpdateManyWithoutProduktInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type produktyCreateManyKategoriaInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    producent_id: number
    cena?: Decimal | DecimalJsLike | number | string | null
    data_dodania?: Date | string | null
  }

  export type produktyUpdateWithoutKategoriaInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producent?: uzytkownicyUpdateOneRequiredWithoutProduktyNestedInput
    zamowienia?: zamowieniaUpdateManyWithoutProduktNestedInput
  }

  export type produktyUncheckedUpdateWithoutKategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    producent_id?: IntFieldUpdateOperationsInput | number
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zamowienia?: zamowieniaUncheckedUpdateManyWithoutProduktNestedInput
  }

  export type produktyUncheckedUpdateManyWithoutKategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    producent_id?: IntFieldUpdateOperationsInput | number
    cena?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_dodania?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zamowieniaCreateManyStatusInput = {
    id?: number
    uzytkownik_id: number
    produkt_id: number
    ilosc?: number | null
    data_zamowienia?: Date | string | null
  }

  export type zamowieniaUpdateWithoutStatusInput = {
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uzytkownik?: uzytkownicyUpdateOneRequiredWithoutZamowieniaNestedInput
    produkt?: produktyUpdateOneRequiredWithoutZamowieniaNestedInput
  }

  export type zamowieniaUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    produkt_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zamowieniaUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    uzytkownik_id?: IntFieldUpdateOperationsInput | number
    produkt_id?: IntFieldUpdateOperationsInput | number
    ilosc?: NullableIntFieldUpdateOperationsInput | number | null
    data_zamowienia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zleceniaCreateManyStatusInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    typ_id: number
  }

  export type zleceniaUpdateWithoutStatusInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zleceniodawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_zleceniodawcaNestedInput
    wykonawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_wykonawcaNestedInput
    typ?: typyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
  }

  export type zleceniaUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typ_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaCreateManyTypInput = {
    id?: number
    tytul?: string | null
    opis?: string | null
    zleceniodawca_id: number
    wykonawca_id: number
    data_utworzenia?: Date | string | null
    status_id: number
  }

  export type zleceniaUpdateWithoutTypInput = {
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zleceniodawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_zleceniodawcaNestedInput
    wykonawca?: uzytkownicyUpdateOneRequiredWithoutZlecenia_wykonawcaNestedInput
    status?: statusyzlecenUpdateOneRequiredWithoutZleceniaNestedInput
  }

  export type zleceniaUncheckedUpdateWithoutTypInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type zleceniaUncheckedUpdateManyWithoutTypInput = {
    id?: IntFieldUpdateOperationsInput | number
    tytul?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    zleceniodawca_id?: IntFieldUpdateOperationsInput | number
    wykonawca_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
  }

  export type projektyCreateManyStatusInput = {
    id?: number
    nazwa?: string | null
    opis?: string | null
    autor_id: number
    data_utworzenia?: Date | string | null
  }

  export type projektyUpdateWithoutStatusInput = {
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: uzytkownicyUpdateOneRequiredWithoutProjektyNestedInput
  }

  export type projektyUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projektyUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    nazwa?: NullableStringFieldUpdateOperationsInput | string | null
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    autor_id?: IntFieldUpdateOperationsInput | number
    data_utworzenia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type producentkatalogCreateManyKategoriaInput = {
    id?: number
    producent_id: number
    opis?: string | null
    strona_www?: string | null
  }

  export type producentkatalogUpdateWithoutKategoriaInput = {
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
    producent?: uzytkownicyUpdateOneRequiredWithoutProducent_katalogNestedInput
  }

  export type producentkatalogUncheckedUpdateWithoutKategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    producent_id?: IntFieldUpdateOperationsInput | number
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type producentkatalogUncheckedUpdateManyWithoutKategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    producent_id?: IntFieldUpdateOperationsInput | number
    opis?: NullableStringFieldUpdateOperationsInput | string | null
    strona_www?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}